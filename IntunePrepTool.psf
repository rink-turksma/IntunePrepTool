<File version="3.2">
  <FileID>373d466f-0843-40eb-9006-241e20fcf1fd</FileID>
  <LastExport>133227411031353429</LastExport>
  <Preview>iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAAAXNSR0IArs4c6QAAAARnQU1BAACx
jwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABPFSURBVHhe7d3Zc1TZfcBx/01581+RlySVKlfl
IW/5D/KQykNeEsdvscdLPAs2GsYOY3sYxCbQgtRa0C61FoTQCkgaMcBsdgYP41/qXiEhqVtq0adx
fKo/n6pvIfr0vS01qurD7Xtuf+c7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAECKf/re9/6h41zHrzt+9s55SZKU
aT9/t6PjnV9c6Pjud7/bcfzFvsbf/O3ffTS6sBlzm1/EzNpTSZLUqtbP0Fnud5b7vGzh0e/j8q3B
OP56X+P8hQ87Fh59FX3Tq9EvSZKSu138ObMWvZP3T27ifnmfgUb3m7xf3qfYb7HN8bH9+iZXyv31
T6/HzMpu4wlAcahg8dGXUamux2B1I/qr29E/txOVxacxOL8dg7Pre1U3YnBuMyr7Xxcd/vrg75sx
vPAwhqobR+6793Ux9iiGDu2n/HNu89B9Du1PkqQMG5rfjBuD8/Fxz1R09k3X7XLvVFzpr8bVgWr5
dWffTFy5PRuXeqbj497puNI/e3C/4j7l34vbb8+U2xV13n55e990+VhdQwvla/Dkva2zTQCWtn8f
Q/MPY2huI1amfxvLI2/HeOe/xPDtD2N4cTeGi7HqelRm1mJ0aSdGFh7G8PyDGFl8VHbn7nbcKf/c
ieG59bg5OB0DsxsxWtx+dyvuLG6V2w3NrsSNgYm4PbUao0vb5bbFn5WZlajMbpT7lCQp94rXt+IF
um/yfvmaV6luxMDsZlnxend7qnjdWytf9D/umS7/h983uRq/u1aJ6z3DceVmJT7uGS/vW/zP/1L3
ZDk5KP6j3D12Ly5e7o2Ll/vi4qXu6OybjIHZ9egdX46r/dXydXV6ebvxBODdX1zoWHn8dYzeexwT
c9XYuf738enkD2Porb+KoVvnYnz1yxi/txMj1ZW4NTgVPSPVuFUZi6t9o+WkYHD6fnQPTUffxL24
PTYfXZXx6OzqjxsDk3F7/G70jMxG7+h89AzPxmAxAegbid6xxei9MxeV6eXoG5uPm5WJ6J9ei4nl
7Rhb2pIkKesmlnfixtBCDEytxWD1QVzuGY8rt0ai89ZwdPZOlrcNVTfjemW+fNEemnsQt0bvx/Wu
/rj4mytx/Xp3XL45HENzj8qj58WL/43BhfKIeXGI/8KHN2K+OhcfXe6Kzv7ZGJx7UE4quoYWY3Jl
N6qrZ3gL4N3zH3RsPHsRk+u/j+rYpVi/+o+x1P3v0fvffx2jk6Mxvf55TK9+GhN3N+NG33B09Y/F
9d7B6BoYKycC13oqcaN/LG4O3ImPrnXH1d6huNE/GZWphbg5MBaXb/TGtb5iNtMf/ZNLUZlYiO7B
qbjRPxrXi/0NjMa13uHyKMPM2uOYWtmVJCnrZtY+jVsjd2NwdjOGF7ej48Prce3azbh29WZc+E1X
jCwWR9MfRdfwYjkJKL6uVB/G+xevxvn3P4zzHRfjt9cGY3Tpk/L18drAXLm/saWd8sX+7fO/jV9d
7Iyfv/eruNo/E+P3PiknCrfuLEV181ksbDxpPAE4d/6DjodfRMxufhFzSwtRne6L6elKTM6Mxczq
blQ3npbNrj2OibsPY3J5JyaWHsXY4oO4M7caw3NrMXl/J6aWt2N0YSOKFQUza0+iuv44pu4X930Y
lYm56B6ajen1J+Vtk/cexUh1PaaWt2KkuhYT97ZievXx3uOsP5EkKevmH3wW3XfuxXD1Qfl2+MD0
evlCX1SZ2YjRxe0Yu7sdN4fvlv+zH13YKm+7PblavtAXDc1ulrfdmX8U1ysL0T2yFONLOzG6uBW3
J1ait2hsOUbmH5b7Gq5uRs/YcixufRlLD5+dZQLw647tryIWH30Rq0/+FCtPI1aLnkWsfvrHKN4e
2Ot5rD35JtY+/ePen2UvYv3JN+X9il79/XmsPn6+d9vTF7Gy+4e4v/u83Pbgvk9fHGyzd/vz8jEk
Scq94nVtfvPz8oV9bLH4z/AnMbn8uKz4urhtdGE7ZlefRnX9Wfn13v12D+43fnf/fltRXf8splee
vLrfvd29+97bjfG7OzG2WPwnfLu8z92tr2J564uzTAA+6Pj0eZT/m//x27+Mt94+f9CP3ynqONLR
8bOOvX9k/Mc144fGjt1++n4bbHtou3rjzY4Vz8vBWJ3x07Y9+1ij8WbHGo23Zuzwc1RvvNmxw/+m
b+xnOWX8+O01277GmN/PemONxlsz9sae+z/Hz3LK+PHba7Z9jbE39hy1y+/n2+fjJ+++Hz9970L8
9L2Xf5572cFt77+8z/vxs3MXyvbGXo0XXx+9fW/sJ8fHz12I//rZe9E3NB4bT7+J5a0vzzYBePpt
xI2+O/HP//aD+OBqJX75u+69PirqifOXeuL8Rz3l1wdj5fje7TVj+9sdHituOzR+dOzwtnt/r7vf
eo956rZHH7N221P2W+8xL9Xb7pRt642d9pgn7Hf/56o3VvOYZ9jv/ljNtkn73but/lidbU8be93n
6HV/P4+N7Y0f3e/Rxzztd+zk/dZ+v8e3rfOznLJtw8ds9vfz8PN32mOesN/9n6veWM1jnmG/+2M1
2ybtd++2+mMvH7Pe71G9x2ziOarZb71t640dfE91vt+Dx2zd7+f+WL3HPOu2r/eYdcaPj/05fz/r
jZ3w3J9p2/2xht/v3m31x874+3mpN97quBydNwdi+4s/vcYE4EXE9b478YO3zsXYvZ1ymYEkScqj
4toDXXeWontwIh4+e50jAC8nAN//4bvl2YW9E8uSJCmTiusNdA5Uy9V3jz578foTgP/8UTEB2KzZ
sSRJ+svtYALQ3/QE4D0TAEmSMiv5CMAP3jIBkCQpt/YnALcGxpubADgCIElSfh1MACpNTwCcBChJ
Um4lTwC+/8N3TAAkScosEwBJktqwVycBNjkB8BaAJEn5ZRmgJEltWPIEwDJASZLyqwVvAZgASJKU
W8knAboUsCRJ+ZU8AfBhQJIk5VcLJgCWAUqSlFvJlwJ2BECSpPxK/jAg5wBIkpRfycsArQKQJCm/
ko8AuA6AJEn5lXwOgCMAkiTlV/IqAJ8FIElSfiVPACwDlCQpv5LfAjABkCQpv5JPAvQWgCRJ+WUZ
oCRJbVjyEQDLACVJyi8fByxJUhuWvArApYAlScqvVxOAieYmAD4MSJKk/Eo+AmAZoCRJ+ZV8DoAj
AJIk5VfyKgDnAEiSlF/J1wGwDFCSpPxqwREAEwBJknIr+SRAbwFIkpRflgFKktSGJR8BsAxQkqT8
asHHATsCIElSbrXgJEATAEmScit5GaBVAJIk5VfyEQDXAZAkKb+SzwFwBECSpPxKXgXgHABJkvIr
eQJgFYAkSfnVggmA6wBIkpRbPg5YkqQ2zDJASZLasOQJgGWAkiTlV/JbAI4ASJKUX8knAfo4YEmS
8it5AuAkQEmS8qsFEwDLACVJyq3kSwE7AiBJUn4lfxiQcwAkScqv5GWAVgFIkpRfyUcAXAdAkqT8
Sj4HwBEASZLyK3kVgI8DliQpv5InAJYBSpKUXyYAkiS1YS34LABvAUiSlFuWAUqS1IYlTwAsA5Qk
Kb9a8BaACYAkSbmVfBKgSwFLkpRfyRMAHwYkSVJ+tWACYBmgJEm5lXwpYEcAJEnKr+QPA3IOgCRJ
+ZW8DNAqAEmS8iv5CIDrAEiSlF/J5wA4AiBJUn4lrwLwWQCSJOVX8gTAMkBJkvIr+S0AywAlScqv
5JMAvQUgSVJ+WQYoSVIblnwEwDJASZLyy8cBS5LUhiWvAnApYEmS8uvVBGCiuQmAVQCSJOVX8hEA
1wGQJCm/ks8BcARAkqT8Sl4F4BwASZLyK/k6AJYBSpKUXy04AmACIElSbiWfBOgtAEmS8ssyQEmS
2rDkIwCWAUqSlF8+DliSpDasBScBmgBIkpRbycsArQKQJCm/ko8AuA6AJEn5lXwOgCMAkiTlV/Iq
AOcASJKUX8kTAKsAJEnKrxZMAFwHQJKk3PJxwJIktWGWAUqS1IYlTwAsA5QkKb+S3wJwBECSpPxK
PgnQxwFLkpRfyRMAJwFKkpRfLZgAWAYoSVJuJV8K2BEASZLyK/nDgJwDIElSfiUvA7QKQJKk/Eo+
AuA6AJIk5VfyOQCOAEiSlF/JqwB8HLAkSfmVPAGwDFCSpPwyAZAkqQ1LPgnQWwCSJOXX/gSgyzJA
SZLap+QjAJYBSpKUXz4OWJKkNiz5JECXApYkKb+SJwA+DEiSpPxqwQTAMkBJknIr+VLAjgBIkpRf
yasAnAMgSVJ++ThgSZLasOQjAK4DIElSfiWfA+AIgCRJ+dWCVQBOApQkKbdaMAGwDFCSpNxqwQTA
EQBJknIr+SRAHwcsSVJ+WQYoSVIblnwEwDJASZLyy8cBS5LUhiWfBOhSwJIk5derCcBEcxMAqwAk
Scqv5CMArgMgSVJ+JZ8D4AiAJEn5lbwKwDkAkiTlV/J1ACwDlCQpv5KPAJgASJKUX8knAboOgCRJ
+WUZoCRJbVjyEQDLACVJyq+DCYBlgJIktU/JJwH6OGBJkvIreRmgkwAlScqv5CMAlgFKkpRfyecA
OAIgSVJ+Ja8CcA6AJEn5lTwBsApAkqT8asEEwHUAJEnKLR8HLElSG2YZoCRJbVjyBMAyQEmS8iv5
LQBHACRJyq/kkwD3lgGaAEiSlFPJEwAnAUqSlF8tmABYBihJUm4lXwrYEQBJkvIr+cOAnAMgSVJ+
JS8DtApAkqT8Sj4C4DoAkiTlV/I5AI4ASJKUX8mrAHwcsCRJ+ZU8AbAMUJKk/DIBkCSpDUs+CdBb
AJIk5df+BKDLMkBJktqn5CMAlgFKkpRfPg5YkqQ2LPkkQJcCliQpv5InAD4MSJKk/GrBBMAyQEmS
civ5UsCOAEiSlF/JqwCcAyBJUn75OGBJktqw5CMArgMgSVJ+JZ8D4AiAJEn51YJVAE4ClCQpt1ow
AbAMUJKk3GrBBMARAEmSciv5JEAfByxJUn5ZBihJUhuWfATAMkBJkvLLxwFLktSGJZ8E6FLAkiTl
16sJwERzEwCrACRJyq/kIwCuAyBJUn4lnwPgCIAkSfmVvArAOQCSJOVX8nUALAOUJCm/ko8AmABI
kpRfyScBug6AJEn5lbwMsDgHYGj+QbkjSZKUR7enVuJKZe71JwDPvo242jMc//ofP4qbY8vRWamW
XTmhNzHWaLzZsUbjKWOnjZ/WadudNtZovNmxRuPNjjWq2W0bPfdvYqzReLNjjcZTxhqNH78tdazR
eLNjjcabHWtUs9t67s821mj8+G2pY43Gmx1rNN7sWKOOb3t1cC5+dWM0rnQPxdbn3559AvD4ecRo
9X78z++uRPfgZHT1j5YVJxPcrIyX7ykUFX/vKtofGzg89nL8YGys7tj++MFYvf2e8JjFn3W3PTRW
s+3hn+XI97t3//pjtfut+5infb/7308T+93/3vb32/A5qoyf/Bwdecyjz/3B93vKc3Rkv8ce8/jP
cvz7PfLzHH/MIz9rnefo0HNY9zGb3W+d5+hg23b6/UzY7/73dvzf++Tn6JT9/j/+fh7eb81jNnqO
XnbkZ6mz31Y89wfb1vl+Gz/3p/x+Jj73++O1Yyf/LG/qOWrV7+f+tvXGmnmOTnzuD2970vdb59/7
+H6PP2Zn92BU796PzaffnG0C8IuOX3fs/m/Eyu7XsfNlxMNn35SHD4oefvZN+feDPjs8dmy8+Prw
djVjZ93vyWONxhuOnfA9nfaznGm/J441t9+a7ert9/DYoX+zmv0e+jlrxmr2W/scHdnvscds9LMc
+X048THrfb+n7/dsY29qvyePNRpvOFbz/Z7w+9Cyn6W5/dZsV2+/x8ZO3O+hn7NmrGa/tc/R/lg5
fni7cvyEx6y33xPH6n2/f8n7PXmsZjzxud8ff3M/S3P7rdmu3n6Pje3vd//nOjp21u+3dtv9sfrb
njZ21sc8Or71+YvYfPrHWP7k61j95A+NJwA//fl7Hz39OuL+9pfljEGSJOXb6u4fYmP3q8YTAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAADgRP8HI7JhHSBlJIEAAAAASUVORK5CYII=</Preview>
  <Form>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
KaZVROdoQqsI0mTGxSMdDinzZo+y5qRSJUHlFdFg5LGNIfyjxXjMwYZC2QUsEypKUmvTp4u5JHPD
N0keyxjla4GJawDyVp3qIEPvQQBxYnK6mcNk0dMdDg6nQ2biui9sktQ/RnfFN+MhwFqpmr7W+Egl
lNfnII5Fewv56qaFfPIfK5NM1qdIujA0PLnEOHXNtBisEQdRllAX1p+DmILGMr1Zdae1TDyF1OFK
piDOOOXr/8R+odleJR5ux3Je/0+j05uUe2P9T0Xw1/y4mH/R/1FYCzMlAX5QuB0Wur1yPl+7bRVv
PieFR/1nRem+Xa70flw9lUealNBatzT/MlnWu9WZNE0+vD5JdPKjlc6LvffX/pyT1Ydpv1/sSH15
+tp+6Uga3fkSXyu1TrNYTj2X59Ld7ar64yqZf82y7drd+y2tjjMfr+8P5cZ9tVSsdQWuUltI+Zf6
ctnosfUHaToo1kttXhbbjMy0pvWb9Xo2YpmW+pIdCe/M8PPHlVr5PZEavQe+/6KkqpPuw5TvXuc/
vr5eJ3dyoTSVR/mbm8517osupSq/71a15rqe634VVu+Ju8+XxutDZbV+aaZuClqd/nFV4l7XxY/1
3eO61GSy5dRo3HifrQrvYurh873amL+nCvPSS50uVCf553pm9DRgmver55vZTTHZ6yj5Rv7m8fm1
tBZfioUfV4NHVlq98p0Hvt29bT+2Wl01y5RWYuaj0FuLfLHHv3Dr/pyt3Uu3wkwdlJnc8nExHbY+
O3z9MVlaCup7fiKzNyVR+3G1TKpTLreoTTofH/WcmkjdlMtSvcaPhds635uoq8kD+5ifvvbuxs98
bpB91LK98uKjvu5P1HxCYdbVu3G30rx5uCsUf1zVZsXKQFjXihxPZ9jMbaFzW8z1H28HdPV1Uhk9
y8+PueTkmm/cXwv0LFfIa9l+9r7OsC+dWkPIZcXbXLqt3D51G42XH1fSdSszzmVr4qjHfLWk8viO
fXleThbr7s3n+qnADh4bNwOu12YSv0uNx9RTSRwNnq+zk/y0/3VdlrjRqjbIMyzNjZ/0PV23u430
9OVhWeLryu90hq+NJw+Nwc288jV+v2VWbOqpO5k1c0/15kjUf5cty/znc/+JLwncI59ujBfFxugp
PxCWTeHH1Tif+eKLmdT0tSKtW9drcSjc31dS0odWrMxv7ibr1euq0U5WFHad/xJu37Of1cKS/WwV
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</Form>
  <Code><![CDATA[


class config_customerinfo {
	[string]$customername
	[string]$customPrivacyURL
	[string]$logfoldertarget
	[string]$packagefolder
	[string]$tenanturl
	[string]$downloadpath
	[string]$buildingblockspath
}
function refreshTenants
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$config_treeview3.BeginUpdate()
		$config_treeview3.Refresh()
		$config_treeview3.Nodes.Clear()
		$Root = $config_treeview3.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			
			$node = $Root.Nodes.Add($tenantCSV.customername)
			#$upload_upload_listbox1.Items.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			$node.ContextMenuStrip = $config_tenants_contextmenustrip1
			
		}
		$Root.Expand()
		$config_treeview3.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function refreshTenantsUpload
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$upload_treeview2.BeginUpdate()
		$upload_treeview2.Refresh()
		$upload_treeview2.Nodes.Clear()
		$upload_treeview2.CheckBoxes = $true
		$Root = $upload_treeview2.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			#$upload_treeview2.Nodes.Add($tenantCSV.customername)
			$node = $Root.Nodes.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			
			
		}
		$Root.Expand()
		$upload_treeview2.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function PowershellISEOnTop
{
	Add-Type @"
using System;
using System.Runtime.InteropServices;
public class User32 {
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
    
    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
    
    public static IntPtr HWND_TOPMOST = new IntPtr(-1);
    public static IntPtr HWND_NOTOPMOST = new IntPtr(-2);
    public const UInt32 SWP_NOSIZE = 0x0001;
    public const UInt32 SWP_NOMOVE = 0x0002;
    public const UInt32 SWP_SHOWWINDOW = 0x0040;
}
"@
	$hwnd = [User32]::FindWindow($null, "Administrator: Windows PowerShell ISE")
	if ($hwnd -ne [IntPtr]::Zero)
	{
		[User32]::SetWindowPos($hwnd, [User32]::HWND_TOPMOST, 0, 0, 0, 0, [User32]::SWP_NOSIZE -bor [User32]::SWP_NOMOVE -bor [User32]::SWP_SHOWWINDOW)
	}
}



$IntunePrepTool_Load = {
	Set-ControlTheme $IntunePrepTool -Theme Dark
	#Set-ControlTheme $config_tabpage -Theme Dark
	$scaledHeight = ConvertTo-ScaledPixel -Form $IntunePrepTool -Height 720
	$scaledWidth = ConvertTo-ScaledPixel -Form $IntunePrepTool -Width 1725
	

	if (!(Test-Path -Path "c:\users\$env:username\.IntunePrepTool"))
	{
		
		New-Item -ItemType Directory -Path "c:\users\$env:username\.IntunePrepTool"
	}
	
	try
	{
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			Copy-Item -Path "C:\Program Files\IntunePrepTool\config_customerinfo.csv" -Destination "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
			Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
			Update-ListBox $update_exe_listbox1 $cis.customername -Append
		}
		
	}
	catch
	{
		
		[void][System.Windows.Forms.MessageBox]::Show('Add customers in the config tab', 'Please Add Customer first')
		
	}
	
	$rechten = [bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544")
	if ($rechten -eq $false)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Admin Rights needed!, Please run as Administrator', 'Please run as Administrator') # Casting the method to [void] suppresses the output. 
		
	}
	else
	{
		$restrictionpolicy = Get-ExecutionPolicy -ErrorAction SilentlyContinue;
		if ($restrictionpolicy -ne 'Unrestricted')
		{
			
			if ([System.Windows.Forms.MessageBox]::Show('Set-ExecutionPolicy Unrestricted?; Please reopen IntunePrepTool', 'Powershell Execution Policy needs to be unrestricted', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	Set-ExecutionPolicy Unrestricted

'@
				if (Test-Path "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1")
				{
					powershell.exe -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
				}
				else
				{
					$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1" -Confirm:$false -Force
					Start-Sleep 1
					powershell -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
				}
			}
		}
		else
		{
			if (Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf)
			{
				Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
			}
			$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
			if ($ResolveWingetPath)
			{
				$WingetPath = $ResolveWingetPath[-1].Path
			}
			$wingetexe = $ResolveWingetPath
			
			if (Test-path $wingetexe)
			{
				$wingetOption = 1
				$version = & $wingetexe --version
			}
			else
			{
				$wingetOption = 2
				$version = winget --version
			}
			if (($version -notlike 'v1.9*') -and ($version -notlike 'v1.10*') -and ($version -notlike 'v1.11*'))
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use button to Install / Update Winget', 'Winget missing or wrong version')
				
			}
			else
			{
			<#
			if ($wingetOption -like 1)
			{
				& $wingetexe search rink-turksma.IntunePrepTool --accept-source-agreements 2>$null
				$IntunePrepToolversion = & $wingetexe list --id rink-turksma.IntunePrepTool
			}
			else
			{
				winget search rink-turksma.IntunePrepTool --accept-source-agreements
				$IntunePrepToolversion = winget list --id rink-turksma.IntunePrepTool
			}
			Write-Host $IntunePrepToolversion
			if ($IntunePrepToolversion | Select-String '\bVersion\s+Available\b')
			{
				[void][System.Windows.Forms.MessageBox]::Show('Use button on config page to check for updates ', 'New version IntunePrepTool available')
			} #>
			}
			
			
			
			try
			{
				
				Get-ChildItem -Path "IntuneWinAppUtil.exe" -ErrorAction Stop
			}
			catch
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download Microsoft Win32 Content Prep Tool. Place EXE file in same directory as this script', 'IntuneWinAppUtil missing') # Casting the method to [void] suppresses the output. 
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			}
			if (Test-Path 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -PathType Leaf)
			{
				$reqPSModules = Get-Content 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt'
				if ($reqPSModules -like 'false')
				{
					Remove-Item 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Confirm:$false -Force
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
				}
				else
				{
					
				}
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
			}
			
			
			if (!(test-path -path 'C:\ProgramData\chocolatey'))
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use the Button: "Install Chocolatey"', 'Chocolatey missing') # Casting the method to [void] suppresses the output. 
				
			}
			
			
			refreshTenants
			refreshTenantsUpload
			
			$config_tabpage.Dock = 'Fill'
			$config_tabpage.Visible = $true
			$config_tabpage.Enabled = $true
			
			
			
			
			$BuildingBlocks_datagridview1.DataSource = $BuildingBlocksTable;
			$BuildingBlocks_datagridview2.DataSource = $BuildingBlocksTable2;
			$BuildingBlocks_datagridview3.DataSource = $BuildingBlocksTable3;
			
		}
	}
}





$darkToolStripMenuItem_Click = {
	#TODO: Place custom script here
	Set-ControlTheme -Control $IntunePrepTool -Theme Dark
}

$lightToolStripMenuItem_Click = {
	Set-ControlTheme -Control $IntunePrepTool -Theme Light
}

#region Control Theme Helper Function
<#
	.SYNOPSIS
		Applies a theme to the control and its children.
	
	.PARAMETER Control
		The control to theme. Usually the form itself.
	
	.PARAMETER Theme
		The color theme:
		Light
		Dark

	.PARAMETER CustomColor
		A hashtable that contains the color values.
		Keys:
		WindowColor
		ContainerColor
		BackColor
		ForeColor
		BorderColor
		SelectionForeColor
		SelectionBackColor
		MenuSelectionColor
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -Theme Dark
	
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -CustomColor @{ WindowColor = 'White'; ContainerBackColor = 'Gray'; BackColor... }
	.NOTES
		Created by SAPIEN Technologies, Inc.
#>
function Set-ControlTheme
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.ComponentModel.Component]$Control,
		[ValidateSet('Light', 'Dark')]
		[string]$Theme = 'Dark',
		[System.Collections.Hashtable]$CustomColor
	)
	
	$Font = [System.Drawing.Font]::New('Segoe UI', 9)
	
	#Initialize the colors
	if ($Theme -eq 'Dark')
	{
		$WindowColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ContainerColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
		$BackColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ForeColor = [System.Drawing.Color]::White
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::DimGray
	}
	else
	{
		$WindowColor = [System.Drawing.Color]::White
		$ContainerColor = [System.Drawing.Color]::WhiteSmoke
		$BackColor = [System.Drawing.Color]::Gainsboro
		$ForeColor = [System.Drawing.Color]::Black
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::LightSteelBlue
	}
	
	if ($CustomColor)
	{
		#Check and Validate the custom colors:
		$Color = $CustomColor.WindowColor -as [System.Drawing.Color]
		if ($Color) { $WindowColor = $Color }
		$Color = $CustomColor.ContainerColor -as [System.Drawing.Color]
		if ($Color) { $ContainerColor = $Color }
		$Color = $CustomColor.BackColor -as [System.Drawing.Color]
		if ($Color) { $BackColor = $Color }
		$Color = $CustomColor.ForeColor -as [System.Drawing.Color]
		if ($Color) { $ForeColor = $Color }
		$Color = $CustomColor.BorderColor -as [System.Drawing.Color]
		if ($Color) { $BorderColor = $Color }
		$Color = $CustomColor.SelectionBackColor -as [System.Drawing.Color]
		if ($Color) { $SelectionBackColor = $Color }
		$Color = $CustomColor.SelectionForeColor -as [System.Drawing.Color]
		if ($Color) { $SelectionForeColor = $Color }
		$Color = $CustomColor.MenuSelectionColor -as [System.Drawing.Color]
		if ($Color) { $MenuSelectionColor = $Color }
	}
	
	#Define the custom renderer for the menus
	#region Add-Type definition
	try
	{
		[SAPIENTypes.SAPIENColorTable] | Out-Null
	}
	catch
	{
		if ($PSVersionTable.PSVersion.Major -ge 7)
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing', 'System.Drawing.Primitives'
		}
		else
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing'
		}
		Add-Type -ReferencedAssemblies $Assemblies -TypeDefinition "
using System;
using System.Windows.Forms;
using System.Drawing;
namespace SAPIENTypes
{
    public class SAPIENColorTable : ProfessionalColorTable
    {
        Color ContainerBackColor;
        Color BackColor;
        Color BorderColor;
		Color SelectBackColor;

        public SAPIENColorTable(Color containerColor, Color backColor, Color borderColor, Color selectBackColor)
        {
            ContainerBackColor = containerColor;
            BackColor = backColor;
            BorderColor = borderColor;
			SelectBackColor = selectBackColor;
        } 
		public override Color MenuStripGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuStripGradientEnd { get { return ContainerBackColor; } }
        public override Color ToolStripBorder { get { return BorderColor; } }
        public override Color MenuItemBorder { get { return SelectBackColor; } }
        public override Color MenuItemSelected { get { return SelectBackColor; } }
        public override Color SeparatorDark { get { return BorderColor; } }
        public override Color ToolStripDropDownBackground { get { return BackColor; } }
        public override Color MenuBorder { get { return BorderColor; } }
        public override Color MenuItemSelectedGradientBegin { get { return SelectBackColor; } }
        public override Color MenuItemSelectedGradientEnd { get { return SelectBackColor; } }      
        public override Color MenuItemPressedGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientEnd { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientMiddle { get { return ContainerBackColor; } }
        public override Color ImageMarginGradientBegin { get { return BackColor; } }
        public override Color ImageMarginGradientEnd { get { return BackColor; } }
        public override Color ImageMarginGradientMiddle { get { return BackColor; } }
    }
}"
	}
	#endregion
	
	$colorTable = New-Object SAPIENTypes.SAPIENColorTable -ArgumentList $ContainerColor, $BackColor, $BorderColor, $MenuSelectionColor
	$render = New-Object System.Windows.Forms.ToolStripProfessionalRenderer -ArgumentList $colorTable
	[System.Windows.Forms.ToolStripManager]::Renderer = $render
	
	#Set up our processing queue
	$Queue = New-Object System.Collections.Generic.Queue[System.ComponentModel.Component]
	$Queue.Enqueue($Control)
	
	Add-Type -AssemblyName System.Core
	
	#Only process the controls once.
	$Processed = New-Object System.Collections.Generic.HashSet[System.ComponentModel.Component]
	
	#Apply the colors to the controls
	while ($Queue.Count -gt 0)
	{
		$target = $Queue.Dequeue()
		
		#Skip controls we already processed
		if ($Processed.Contains($target)) { continue }
		$Processed.Add($target)
		
		#Set the text color
		$target.ForeColor = $ForeColor
		
		#region Handle Controls
		if ($target -is [System.Windows.Forms.Form])
		{
			#Set Font
			$target.Font = $Font
			$target.BackColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.SplitContainer])
		{
			$target.BackColor = $BorderColor
		}
		elseif ($target -is [System.Windows.Forms.PropertyGrid])
		{
			$target.BackColor = $BorderColor
			$target.ViewBackColor = $BackColor
			$target.ViewForeColor = $ForeColor
			$target.ViewBorderColor = $BorderColor
			$target.CategoryForeColor = $ForeColor
			$target.CategorySplitterColor = $ContainerColor
			$target.HelpBackColor = $BackColor
			$target.HelpForeColor = $ForeColor
			$target.HelpBorderColor = $BorderColor
			$target.CommandsBackColor = $BackColor
			$target.CommandsBorderColor = $BorderColor
			$target.CommandsForeColor = $ForeColor
			$target.LineColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.ContainerControl] -or
			$target -is [System.Windows.Forms.Panel])
		{
			#Set the BackColor for the container
			$target.BackColor = $ContainerColor
			
		}
		elseif ($target -is [System.Windows.Forms.GroupBox])
		{
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.Button])
		{
			$target.FlatStyle = 'Flat'
			$target.FlatAppearance.BorderColor = $BorderColor
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.CheckBox] -or
			$target -is [System.Windows.Forms.RadioButton] -or
			$target -is [System.Windows.Forms.Label])
		{
			#$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.ComboBox])
		{
			$target.BackColor = $BackColor
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.TextBox])
		{
			$target.BorderStyle = 'FixedSingle'
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.DataGridView])
		{
			$target.GridColor = $BorderColor
			$target.BackgroundColor = $ContainerColor
			$target.DefaultCellStyle.BackColor = $WindowColor
			$target.DefaultCellStyle.SelectionBackColor = $SelectionBackColor
			$target.DefaultCellStyle.SelectionForeColor = $SelectionForeColor
			$target.ColumnHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.ColumnHeadersDefaultCellStyle.ForeColor = $ForeColor
			$target.EnableHeadersVisualStyles = $false
			$target.ColumnHeadersBorderStyle = 'Single'
			$target.RowHeadersBorderStyle = 'Single'
			$target.RowHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.RowHeadersDefaultCellStyle.ForeColor = $ForeColor
			
		}
		elseif ($PSVersionTable.PSVersion.Major -le 5 -and $target -is [System.Windows.Forms.DataGrid])
		{
			$target.CaptionBackColor = $WindowColor
			$target.CaptionForeColor = $ForeColor
			$target.BackgroundColor = $ContainerColor
			$target.BackColor = $WindowColor
			$target.ForeColor = $ForeColor
			$target.HeaderBackColor = $ContainerColor
			$target.HeaderForeColor = $ForeColor
			$target.FlatMode = $true
			$target.BorderStyle = 'FixedSingle'
			$target.GridLineColor = $BorderColor
			$target.AlternatingBackColor = $ContainerColor
			$target.SelectionBackColor = $SelectionBackColor
			$target.SelectionForeColor = $SelectionForeColor
		}
		elseif ($target -is [System.Windows.Forms.ToolStrip])
		{
			
			$target.BackColor = $BackColor
			$target.Renderer = $render
			
			foreach ($item in $target.Items)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ToolStripMenuItem] -or
			$target -is [System.Windows.Forms.ToolStripDropDown] -or
			$target -is [System.Windows.Forms.ToolStripDropDownItem])
		{
			$target.BackColor = $BackColor
			foreach ($item in $target.DropDownItems)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ListBox] -or
			$target -is [System.Windows.Forms.ListView] -or
			$target -is [System.Windows.Forms.TreeView])
		{
			$target.BackColor = $WindowColor
		}
		else
		{
			$target.BackColor = $BackColor
		}
		#endregion
		
		if ($target -is [System.Windows.Forms.Control])
		{
			#Queue all the child controls
			foreach ($child in $target.Controls)
			{
				$Queue.Enqueue($child)
			}
		}
	}
}
#endregion

$winget_maakPackage_button1_Click = {
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$fid = $config_packagefolder
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$wlo = $Winget_locale_textbox.text
		
	}
	else { $wlo = $null; }
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$wve = $winget_version_textbox1.text
	}
	else { $wve = $null; }
	
	$DisplayName = $winget_displayname_textbox1.text
	$WinGetID = $wid
	$regApp1 = $DisplayName
	$version = $vid
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$outputDirectory = $fid
	Set-Location $PSScriptRoot
	
	$winget_output_textbox3.Text = "`nNew intunewin package will now be created: `r`n"
	$winget_output_textbox3.AppendText("Please wait`r`n")
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$DisplayName\$version\source" -s "$outputDirectory\$DisplayName\$version\source\install.ps1" -o "$outputDirectory\$DisplayName\$version\output" -q
	
	Rename-Item -Path "$outputDirectory\$DisplayName\$version\output\install.intunewin" -NewName "$outputDirectory\$DisplayName\$version\output\$DisplayName.intunewin"
	
	
	$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\output\$DisplayName.intunewin")
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Version: $Version `r`n")
	$winget_output_textbox3.AppendText("Install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$winget_output_textbox3.AppendText("un-install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$winget_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$regApp1\"
	$regkeyApp
	$winget_output_textbox3.AppendText("$regkeyApp `r`n")
	$winget_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$winget_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: $Version `r`n")
	$winget_output_textbox3.AppendText("Please reopen tool to make another winget package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$DisplayName.intunewin"
			DisplayName   = $DisplayName
			Publisher	  = $config_customername_textbox.Text
			AppVersion    = $version;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$DisplayName\$version\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$DisplayName\$version\output\"
	$winget_output_textbox3.AppendText("Config.csv written to: `r`n")
	$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\output\config.csv")
	$winget_output_textbox3.AppendText("  `r`n")
	$winget_output_textbox3.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
	$winget_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	$winget_upload_logo_button1.Visible = $true
	$winget_upload_logo_button1.Enabled = $true;
	$buildingBlokcsCSV = $winget_buildingBlocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$DisplayName\$version\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$DisplayName\BuildingBlocks.csv" -force -NoTypeInformation
		$winget_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$winget_output_textbox3.AppendText("$config_buildingblockspath\$DisplayName\BuildingBlocks.csv `r`n")
		$winget_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
	
	
}



$winget_WingetID_textbox1_TextChanged = {
	#TODO: Place custom script here
	
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$versie_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$config_packagefolder_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_output_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_intunewin_tabpage2_Click = {
	#TODO: Place custom script here
	
}

$config_packagefolder_label_Click = {
	#TODO: Place custom script here
	
}

$winget_checkurl_button1_Click = {
	
	$wgid = $winget_WingetID_textbox1.text
	
	
	$showurl = winget show $wgid --accept-source-agreements
	foreach ($l in $showurl)
	{
		if ($l -like "*Installer Url*") { $url = "https:" + $l.Split(":")[2] }
	}
	
	
	
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show($URL, 'Download source URL') # Casting the method to [void] suppresses the output. 
	
}

$config_customername_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_logfoldertarger_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_save_button_Click = {
	#TODO: Place custom script here
	
	[string]$c_customername = $config_customername_textbox.text
	[string]$c_logfoldertarget = $config_logfoldertarger_textbox.text
	[string]$c_packagefolder = $config_packagefolder_textbox.text
	[string]$c_buildingblocksfolder  = $config_buildingblocks_textbox3.text
	[string]$c_downloadfolder = $config_download_folder_textbox3.Text
	
	[string]$c_customername = $c_customername.Replace(" ","")
	[string]$c_logfoldertarget = $c_logfoldertarget.Replace(" ", "")
	[string]$c_packagefolder = $c_packagefolder.Replace(" ", "")
	[string]$c_buildingblocksfolder = $c_buildingblocksfolder.Replace(" ", "")
	[string]$c_downloadfolder = $c_downloadfolder.Replace(" ", "")

	$config_customerinfo += @([config_customerinfo]@{
			customername    = $c_customername
			logfoldertarget = $c_logfoldertarget
			packagefolder   = $c_packagefolder
			downloadpath    = $c_downloadfolder;
			buildingblockspath = $c_buildingblocksfolder;
		})
	
	
	$existing_customerinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$filtered_customerinfo = $existing_customerinfo | Where-Object { $_.customername -ne $config_customerinfo.customername }
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Force
	$filtered_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Append
	$config_listbox.ResetText()
	try
	{
		$config_import_csv = $null;
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		$config_listbox.ClearSelected()
		$config_listbox.Items.Clear()
		$config_listbox.Refresh()
		foreach ($cis in $config_import_csv)
		{
		
				Update-ListBox $config_listbox $cis.customername -Append
				Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
				Update-ListBox $update_exe_listbox1 $cis.customername -Append
			
			
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$tools_winget_searchtabcontrol1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$exe_openexe_button1_Click = {
	#TODO: Place custom script here
	$exe_openfiledialog1.ShowDialog()
	$exe_label1.Text = $exe_openfiledialog1.SafeFileName
	$exe_label1.Visible = $true;
	$exe_maakPackageDir_button1.Enabled = $true
	$exe_open_Azure_OpenAI_Example_button1.Enabled = $true
	$exe_open_withqquestion_button1.Enabled = $true
}

$exe_label1_Click = {
	#TODO: Place custom script here
	
}

$exe_maakPackageDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$exepnaam = $exepnaam -replace (" ", "")
	$exe_packagenaam_textbox1.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$exe_output_textbox1.Text = "`nNew package directory created: `r`n"
			$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("`nEXE file will be copied now `r`n")
			
			[string]$exe_org_path = $exe_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $exe_org_path -Confirm:$false
				Copy-Item -Path $exe_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\source" -ErrorAction Stop
				$exe_output_textbox1.AppendText("`nEXE file copy done!`r`n")
				$exe_output_textbox1.AppendText("`nIf you need any additional files please place in just created source directory `r`n")
				$exe_panel1.Enabled = $true
				$exe_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nEXE file copy failed. Please select EXE file first `r`n")
			}
			$exe_open_sourcedir_button1.Enabled = $true
			$exe_open_sourcedir_button1.Visible = $true
			$exe_maakScripting_button1.Enabled = $true
			$exe_buttonAddCustomPackageDesc.Enabled = $true
			$exe_buttonAddCustomPackageDesc.Visible = $true
			
		}
	}
	
	
}

$exe_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$exe_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_intunewin_tabpage5_Click = {
	#TODO: Place custom script here
	
}

$exe_parsInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	$argList = $exe_parsInstall_textbox1.Text
	$exebestand = $exe_openfiledialog1.SafeFileName
	$exe_output_installparameters.text = "Start-Process -FilePath $EXEbestand -ArgumentList $argList"
}

$exe_output_installparameters_Click = {
	#TODO: Place custom script here
	
}

$exe_install_test_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show("After successful test in PowerShell ISE. Please click the 'Test Done' button.", 'Test install.ps1?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		$backupFolder = "$env:LOCALAPPDATA\temp"
		$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
		$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
		$preBackupPath = Join-Path $backupFolder "PreChanges64_$timeStamp.reg"
		try
		{
			New-Variable -Name 'exe_preBackupPath64' -Value $preBackupPath -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'exe_preBackupPath64' -Value $preBackupPath -Scope Script
		}
		
		reg export "$regExportPath" "$preBackupPath" /y | Out-Null
		$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
		$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
		$preBackupPath = Join-Path $backupFolder "PreChanges32_$timeStamp.reg"
		try
		{
			New-Variable -Name 'exe_preBackupPath32' -Value $preBackupPath -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'exe_preBackupPath32' -Value $preBackupPath -Scope Script
		}
		reg export "$regExportPath" "$preBackupPath" /y | Out-Null
		$exe_test_done_button1CreateInstallScript.Enabled = $true
		$exe_gotobuildingblocksButton.Enabled = $true
		
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$exe_radiobuttonUninstallEXEPath_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_parsUnInstall_textbox1.Enabled = $true
	$exe_parsUnInstall_textbox1.Visible = $true
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
}

$exe_radiobuttonGebruikZelfdeEXEAlsB_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_parsUnInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exebestandUninstall = $exe_uninstall_exe_path_textbox2.text
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exebestandUninstall = $exe_openfiledialog1.SafeFileName
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $true
	$exe_labelVoorbeeldUninstall.Enabled = $true
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
	
	$argList2 = $exe_parsUnInstall_textbox1.text
	if ($exe_openfiledialog1.SafeFileName -like "*.exe")
	{
		
		$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
	}
}

$exe_labelVoorbeeldUninstall_Click = {
	#TODO: Place custom script here
	
}

$exe_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation.. You can Edit in Powershell ISE. And save that file if needed.', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$exe_addBuildingBlocksCSVButton.Enabled = $true
	}
	
	
	
}

$exe_maakScripting_button1_Click = {
	#TODO: Place custom script here
	
	$exe_UnlInstallParameters.Visible = $true
	$exe_UnlInstallParameters.Enabled = $true
	$exe_radiobuttonUninstallEXEPath.Visible = $true
	$exe_radiobuttonUninstallEXEPath.Enabled = $true
	$exe_install_test_button1.Enabled = $true
	$exe_install_test_button1.Visible = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Enabled = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Visible = $true
	$exe_radiobutton3.Enabled = $true
	$exe_radiobutton3.Visible = $true
	
	
	$exe_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 18:02
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$exeFile = "!!ExeFile!!"
$exeParameters = "!!ExeParams!!" ## Check EXE Params.. 
# Customer variables
$logDir = "!!LogDir!!"
$registerDetectionRoot = "!!RegisterDetectionRoot!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $exeFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Installation completed of $exeFile" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error executing $exeFile" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:









Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_installFile = $exe_installFile.Replace('"!!AppName!!"', $appnaam)
	$exe_installFile = $exe_installFile.Replace('!!LogDir!!', $logdir)
	$exe_installFile = $exe_installFile.Replace('!!RegisterDetectionRoot!!', $RegisterDetectionroot)
	$exe_installFile = $exe_installFile.Replace('!!Version!!', $versie)
	$exe_installFile = $exe_installFile.Replace('"!!ExeFile!!"', $EXEbestand)
	$exe_installFile = $exe_installFile.Replace('"!!ExeParams!!"', $EXEPARSInput)
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	try
	{
		$exe_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$exe_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	
	
}

$exe_uninstall_exe_path_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$exe_maak_intuneWIN_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$mkiapn = $exe_packagenaam_textbox1.text
	$versie = $exe_versie_textbox1.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$exepnaam\$exeversie\source\" -s "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -o "$outputDirectory\$exepnaam\$exeversie\output\" -q
	Rename-Item -Path "$outputDirectory\$exepnaam\$exeversie\output\install.intunewin" -NewName "$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin"
	$exe_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin")
	$exe_output_textbox1.AppendText("`r`n")
	
	$exe_output_textbox1.AppendText("Install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$exe_output_textbox1.AppendText("un-install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$exe_output_textbox1.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$mkiapn\"
	$regkeyApp
	$exe_output_textbox1.AppendText("$regkeyApp `r`n")
	$exe_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$exe_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: $Versie `r`n")
	$exe_output_textbox1.AppendText("Please reopen tool to make another EXE package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$exepnaam.intunewin"
			DisplayName   = $exepnaam
			Publisher	  = $config_customername
			AppVersion    = $exeversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$exepnaam\$exeversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$exepnaam\$exeversie\output\"
	$exe_output_textbox1.AppendText("Config.csv written to naar: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\config.csv")
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	$exe_output_textbox1.AppendText("  `r`n")

	$buildingBlokcsCSV = $exe_buildingblockscsv_textbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$exepnaam\$exeversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$exepnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$exe_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$exe_output_textbox1.AppendText("$config_buildingblockspath\$exepnaam\BuildingBlocks.csv `r`n")
		$exe_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$exe_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$exe_output_textbox1.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$exe_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
	
	
}

$msi_buttonOpenMSIFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog1.ShowDialog()
	$msi_openmsi_label1.Text = $msi_openfiledialog1.SafeFileName
	$msi_openmsi_label1.Visible = $true;
	$msi_openfiledialog2.Reset()
	$msi_openfiledialog3.Reset()
	$msi_openmsp_label1.Text = ''
	$msi_openmsp_label1.Visible = $false
	$msi_openmsp_label1.Enabled = $false
	$msi_buttonOpenMSPFile.Enabled = $true
	$msi_buttonOpenMSPFile.Visible = $true
	$msi_openmst_label1.Text = ''
	$msi_buttonOpenMSTFile.Visible = $true
	$msi_buttonOpenMSTFile.Enabled = $true
	#$msi_reg_hklm_label5.Visible = $false
	#$msi_reg_hklm_label5.Enabled = $false
	
	
}

$msi_buttonOpenMSPFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog2.ShowDialog()
	$msi_openmsp_label1.Text = $msi_openfiledialog2.SafeFileName
	$msi_openmsp_label1.Visible = $true
	$msi_openmsp_label1.Enabled = $true
}


$msi_buttonOpenMSTFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog3.ShowDialog()
	$msi_openmst_label1.Text = $msi_openfiledialog3.SafeFileName
	$msi_openmst_label1.Visible = $true
	$msi_openmst_label1.Enabled = $true
}



$msi_openmsi_label1_Click = {
	#TODO: Place custom script here
	
}

$msi_buttonCreatePackageDirecto_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msipnaam = $msi_packagenaam_textbox1.text
	$msipnaam = $msipnaam -replace (" ", "")
	$msi_packagenaam_textbox1.text = $msipnaam
	$msiversie = $msi_versie_textbox1.text
	
	if ($msipnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msiversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\output"
			}
			$msi_output_textbox1.Text = "`nNew package direcotory created: `r`n"
			$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\source")
			$msi_output_textbox1.AppendText("`r`n")
			$msi_output_textbox1.AppendText("`nMSI file will now be copied`r`n")
			[string]$msi_org_path = $msi_openfiledialog1.FileNames
			
			
			
			try
			{
				Unblock-File -Path $msi_org_path -Confirm:$false
				function Get-MSIProductCode
				{
					### GPT o1-preview
					param (
						[Parameter(Mandatory = $true)]
						[string]$MSIPath
					)
					$installer = New-Object -ComObject WindowsInstaller.Installer
					$database = $installer.OpenDatabase($MSIPath, 0)
					$view = $database.OpenView("SELECT Value FROM Property WHERE Property='ProductCode'")
					$view.Execute()
					$record = $view.Fetch()
					if ($record -ne $null)
					{
						$productCode = $record.StringData(1)
						return $productCode
					}
					else
					{
						Write-Error "ProductCode niet gevonden in het MSI-bestand."
						return $null
					}
					$view.Close()
				}
				$productCode = Get-MSIProductCode -MSIPath $msi_org_path
				
				
				$MSINewname = $msi_openfiledialog1.FileName
				
				$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
				$MSINewname = $MSINewname.Replace(" ", "")
				$MSIbestand = "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname"
				
				
				
				#Write-Host $MSIbestand
				Copy-Item -Path $msi_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname" -ErrorAction Stop
				$msi_output_textbox1.AppendText("`nMSI file copy done `r`n")
				$msp = $msi_openmsp_label1.Text
				
				if ($msp -ne '')
				{
					[string]$msp_org_path = $msi_openfiledialog2.FileNames
					Unblock-File -Path $msp_org_path -Confirm:$false
					$MSPNewname = $msi_openfiledialog2.FileName
					$MSPNewname = $MSPNewname.Split("\")[$MSPNewname.Split("\").Count - 1]
					$MSPNewname = $MSPNewname.Replace(" ", "")
					Copy-Item -Path $msp_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSPNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMSP file copy done `r`n")
				}
				$mst = $msi_openmst_label1.Text
				if ($mst -ne '')
				{
					[string]$mst_org_path = $msi_openfiledialog3.FileNames
					Unblock-File -Path $mst_org_path -Confirm:$false
					$MSTNewname = $msi_openfiledialog3.FileName
					$MSTNewname = $MSTNewname.Split("\")[$MSTNewname.Split("\").Count - 1]
					$MSTNewname = $MSTNewname.Replace(" ", "")
					Copy-Item -Path $mst_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSTNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMST file copy done `r`n")
				}
				
				$msi_output_textbox1.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				$msi_panel1.Enabled = $true
				$msi_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			$appNaam = $msipnaam
			$versie = $msiversie
			#$msi_openfiledialog1.SafeFileName
			#klant variabelen
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			#Dyn vars
			$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
			$filenaamMSILog = $appNaam + $versie + "MSI"
			$filenaamMSIUninstallLog = $appNaam + $versie + "MSI" + "_uninstall"
			$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
			$logfileMSIUninstall = "$(Join-Path $logdir  "$filenaamMSIUninstallLog.txt")"
			
			if ($msp -ne '')
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname PATCH=$MSPNewname"
			}
			else
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname"
			}
			if ($mst -ne '')
			{
				$oldMSIInstallstring = $msi_install_par_textbox3.Text
				$msi_install_par_textbox3.Text = $oldMSIInstallstring + " TRANSFORMS=$MSTNewname"
				
			}
			
			
			$msi_uninstall_par_textbox1.Text = "msiexec /qn, /l*v $logfileMSIUninstall /x$productCode"
			$msi_OpenSourceDir_button1.Enabled = $true
			$msi_OpenSourceDir_button1.Visible = $true
			$msi_open_Orca_button1.Enabled = $true
			$msi_addDescription.Enabled = $true
			$msi_addDescription.Visible = $true
		}
	}
	
	
}

$labelInstallParametersadj_Click = {
	#TODO: Place custom script here
	
}

$msi_uninstall_par_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$msi_button1CreateInstallScript_Click = {
	#TODO: Place custom script here
	#'"' + $exe_openfiledialog1.SafeFileName + '"'
	
	$msi_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	28-8-2025 17:00
	 Created by:   	Rink Turksma	
	 Organization: 	https://intunepreptool.com
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Install file generated by the IntunePrepTool
#>


#AppsVars
$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"

#Customer vars
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$loglevel = "!!loglevel!!"

#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;



##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot

if ($loglevel -eq 'verbose')
{
	
	try
	{
		$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
		
		$msilog = get-content $logfileMSI
		if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
		Else
		{
			foreach ($ml in $msilog)
			{
				if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
				{
					$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
				}
			}
			write-host "Script started i.cmd" -ForegroundColor Green
			Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
			write-host $logfileMSI -ForegroundColor Green
			$MSILOGS = get-content $logfileMSI
			
			
			
		}
		
		if ($msiuninstallcode -eq $null) { $excode = 1; write-error "Can't find uninstall code in MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
		Else
		{
			
			$MSILogs = Get-Content -Path $logfileMSI
			
			
			$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
			
			$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
			
			$Status = $null
			
			
			$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
			if ($lastStatusLine)
			{
				if ($lastStatusLine.Line -match $patternStatus)
				{
					$Status = [int]$Matches['code']
				}
			}
			
			
			if (-not $Status)
			{
				$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
				if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
				{
					$Status = [int]$Matches['code']
				}
			}
			
			$MsiErrors = @{
				0 = 'ERROR_SUCCESS - The action completed successfully.'
				13 = 'ERROR_INVALID_DATA - The data is invalid.'
				87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
				120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
				1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
				1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
				1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
				1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
				1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
				1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
				1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
				1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
				1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
				1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
				1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
				3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
			}
			[int]$code = $Status
			if ($MsiErrors.ContainsKey($code))
			{
				$msg = $MsiErrors[$code]
			}
			else
			{
				$msg = "Unknown MSI error code: $code"
			}
			if ($code -eq 0 -or $code -eq 3010)
			{
				Write-Host "MSI Result: $msg" -ForegroundColor Green
				$excode = 0
			}
			else
			{
				Write-Error "MSI Result: $msg"
				$excode = 1
			}
			$excode = 0
		}
	}
	catch
	{
		Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
		Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
		$MSILogs = Get-Content -Path $logfileMSI
		
		
		$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
		
		$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
		
		$Status = $null
		
		
		$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
		if ($lastStatusLine)
		{
			if ($lastStatusLine.Line -match $patternStatus)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		if (-not $Status)
		{
			$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
			if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		
		# Output
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
		
		
		$excode = 1
	}
}
else
{
	try
	{
		$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
		write-host $startPMSI
		$msilog = get-content $logfileMSI
		if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
		Else
		{
			foreach ($ml in $msilog)
			{
				if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
				{
					$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
				}
			}
			write-host "Script started i.cmd" -ForegroundColor Green
			write-host ""
			Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
			write-host $logfileMSI -ForegroundColor Green
			$MSILOGS = $null; $MSILOGS = get-content $logfileMSI
			$MSILOGS
			$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
			if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
			{
				$Status = $matches[1]
			}
			
			
			$MsiErrors = @{
				0 = 'ERROR_SUCCESS - The action completed successfully.'
				13 = 'ERROR_INVALID_DATA - The data is invalid.'
				87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
				120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
				1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
				1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
				1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
				1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
				1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
				1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
				1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
				1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
				1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
				1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
				1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
				3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
			}
			[int]$code = $Status
			if ($MsiErrors.ContainsKey($code))
			{
				$msg = $MsiErrors[$code]
			}
			else
			{
				$msg = "Unknown MSI error code: $code"
			}
			if ($code -eq 0 -or $code -eq 3010)
			{
				Write-Host "MSI Result: $msg" -ForegroundColor Green
				$excode = 0
			}
			else
			{
				Write-Error "MSI Result: $msg"
				$excode = 1
			}
		}
	}
	catch
	{
		Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
		Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
		
		$MSILOGS = $null; $MSILOGS = get-content $logfileMSI
		$MSILOGS
		$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
		if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
		{
			$Status = $matches[1]
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		
		# Output
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
		
	}
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'hklm.reg')
{
	Write-Host "hklm.reg detected.. Now importing" -ForegroundColor Green
	
	# Run reg import, capturing stdout/stderr in $output
	$output = reg import "hklm.reg" /reg:64 2>&1
	
	# reg.exe sets a process exit code. 0 = success
	if ($LASTEXITCODE -eq 0)
	{
		Write-Host "Import succeeded!" -ForegroundColor Green
	}
	else
	{
		Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
		Write-Host "Output was: $output"
	}
}
if (Test-Path 'BuildingBlocks\System')
{
	$originalLocation = Get-Location
	Write-Host "BuildBlocks folder detected"
	
	$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
	foreach ($bb in $allBuildingBlocks)
	{
		$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
		
		if (Test-Path $bbScriptLocation -PathType Leaf)
		{
			Write-Host "Now running Building Blocks Script $bbScriptLocation"
			& $bbScriptLocation
			Set-Location $originalLocation
		}
	}
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	fDetectionInRegistry -succes $true
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_install_par_textbox3.Text + '"'
	
	$msi_installFile = $msi_installFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_installFile = $msi_installFile.Replace('!!logdir!!', $logdir)
	$msi_installFile = $msi_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_installFile = $msi_installFile.Replace('!!versie!!', $versie)
	$msi_installFile = $msi_installFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$loglevel = '"' + 'verbose' + '"'
	}
	else
	{
		$loglevel = '"' + 'info' + '"'
	}
	$msi_installFile = $msi_installFile.Replace('"!!loglevel!!"', $loglevel)

	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_install_par_textbox3.Text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\i.cmd" -encoding ascii -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$msi_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`ni.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$msi_output_textbox1.AppendText("`nAfter succesvol installation you can see the uninstall string in Powershell_ISE `r`n")
		$msi_output_textbox1.AppendText("`nIf this is not working. Check Tab Tools for uninstall strings `r`n")
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	$msi_test_install_button1.Enabled = $true
	$msi_test_install_button1.Visible = $true
	
	
}

$msi_install_par_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$msi_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show("When you want to add Building Blocks to this package, test installation first, then use the '(Optional) Go to Building Blocks' button", 'Test install.ps1?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msi_buttonOptionalGoToBuilding.Enabled = $true
	}
}

$Tools_Uninstall_String_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_Output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_Syswow_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$buttonUninstallstringWowAA32Node_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Hier volgen alle uninstallString sort by datum WowAA32Node `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WowAA32Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$msi_button5CreateIntunewinFile_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msi_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$msi_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$msi_output_textbox1.AppendText("`r`n")
	
	$msi_output_textbox1.AppendText("Install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msi_output_textbox1.AppendText("un-install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msi_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$msi_output_textbox1.AppendText("$regkeyApp `r`n")
	$msi_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$msi_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$msi_output_textbox1.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$msi_output_textbox1.AppendText("Config.csv written to: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$msi_output_textbox1.AppendText("  `r`n")
	$msi_buttonUploadLogoPNG.Enabled = $true
	$msi_buttonUploadLogoPNG.Visible = $true

	$buildingBlokcsCSV = $MSI_buildigblocks_Package_InProgresstextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$msipnaam\$msiversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$msipnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$msi_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$msi_output_textbox1.AppendText("$config_buildingblockspath\$msipnaam\BuildingBlocks.csv `r`n")
		$msi_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$msi_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$msi_output_textbox1.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$msi_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
}

$msi_OpenSourceDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$msipnaam\$msiversie\source\"
}

$msi_button3CreateUninstallScri_Click = {
	#TODO: Place custom script here
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	29-8-2025 18:17
	 Created by:   	Rink Turksma
	 Organization: 	https://intunepreptool.com
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$loglevel = "!!loglevel!!"

#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI_uninstall"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
if ($loglevel -eq 'verbose')
{
	try
	{
		$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
		write-host $startPMSI
		write-host "Uninstall done!" -ForegroundColor Green
		write-host "Script used u.cmd" -ForegroundColor Green
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		
		$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
		
		$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
		
		$Status = $null
		
		
		$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
		if ($lastStatusLine)
		{
			if ($lastStatusLine.Line -match $patternStatus)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		if (-not $Status)
		{
			$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
			if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
		$excode = 0
	}
	catch
	{
		
		Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
		write-host "Script used u.cmd" -ForegroundColor Red
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		
		$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
		
		$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
		
		$Status = $null
		
		
		$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
		if ($lastStatusLine)
		{
			if ($lastStatusLine.Line -match $patternStatus)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		if (-not $Status)
		{
			$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
			if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
			$startPMSI
		}
		$startPMSI
		$excode = 1
	}
}
else
{
	try
	{
		$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
		write-host $startPMSI
		write-host "Uninstall done!" -ForegroundColor Green
		write-host "Script used u.cmd" -ForegroundColor Green
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
		if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
		{
			$Status = $matches[1]
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
	}
	catch
	{
		
		Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		write-host "Script used u.cmd" -ForegroundColor Red
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
		if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
		{
			$Status = $matches[1]
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
	}


if (Test-Path 'BuildingBlocks\System')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
}

#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	remove-item $regkeyApp
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_uninstall_par_textbox1.Text + '"'
	
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$loglevel = '"' + 'verbose' + '"'
	}
	else
	{
		$loglevel = '"' + 'info' + '"'
	}
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!loglevel!!"', $loglevel)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_uninstall_par_textbox1.text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
		$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`nu.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
		
		
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
	}
	$msi_button4TestUninstallPowers.Enabled = $true
	$msi_button4TestUninstallPowers.Visible = $true
	$msi_button5CreateIntunewinFile.Enabled = $true
	$msi_button5CreateIntunewinFile.Visible = $true
	
	
}

$msi_button4TestUninstallPowers_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msi_addBuildingBlocksSystemContextbutton5CreateIntunewinFile.Enabled = $true;
	}
}

$Reset_button1_Click = {
	#TODO: Place custom script here
	Clear-Host
}

$config_tabpage1_Click = {
	#TODO: Place custom script here
	
}

$winget_upload_button1_Click = {
	#TODO: Place custom script here
	<#
	$token = Connect-MSIntuneGraph -TenantID "339ad6f1-ba98-4db6-bf71-0c140c9271bc" -Interactive
	$RegisterDetectionroot = "Intune_Customer"
	$appNaam = "Greenshot"
	$versie = 1
	$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
	$regkeyApp = "$regkeyRoot\$appNaam"
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	Add-IntuneWin32App -FilePath $IntuneWinFile `
					   -DisplayName $DisplayName `
					   -Description $DisplayName `
					   -Publisher $Publisher `
					   -AppVersion $AppVersion `
					   -Icon $IconCMD `
					   -InstallExperience "system" `
					   -RestartBehavior "suppress" `
					   -DetectionRule $DetectionRule `
					   -InstallCommandLine 'powershell -executionpolicy bypass -file install.ps1' `
					   -UninstallCommandLine 'powershell -executionpolicy bypass -file uninstall.ps1' -Verbose
	#>
}

$upload_LoadConfig_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	}
	else
	{
		
		
		$config_csv_openfiledialog1.ShowDialog() | Out-Null
		if ($config_csv_openfiledialog1.FileNames -notcontains 'config_csv_openfiledialog1')
		{
			$upload2_IntuneWinFile_textbox1.Text = $null;
			$upload2_DisplayName_textbox2.Text = $null;
			$upload2_Publisher_textbox1.Text = $null;
			$upload2_AppVersion_textbox1.Text = $null;
			$upload2_reglocation_textbox2.Text = $null;
			$upload2_regValue_textbox1.Text = $null;
			$upload2_installCMD_textbox1.Text = $null;
			$upload2_uninstallCMD_textbox1.Text = $null;
			$upload2_context_textbox1.Text = $null;
			
			$upload_panel2.Enabled = $false
			[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
			$upload_configLoaded_textbox3.Text = $config_csv_openfiledialog1.FileNames
			$ConfigCSVImport = Import-Csv $config_csv_path
			#Write-Host $ConfigCSVImport
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload_context_textbox1.Text = $context
			
			
			if (!(test-path "$filepath\Logo.png" -PathType Leaf))
			{
				[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG, JPG, JPEG or WEBP file for the company portal', 'No Logo for Company portal found')
				$upload_logo_button2.Enabled = $true
				$upload_logo_button2.Visible = $true
				
			}
		}
	}
}

$upload_IntuneWinFile_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_DisplayName_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_Publisher_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_AppVersion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_reglocation_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_regValue_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_installCMD_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_upload_button1_Click = {
	#TODO: Place custom script here
	$uploadIntuneFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	22-8-2025 22:36
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	UploadIntune.ps1
	===========================================================================
#>
#Requires -RunAsAdministrator
$RequiredPSModules = get-content "C:\Program Files\IntunePrepTool\InstallReqPSModules.txt"
if ($RequiredPSModules -like 'false')
{
	write-error 'Missing required Powershell Modules'
	start-sleep 60
	exit
}

[string]$config_csv_path = '!!CONFIGCSV!!'
[string]$buildingblocks_csv_path = '!!BUILDINGBLOCKSCSV!!'
$dep = "!!DEPENDENCY!!"
$AvailableAllUsers = "!!AvailableAllUsers!!"
$RequiredAllDevices = "!!RequiredAllDevices!!"
$SetupLikeOldVersion = "!!SetupLikeOldVersion!!"
$TenantName = "!!TenantName!!"
Write-host "First we logon to the Microsoft Tenant"
Write-host "`r`n"
Write-host "`r`n"

try
{
	$load_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv" -ErrorAction Stop
}
catch
{
	Write-Error "Error loading csv file c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv"
}


foreach ($load in $load_import_csv)
{
	if ($load.customername -eq $tenantName)
	{
		
		if ($load.target -ne 'plain')
		{
			$checkCredLoad = Get-StoredCredential -Target $load.target -AsCredentialObject
			$tenantID = $checkCredLoad.TargetName
			$tenantID = $tenantID.Split("_")[1]
			$AppId = $checkCredLoad.UserName
			$Secret = $checkCredLoad.Password
		}
		else
		{
			$cust = import-csv "c:\users\$env:username\.IntunePrepTool\$tenantname.csv"
			$tenantID = $cust.tenantID
			$AppId = $cust.appId
			$Secret = $cust.clientsecret
			$customPrivacyURL = $cust.customPrivacyURL
			
		}
	}
}

try
{
	Connect-MSIntuneGraph -TenantID $tenantID -ClientID $appID -ClientSecret $secret -ErrorAction Stop
}
catch
{
	Write-Error "No Connection to tenant. Please check app registration!!"
	start-sleep 60
	exit
}
$ConfigCSVImport = Import-Csv $config_csv_path
$itwnf = $ConfigCSVImport.IntuneWinFile
$filepath = $config_csv_path.TrimEnd("config.csv")
$itwnffilepath = $filepath + $itwnf
$descriptionpath = $filepath + 'Description.txt'
if (Test-Path $descriptionpath)
{
	[string]$description = Get-Content $descriptionpath
}
else
{
	$description = "The package has been uploaded using the IntunePrepTool."
}
$regKeyApp = $ConfigCSVImport.regLocation
$versie = $ConfigCSVImport.AppVersion
$regvalue = $ConfigCSVImport.RegValue
$dnam = $ConfigCSVImport.DisplayName
$publ = $ConfigCSVImport.Publisher
$icmd = $ConfigCSVImport.installCMD
$ucmd = $ConfigCSVImport.uninstallCMD
if ($ConfigCSVImport.context)
{
	$context = $ConfigCSVImport.context
}
else
{
	$context = 'system'
}
$logoaanwezig = $null;
try
{
	$logoaanwezig = get-childitem "$filepath\logo.png" -ErrorAction Stop
	$icon = New-IntuneWin32AppIcon -FilePath "$filepath\logo.png"
}
catch
{
	Write-Host "No Logo.PNG found in Output Directory" - ForegroundColor Green; Write-host "`r`n"; $logoaanwezig = $null;
}
$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName $regvalue -StringComparisonOperator equal -StringComparisonValue $versie
$RequirementRule = New-IntuneWin32AppRequirementRule -Architecture "All" -MinimumSupportedWindowsRelease "W10_20H2"
write-host "We will first check if there are any apps already available in Intune with the same DisplayName" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
$Win32AppEvtVorigeVersies = Get-IntuneWin32App -DisplayName $dnam
if ($Win32AppEvtVorigeVersies -ne $null)
{
	write-host "Already version(s) found " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$evtvversie = $Win32AppEvtVorigeVersies.DisplayVersion
	write-host $evtvversie
	$alversieAppAanwezig = $true;
	write-host "After uploading new version you can choose Superseedence in this script" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
}

else
{
	$alversieAppAanwezig = $false;
}

write-host "We will upload to Intune now" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
if ($logoaanwezig -eq $null)
{
	if ($customPrivacyURL -ne $null)
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -PrivacyURL $customPrivacyURL
	}
	else
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule
	}
	
}
else
{
	if ($customPrivacyURL -ne $null)
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -PrivacyURL $customPrivacyURL
	}
	else
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule
	}
}
Write-host "If all is good the app will now be available in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";

if ($SetupLikeOldVersion -eq $true)
{
	if ($alversieAppAanwezig -eq $false) { write-host "Because there where no older versions of this software in Intune you have to do the assingments in the Intune portal" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	else
	{
		
		foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
		{
			write-host "We will now try to setup assignments " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
			$assinmentVorigeVersie = get-IntuneWin32AppAssignment -id $vorigeversie.id
			$evtvversie = $vorigeversie.DisplayVersion
			
			if ($assinmentVorigeVersie -eq $null) { write-host "Older version: $evtvversie has no assignments" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
			else
			{
				write-host ""; Write-host "`r`n"; Write-host "`r`n"
				$response = read-host "Press q to do nothing, Any other key to setup assignments like: $evtvversie"
				$niksdoen = $response -eq "q"
				if ($niksdoen -eq $true) { write-host "Ok.. Then you have to setup the assignments in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host "Ok .. We will fix the assignments for you!" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
					Remove-IntuneWin32AppAssignment -ID $vorigeversie.ID -Confirm:$false
					try
					{
						Add-IntuneWin32AppAssignmentGroup -Intent $assinmentVorigeVersie.intent -Include -ID $Win32App.id -GroupID $assinmentVorigeVersie.Target.groupId -ErrorAction Stop
					}
					catch
					{
						Write-Host "Something went wrong. You will have to do this in Intune" -ForegroundColor Green
					}
				}
			}
		}
		
		foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
		{
			$response = read-host "Press q to do nothing, Any other key to setup Supersedence  "
			$niksdoen = $response -eq "q"
			if ($niksdoen -eq $true) { write-host "Ok.. We are doing nothing here" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
			else
			{
				write-host "Ok .. We will try to fix superseedence" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
				Write-host "We will fix superseedence for:" -ForegroundColor Green
				$vorigeversie.displayVersion
				
				$superseede = New-IntuneWin32AppSupersedence -ID $vorigeversie.id -SupersedenceType Replace
				$bestaandeSuperSedence = $null; $bestaandeSuperSedence = Get-IntuneWin32AppSupersedence -ID $vorigeversie.id
				if ($bestaandeSuperSedence -ne $null) { Remove-IntuneWin32AppSupersedence -ID $bestaandeSuperSedence -Confirm:$False }
				Add-IntuneWin32AppSupersedence -ID $Win32App.id -Supersedence $superseede -Confirm:$false
			}
		}
	}
}
if ($AvailableAllUsers -eq $true)
{
	write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	Add-IntuneWin32AppAssignmentAllUsers -ID $Win32App.Id -Intent available -Notification showAll
}


if ($RequiredAllDevices -eq $true)
{
	write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	Add-IntuneWin32AppAssignmentAllDevices -ID $Win32App.Id -Intent required -Notification hideAll
}
write-host 'Upload Finished!' -ForegroundColor Green
start-sleep 15

'@
	function Get-CheckedNodes
	{
		param (
			[ValidateNotNull()]
			[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
			[ValidateNotNull()]
			[System.Collections.ArrayList]$CheckedNodes)
		
		foreach ($Node in $NodeCollection)
		{
			if ($Node.Checked)
			{
				[void]$CheckedNodes.Add($Node)
			}
			Get-CheckedNodes $Node.Nodes $CheckedNodes
		}
	}
	$CheckedNodes = New-Object System.Collections.ArrayList
	Get-CheckedNodes $upload_treeview2.Nodes $CheckedNodes
	[string]$config_csv_path = $upload_configLoaded_textbox3.Text
	foreach ($node in $CheckedNodes)
	{
		
		if ($config_csv_path -notlike '*BuildingBlocks.csv*')
		{
			$depWin = $upload_dep_textbox1.Text
			$tenantName = $node.Name
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!CONFIGCSV!!', $config_csv_path)
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!TenantName!!', $TenantName)
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!DEPENDENCY!!', $depWin)
			if ($Upload_beschikbaar_all_users_checkbox1.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $false)
			}
			if ($upload_checkboxRequiredForAllDevice.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $false)
			}
			if ($upload_checkboxSetupAssignmentLikeP.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $false)
			}
			
			
			
			
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$tenant = $node.Name
			$uploadFile = $filepath + "\uploadIntune" + $tenant + ".ps1"
			$uploadIntuneFile | Out-File $uploadFile -Force
			
			if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				Start-Process -FilePath "powershell.exe" -ArgumentList "-NoProfile -File $uploadFile"
				#powershell -file $filepath\uploadIntune.ps1
				#Start-Sleep 1
				#PowershellISEOnTop
			}
		}
		else
		{
			if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				$tenantName = $node.Name
				$scriptPath = "C:\Program Files\IntunePrepTool\UploadToIntuneBuildingBlocksCSV.ps1"
				$args = "-NoProfile -File `"$scriptPath`" -buildingblocks_csv_path `"$config_csv_path`" -tenantname `"$tenantName`""
				
				if ($Upload_beschikbaar_all_users_checkbox1.Checked)
				{
					$args += " -AvailableAllUsers `"True`""
				}
				
				if ($upload_checkboxRequiredForAllDevice.Checked)
				{
					$args += " -RequiredAllDevices `"True`""
				}
				Write-Host $args
				Start-Process -FilePath "powershell.exe" -ArgumentList $args
				
			}
			
		}
		
		
	}
	
	
}

$upload_tenantURL_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_upload_logo_button1_Click = {
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$DisplayName = $winget_displayname_textbox1.text
	$msipnaam = $DisplayName -replace (" ", "")
	$msiversie = $versie_textbox2.Text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
}

$msi_buttonUploadLogoPNG_Click = {
	#TODO: Place custom script here
	
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\","\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
}

$exe_uploadlogo_button1_Click = {
	#TODO: Place custom script here
	$msipnaam = $exe_packagenaam_textbox1.text
	$msiversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
}



$upload_dep_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}





$config_panel_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_tenanturl_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

#region Control Helper Functions
function Show-NotifyIcon
{
<#
	.SYNOPSIS
		Displays a NotifyIcon's balloon tip message in the taskbar's notification area.
	
	.DESCRIPTION
		Displays a NotifyIcon's a balloon tip message in the taskbar's notification area.
		
	.PARAMETER NotifyIcon
     	The NotifyIcon control that will be displayed.
	
	.PARAMETER BalloonTipText
     	Sets the text to display in the balloon tip.
	
	.PARAMETER BalloonTipTitle
		Sets the Title to display in the balloon tip.
	
	.PARAMETER BalloonTipIcon	
		The icon to display in the ballon tip.
	
	.PARAMETER Timeout	
		The time the ToolTip Balloon will remain visible in milliseconds. 
		Default: 0 - Uses windows default.
#>
	 param(
	  [Parameter(Mandatory = $true, Position = 0)]
	  [ValidateNotNull()]
	  [System.Windows.Forms.NotifyIcon]$NotifyIcon,
	  [Parameter(Mandatory = $true, Position = 1)]
	  [ValidateNotNullOrEmpty()]
	  [String]$BalloonTipText,
	  [Parameter(Position = 2)]
	  [String]$BalloonTipTitle = '',
	  [Parameter(Position = 3)]
	  [System.Windows.Forms.ToolTipIcon]$BalloonTipIcon = 'None',
	  [Parameter(Position = 4)]
	  [int]$Timeout = 0
 	)
	
	if($null -eq $NotifyIcon.Icon)
	{
		#Set a Default Icon otherwise the balloon will not show
		$NotifyIcon.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon([System.Windows.Forms.Application]::ExecutablePath)
	}
	
	$NotifyIcon.ShowBalloonTip($Timeout, $BalloonTipTitle, $BalloonTipText, $BalloonTipIcon)
}




<#
	.SYNOPSIS
		Sets the emulation of the WebBrowser control for the application.
	
	.DESCRIPTION
		Sets the emulation of the WebBrowser control for the application using the installed version of IE.
		This improves the WebBrowser control compatibility with newer html features.
	
	.PARAMETER ExecutableName
		The name of the executable E.g. PowerShellStudio.exe.
		Default Value: The running executable name.
	
	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation

	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation PowerShell.exe
#>
function Set-WebBrowserEmulation
{
	param
	(
		[ValidateNotNullOrEmpty()]
		[string]$ExecutableName = [System.IO.Path]::GetFileName([System.Diagnostics.Process]::GetCurrentProcess().MainModule.FileName)
	)
	
	#region Get IE Version
	$valueNames = 'svcVersion', 'svcUpdateVersion', 'Version', 'W2kVersion'
	
	$version = 0;
	for ($i = 0; $i -lt $valueNames.Length; $i++)
	{
		$objVal = [Microsoft.Win32.Registry]::GetValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer', $valueNames[$i], '0')
		$strVal = [System.Convert]::ToString($objVal)
		if ($strVal)
		{
			$iPos = $strVal.IndexOf('.')
			if ($iPos -gt 0)
			{
				$strVal = $strVal.Substring(0, $iPos)
			}
			
			$res = 0;
			if ([int]::TryParse($strVal, [ref]$res))
			{
				$version = [Math]::Max($version, $res)
			}
		}
	}
	
	if ($version -lt 7)
	{
		$version = 7000
	}
	else
	{
		$version = $version * 1000
	}
	#endregion
	
	[Microsoft.Win32.Registry]::SetValue('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION', $ExecutableName, $version)
}



function Update-ComboBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.
	
	.PARAMETER ComboBox
		The ComboBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ComboBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red" -Append
		Update-ComboBox $combobox1 "White" -Append
		Update-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Update-ComboBox $combobox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ComboBox]$ComboBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ComboBox.Items.Clear()
	}
	
	if ($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ComboBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ComboBox.Items.Add($obj)
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	if ($ValueMember)
	{
		$ComboBox.ValueMember = $ValueMember
	}
}



function Get-CheckedNode
{
<#
	.SYNOPSIS
		This function collects a list of checked nodes in a TreeView

	.DESCRIPTION
		This function collects a list of checked nodes in a TreeView

	.PARAMETER  $NodeCollection
		The collection of nodes to search

	.PARAMETER  $CheckedNodes
		The ArrayList that will contain the all the checked items
	
	.EXAMPLE
		$CheckedNodes = New-Object System.Collections.ArrayList
		Get-CheckedNode $treeview1.Nodes $CheckedNodes
		foreach($node in $CheckedNodes)
		{	
			Write-Host $node.Text
		}
#>
	param (
		[ValidateNotNull()]
		[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
		[ValidateNotNull()]
		[System.Collections.ArrayList]$CheckedNodes
	)
	
	foreach ($Node in $NodeCollection)
	{
		if ($Node.Checked)
		{
			[void]$CheckedNodes.Add($Node)
		}
		Get-CheckedNode $Node.Nodes $CheckedNodes
	}
}



function Update-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The DataGridView control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the DataGridView's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	.PARAMETER AutoSizeColumns
	    Resizes DataGridView control's columns after loading the items.
	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		$Item,
		[Parameter(Mandatory = $false)]
		[string]$DataMember,
		[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($null -eq $Item)
	{
		$DataGridView.DataSource = $null
	}
	elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
	{
		$DataGridView.DataSource = $Item.Tables[0]
	}
	elseif ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView])
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{
			$array.Add($Item)
		}
		$DataGridView.DataSource = $array
	}
	
	if ($AutoSizeColumns -ne 'None')
	{
		$DataGridView.AutoResizeColumns($AutoSizeColumns)
	}
	
	$DataGridView.ResumeLayout()
}



function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterCIMProperties
			This switch removes CIM properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param (
		$InputObject,
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterCIMProperties)
	
	if ($null -eq $Table)
	{
		$Table = New-Object System.Data.DataTable
	}
	
	if ($null -eq $InputObject)
	{
		$Table.Clear()
		return @( ,$Table)
	}
	
	if ($InputObject -is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
	{
		$Table = $InputObject.Tables[0]
	}
	else
	{
		if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()
			
			if ($null -eq $InputObject) { return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach ($item in $InputObject)
			{
				if ($null -ne $item)
				{
					$object = $item
					break
				}
			}
			
			if ($null -eq $object) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if (-not $FilterCIMProperties -or -not $prop.Name.StartsWith('__')) #filter out CIM properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if ($null -ne $prop.Value)
					{
						try { $type = $prop.Value.GetType() }
						catch { Out-Null }
					}
					
					if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
						[void]$table.Columns.Add($prop.Name, $type)
					}
					else #Type info not found
					{
						[void]$table.Columns.Add($prop.Name)
					}
				}
			}
			
			if ($object -is [System.Data.DataRow])
			{
				foreach ($item in $InputObject)
				{
					$Table.Rows.Add($item)
				}
				return @( ,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()
		}
		
		foreach ($item in $InputObject)
		{
			$row = $table.NewRow()
			
			if ($item)
			{
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if ($table.Columns.Contains($prop.Name))
					{
						$row.Item($prop.Name) = $prop.Value
					}
				}
			}
			[void]$table.Rows.Add($row)
		}
	}
	
	return @( ,$Table)
}



function Update-ListBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ListBox or CheckedListBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ListBox control.
	
	.PARAMETER ListBox
		The ListBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ListBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ListBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ListBox $ListBox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ListBox $listBox1 "Red" -Append
		Update-ListBox $listBox1 "White" -Append
		Update-ListBox $listBox1 "Blue" -Append
	
	.EXAMPLE
		Update-ListBox $listBox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ListBox]$ListBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ListBox.Items.Clear()
	}
	
	if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
	{
		$ListBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ListBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ListBox.Items.Add($obj)
		}
		$ListBox.EndUpdate()
	}
	else
	{
		$ListBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ListBox.DisplayMember = $DisplayMember
	}
	if ($ValueMember)
	{
		$ListBox.ValueMember = $ValueMember
	}
}


#endregion

$config_listbox_SelectedIndexChanged = {
	#TODO: Place custom script here
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
	}
	catch
	{
		#Error handling here
	}
	
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -eq $config_listbox.SelectedItem)
		{
			$config_customername_textbox.text = $cis.customername
			$config_logfoldertarger_textbox.text = $cis.logfoldertarget;
			$config_packagefolder_textbox.text = $cis.packagefolder;
			$config_download_folder_textbox3.Text = $cis.downloadpath
			$config_buildingblocks_textbox3.Text = $cis.buildingblockspath
			if ($cis.downloadpath -like 'Enter UNC or local path for the download Package folder. (Evergreen / Winget)')
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download folder was added to config. Please use this tool or edit "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" ', 'Please add Download folder') # Casting the method to [void] suppresses the output. 
			}
			
			try
			{
				New-Variable -Name 'config_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_customername' -Value $cis.customername -Scope Script
			}
			try
			{
				New-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
			}
			try
			{
				New-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script
			}
			try
			{
				New-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script
			}
			try
			{
				New-Variable -Name 'config_buildingblockspath' -Value $cis.buildingblockspath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_buildingblockspath' -Value $cis.buildingblockspath -Scope Script
			}
		
			$toolstripstatuslabel1.Text = "Selected Customer: $config_customername"
		}
	}
	
}



$config_new_button_Click = {
	#TODO: Place custom script here
	$config_customername_textbox.text = "Enter Customer name here"
	$config_logfoldertarger_textbox.text = "Enter log directory used by scripting on target; Example c:\ProgramData\customername\logs"
	$config_packagefolder_textbox.text = "Enter local path where packages & scripts will be stored; Example c:\sources\"
	$config_download_folder_textbox3.Text = "Enter UNC or local path for the download Package folder. (Evergreen / Winget)"
	$config_buildingblocks_textbox3.Text = "Enter local path where Building Blocks will be stored; Example c:\BuildingBlocks\"
}

$tools_winget_search_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $true
	$tools_datagridview1.Visible = $true
	$tools_Output_textbox1.Enabled = $false
	$tools_Output_textbox1.Visible = $false
	
	
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$tools_wsearchstring = $tools_search_winget_textbox.text
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			
			$tools_datagridview1.DataSource = $table;
		}
		
	}
	
}

$tools_show_winget_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	<#
	$winget_exe = Resolve-Path "\Microsoft.DesktopAppInstaller_1.19.10173.0_x64__8wekyb3d8bbwe\winget.exe"
	if ($winget_exe.count -gt 1)
	{
		$winget_exe = $winget_exe[-1].Path
	}
	
	if (!$winget_exe)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Install winget", 'No Winget found') # Casting the method to [void] suppresses the output. 
	}
	
	#>
	$tools_winget_show_string = $tools_show_winget.text
	$tools_winget_id = winget show $tools_winget_show_string --accept-source-agreements
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
}

$tools_show_winget_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_locale_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$winget_locale_label.Enabled = $true
		$winget_locale_label.Visible = $true
		$Winget_locale_textbox.Enabled = $true
		$Winget_locale_textbox.Visible = $true
	}
	else
	{
		$winget_locale_label.Enabled = $false
		$winget_locale_label.Visible = $false
		$Winget_locale_textbox.Enabled = $false
		$Winget_locale_textbox.Visible = $false
	}
}

$Winget_locale_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_version_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$winget_version_label1.Enabled = $true
		$winget_version_label1.Visible = $true
		$winget_version_textbox1.Enabled = $true
		$winget_version_textbox1.Visible = $true
	}
	else
	{
		$winget_version_label1.Enabled = $false
		$winget_version_label1.Visible = $false
		$winget_version_textbox1.Enabled = $false
		$winget_version_textbox1.Visible = $false
	}
}

$tools_versions_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_winget_show_versions_button_Click = {
	
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_winget_show_string = $tools_versions_winget_textbox.text
	$tools_winget_id = winget show $tools_winget_show_string --versions --accept-source-agreements
	
	
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
	
}

$exe_open_sourcedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$exepnaam\$exeversie\source"
}

$msi_labelPackageName_Click = {
	#TODO: Place custom script here
	
}


$tools_search_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_search_output_button1_Click = {
	#TODO: Place custom script here
	
}

$deP_label3_Click = {
	#TODO: Place custom script here
	
}

$tools_tabpage7_Click = {
	#TODO: Place custom script here
	
}

$upload_checkboxSetupAssignmentLikeP_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllDevice_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllUsers_CheckedChanged = {
	#TODO: Place custom script here
	
}

$Upload_beschikbaar_all_users_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$weblink_ico_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$shortcut_openfiledialog1.ShowDialog()
	[string]$ICO_org_path = $shortcut_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	Copy-Item -Path $ICO_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\$weblinkName.ico" -ErrorAction Stop
	
	$weblink_output_textbox1.AppendText("*.ICO now available in source directory `r`n")
	$weblink_ico_label1.text = $shortcut_openfiledialog1.SafeFileName
	$weblink_ico_label1.Visible = $true;
	$weblink_ico_label1.Enabled = $true;
	$weblink_logo_png_button1.Visible = $true
	$weblink_logo_png_button1.Enabled = $true
	$weblink_output_textbox1.AppendText("Now upload *.png file `r`n")
	
	
	
	
}

$weblink_create_intunewin_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\" -s "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -o "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\" -q
	Rename-Item -Path "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\install.intunewin" -NewName "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkPackageName.intunewin"
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\"
	$weblink_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkName.intunewin")
	$weblink_output_textbox1.AppendText("`r`n")
	
	$weblink_output_textbox1.AppendText("Install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$weblink_output_textbox1.AppendText("un-install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$weblink_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$weblinkPackageName\"
	$regkeyApp
	$weblink_output_textbox1.AppendText("$regkeyApp `r`n")
	$weblink_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$weblink_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: $weblinkVersion `r`n")
	$weblink_output_textbox1.AppendText("Please reopen tool to make another Weblink package `r`n")
	
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$weblinkPackageName.intunewin"
			DisplayName   = $weblinkPackageName
			Publisher	  = $config_customername
			AppVersion    = $weblinkVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\config.csv" -NoTypeInformation
	$weblink_output_textbox1.AppendText("Config.csv written to: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\\config.csv")
	$weblink_output_textbox1.AppendText("  `r`n")
	$weblink_output_textbox1.AppendText("Use config file to upload package to Intune. `r`n")
	
}

$config_delete_button1_Click = {
	#TODO: Place custom script here
	
	$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$config_customerinfo = $null;
	Remove-Item "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -Confirm:$false
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -ne $config_listbox.SelectedItem)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername    = $cis.customername
					logfoldertarget = $cis.logfoldertarget
					packagefolder   = $cis.packagefolder
					downloadpath    = $cis.downloadpath
					buildingblockspath = $cis.buildingblockspath
				})
		}
		
		
	}
	
	
	
	
	
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation
	$config_listbox.Items.Clear()
	
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$weblink_logo_png_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblink_logo_openfiledialog1.ShowDialog()
	[string]$weblinkLogo_org_path = $weblink_logo_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	Copy-Item -Path $weblinkLogo_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\output\logo.png" -ErrorAction Stop
	$weblink_output_textbox1.AppendText("Logo.PNG now available in Output directory `r`n")
	$weblink_png_label1.text = $weblink_logo_openfiledialog1.SafeFileName
	$weblink_png_label1.Enabled = $true
	$weblink_png_label1.Visible = $true
	$weblink_create_scripts_button1.Enabled = $true
	$weblink_create_scripts_button1.Visible = $true
	$weblink_output_textbox1.AppendText("Click Create scripts to create install.ps1 and uninstall.ps1 `r`n")
}

$weblink_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$weblink_create_scripts_button1_Click = {
	#TODO: Place custom script here
	$weblink_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}


#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will now copy ICO file"
	Copy-Item "$Name.ico" "$logdir\ico\$Name.ico" -confirm:$false
	Write-Host "Script will now create extra folder in startmenu (when needed)"
  if (!(Test-Path -Path $location))
{
	
	New-Item -ItemType Directory -Path $location
}

	Write-Host "Script will now create shortcut"
	fCreateShortcut -TargetFile $browser -shortcutName $Name -ShortcutArguments $URL -icon "$logdir\ico\$Name.ico" -programmenu $location
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	$weblink_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Gebruik: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType Dword
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType Dword
	}
}
function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}




#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will remove ICO file and Lnk file"
	Remove-Item $logdir\ico\$Name.ico -confirm:$false
	Remove-Item $location\$Name.lnk -confirm:$false
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkICOFile = "$weblinkName.ico"
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_installFile = $weblink_installFile.Replace("!!packagename!!", $weblinkPackageName)
	$weblink_installFile = $weblink_installFile.Replace("!!Name!!", $weblinkName)
	$weblink_installFile = $weblink_installFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_installFile = $weblink_installFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_installFile = $weblink_installFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_installFile = $weblink_installFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_installFile = $weblink_installFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_installFile = $weblink_installFile.Replace("!!logdir!!", $logdir)
	$weblink_installFile = $weblink_installFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!packagename", $weblinkPackageName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Name!!", $weblinkName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!logdir!!", $logdir)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_installFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$weblink_uninstallFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1" -force
	$weblink_output_textbox1.AppendText("Install.ps1 and uninstall.ps1 created `r`n")
	$weblink_output_textbox1.AppendText("You can now test install and uninstall `r`n")
	$weblink_output_textbox1.AppendText("You can save changes in script if needed `r`n")
	$weblink_output_textbox1.AppendText("Then create Intunewin file`r`n")
	$weblink_test_install_button1.Visible = $true
	$weblink_test_install_button1.Enabled = $true
	$weblink_test_uninstall_button1.Visible = $true
	$weblink_test_uninstall_button1.Enabled = $true
	$weblink_create_intunewin_button1.Visible = $true
	$weblink_create_intunewin_button1.Enabled = $true
	
}



$weblink_create_packagedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$weblinkName = $weblink_packagename.Text
	$weblinkName = $weblinkName -replace (" ", "")
	$weblink_packagename.Text = $weblinkName
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"
	}
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"
	}
	$weblink_output_textbox1.Text = "`nNew package direcotory created: `r`n"
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkName\$weblinkVersion\")
	$weblink_output_textbox1.AppendText(" `r`n")
	$weblink_output_textbox1.AppendText("Now Upload *.ICO file `r`n")
	$weblink_ico_button1.Enabled = $true
	$weblink_ico_button1.Visible = $true
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_browser_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_location_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_url_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_Name_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$weblink_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$helpbutton1_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://github.com/rink-turksma/IntunePrepTool'
}

$winget_displayname_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_create_scripts_button1_Click = {
	#TODO: Place custom script here
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$version = $versie_textbox2.Text
		if ($version -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			$wid = $winget_WingetID_textbox1.text
			$DisplayName = $winget_displayname_textbox1.text
			$fid = $config_packagefolder
			if ($winget_locale_checkbox1.Checked -eq $true)
			{
				$wlo = $Winget_locale_textbox.text
				
			}
			else { $wlo = $null; }
			if ($winget_version_checkbox.Checked -eq $true)
			{
				$wve = $winget_version_textbox1.text
			}
			else { $wve = $null; }
			$WinGetID = $wid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			$outputDirectory = $fid
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	13-9-2025 11:16
	 Created by:   	Rink Turksma
	 Organization: 	https://intunepreptool.com
	 Filename:     	Winget_install_uninstall.ps1
	===========================================================================
#>
# Variables will be provided from IntunePrepTool
$WinGetID = "!!WinGetID!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$version = "!!version!!"
$locale = "!!locale!!"
$localeSelected = "!!localeSelected!!"
$versionWinget = "!!versionWinget!!"
$versionWingetSelected = "!!versionSelected!!"
$includeWingetRequirment = "!!includeWingetRequirment!!"
#Dyn vars
$regApp1 = $DisplayName
$logfile = $(Join-Path $logdir  "$DisplayName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null;
#Creates logdirectory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Create registry application key.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Start Powershell functions
function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution.
	### Ultimately, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $True
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functies
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}



#Start Transcript.  Will be saved under  $logdir.
Start-Transcript -Path $logfile
$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($ResolveWingetPath)
{
	$WingetPath = $ResolveWingetPath[-1].Path
	$wingetexe = $WingetPath
}


if (Test-path $WingetPath -ErrorAction SilentlyContinue)
{
	
	Write-Host "We are now checking the version of Winget"
	$wingetOption = 1
	$versionW = & $wingetexe --version
	Write-Host $versionW
}
else
{
	Write-Host "We are now checking the version of Winget"
	$wingetOption = 2
	$versionW = winget --version
	write-host $versionW
}


if ($versionW -notlike 'v*')
{
	Write-Host "Winget Version does not match.. installing now"
	[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
	$msixUrl = "https://github.com/microsoft/winget-cli/releases/download/v1.11.430/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
	$msixPath = "$($env:TEMP)\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
	(New-Object System.Net.WebClient).DownloadFile($msixUrl, $msixPath)
	
	try
	{
		Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
		Write-Host "Winget installation completed successfully."
	}
	catch
	{
		if ($_.Exception.Message -match "Microsoft.VCLibs.140.00.UWPDesktop")
		{
			Write-Host "Now downloading: Missing dependency 'Microsoft.VCLibs.140.00.UWPDesktop'."
			[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
			$dependencyURL = 'https://github.com/microsoft/winget-cli/releases/download/v1.11.430/DesktopAppInstaller_Dependencies.zip'
			$dependencyPath = "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
			(New-Object System.Net.WebClient).DownloadFile($dependencyURL, $dependencyPath)
			unblock-file "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
			Expand-Archive -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip" -DestinationPath "$($env:TEMP)\DesktopAppInstaller_Dependencies"
			write-host "Now installing dependency"
			try
			{
				Add-AppxPackage -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies\x64\Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64.appx" -ErrorAction Stop
				write-host "Installing depedency done"
			}
			catch
			{
				Write-host "Installing depedency failed"
				Write-Host "An unexpected error occurred: $($_.Exception.Message)"
			}
			try
			{
				write-host "Now trying to install Winget again"
				Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
				write-host "Install winget done"
			}
			catch
			{
				Write-Host "An unexpected error occurred: $($_.Exception.Message)"
			}
		}
		else
		{
			Write-Host "An unexpected error occurred: $($_.Exception.Message)"
		}
	}
	$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
	if ($ResolveWingetPath)
	{
		$WingetPath = $ResolveWingetPath[-1].Path
	}
	$wingetexe = $WingetPath
	
	if (Test-path $wingetexe)
	{
		
		Write-Host "We are now checking the version of Winget"
		$wingetOption = 1
		$versionW = & $wingetexe --version
		Write-Host $versionW
	}
	else
	{
		Write-Host "We are now checking the version of Winget"
		$wingetOption = 2
		$versionW = winget --version
		write-host $versionW
	}
}
else
{
	write-host "Winget already active"
}
$loglocation = 'C:\Windows\Temp\intunepreptoolwinget.txt'
if (Test-Path $loglocation) { Remove-Item $loglocation -Confirm:$false }
$TreatAsSuccessCodes = @(
	-1978335189, # 0x8A15002B UPDATE_NOT_APPLICABLE
	-1978335153, # 0x8A15004F UPGRADE_VERSION_NOT_NEWER
	-1978335135 # 0x8A150061 PACKAGE_ALREADY_INSTALLED
)


$BenignVerbatim = @(
	'No applicable upgrade found',
	'Found an existing package already installed'
)


$PatternRules = New-Object System.Collections.ArrayList

function ConvertTo-RegexFromPhrase
{
	param ([Parameter(Mandatory)]
		[string]$Text)
	if ([string]::IsNullOrWhiteSpace($Text)) { return $null }
	$escaped = [regex]::Escape($Text)
	$escaped = $escaped -replace '\\\s+', '\s+' -replace '\s+', '\s+'
	return "(?i)$escaped"
}

function Add-Rule
{
	param (
		[Parameter(Mandatory)]
		[System.Collections.IList]$Rules,
		[Parameter(Mandatory)]
		[string]$Regex,
		[Parameter(Mandatory)]
		[string]$Description,
		[Parameter(Mandatory)]
		[bool]$TreatAsSuccess
	)
	if ($null -eq $Rules) { throw "Rules list is null." }
	if ([string]::IsNullOrWhiteSpace($Regex)) { return }
	[void]$Rules.Add([pscustomobject]@{
			Regex		   = $Regex
			Description    = $Description
			TreatAsSuccess = $TreatAsSuccess
		})
}
function Convert-ToHex32
{
	param ([Parameter(Mandatory)]
		[object]$Value)
	
	$v = [int64]$Value
	$mask = 0x00000000FFFFFFFF # this is a positive Int64 (4294967295)
	$n = $v -band $mask # low 32 bits as a non-negative Int64
	
	return ('0x{0:X8}' -f $n)
}
function Write-Log
{
	param ([string]$Path,
		[string]$Message)
	Add-Content -Path $Path -Value $Message -Encoding UTF8
}


$WingetErrorCatalog = [ordered]@{
	-1978335231 = @{ Hex = '0x8A150001'; Symbol = 'APPINSTALLER_CLI_ERROR_INTERNAL_ERROR'; Description = 'Internal Error' }
	-1978335230 = @{ Hex = '0x8A150002'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_CL_ARGUMENTS'; Description = 'Invalid command line arguments' }
	-1978335229 = @{ Hex = '0x8A150003'; Symbol = 'APPINSTALLER_CLI_ERROR_COMMAND_FAILED'; Description = 'Executing command failed' }
	-1978335228 = @{ Hex = '0x8A150004'; Symbol = 'APPINSTALLER_CLI_ERROR_MANIFEST_FAILED'; Description = 'Opening manifest failed' }
	-1978335227 = @{ Hex = '0x8A150005'; Symbol = 'APPINSTALLER_CLI_ERROR_CTRL_SIGNAL_RECEIVED'; Description = 'Cancellation signal received' }
	-1978335226 = @{ Hex = '0x8A150006'; Symbol = 'APPINSTALLER_CLI_ERROR_SHELLEXEC_INSTALL_FAILED'; Description = 'Running ShellExecute failed' }
	-1978335225 = @{ Hex = '0x8A150007'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_MANIFESTVERSION'; Description = 'Cannot process manifest. The manifest version is higher than supported. Please update the client.' }
	-1978335224 = @{ Hex = '0x8A150008'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_FAILED'; Description = 'Downloading installer failed' }
	-1978335223 = @{ Hex = '0x8A150009'; Symbol = 'APPINSTALLER_CLI_ERROR_CANNOT_WRITE_TO_UPLEVEL_INDEX'; Description = 'Cannot write to index; it is a higher schema version' }
	-1978335222 = @{ Hex = '0x8A15000A'; Symbol = 'APPINSTALLER_CLI_ERROR_INDEX_INTEGRITY_COMPROMISED'; Description = 'The index is corrupt' }
	-1978335221 = @{ Hex = '0x8A15000B'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCES_INVALID'; Description = 'The configured source information is corrupt' }
	-1978335220 = @{ Hex = '0x8A15000C'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NAME_ALREADY_EXISTS'; Description = 'The source name is already configured' }
	-1978335219 = @{ Hex = '0x8A15000D'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_SOURCE_TYPE'; Description = 'The source type is invalid' }
	-1978335218 = @{ Hex = '0x8A15000E'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_IS_BUNDLE'; Description = 'The MSIX file is a bundle, not a package' }
	-1978335217 = @{ Hex = '0x8A15000F'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_DATA_MISSING'; Description = 'Data required by the source is missing' }
	-1978335216 = @{ Hex = '0x8A150010'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICABLE_INSTALLER'; Description = 'None of the installers are applicable for the current system' }
	-1978335215 = @{ Hex = '0x8A150011'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_HASH_MISMATCH'; Description = "The installer file's hash does not match the manifest" }
	-1978335214 = @{ Hex = '0x8A150012'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NAME_DOES_NOT_EXIST'; Description = 'The source name does not exist' }
	-1978335213 = @{ Hex = '0x8A150013'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_ARG_ALREADY_EXISTS'; Description = 'The source location is already configured under another name' }
	-1978335212 = @{ Hex = '0x8A150014'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICATIONS_FOUND'; Description = 'No packages found' }
	-1978335211 = @{ Hex = '0x8A150015'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_SOURCES_DEFINED'; Description = 'No sources are configured' }
	-1978335210 = @{ Hex = '0x8A150016'; Symbol = 'APPINSTALLER_CLI_ERROR_MULTIPLE_APPLICATIONS_FOUND'; Description = 'Multiple packages found matching the criteria' }
	-1978335209 = @{ Hex = '0x8A150017'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_MANIFEST_FOUND'; Description = 'No manifest found matching the criteria' }
	-1978335208 = @{ Hex = '0x8A150018'; Symbol = 'APPINSTALLER_CLI_ERROR_EXTENSION_PUBLIC_FAILED'; Description = 'Failed to get Public folder from source package' }
	-1978335207 = @{ Hex = '0x8A150019'; Symbol = 'APPINSTALLER_CLI_ERROR_COMMAND_REQUIRES_ADMIN'; Description = 'Command requires administrator privileges to run' }
	-1978335206 = @{ Hex = '0x8A15001A'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NOT_SECURE'; Description = 'The source location is not secure' }
	-1978335205 = @{ Hex = '0x8A15001B'; Symbol = 'APPINSTALLER_CLI_ERROR_MSSTORE_BLOCKED_BY_POLICY'; Description = 'The Microsoft Store client is blocked by policy' }
	-1978335204 = @{ Hex = '0x8A15001C'; Symbol = 'APPINSTALLER_CLI_ERROR_MSSTORE_APP_BLOCKED_BY_POLICY'; Description = 'The Microsoft Store app is blocked by policy' }
	-1978335203 = @{ Hex = '0x8A15001D'; Symbol = 'APPINSTALLER_CLI_ERROR_EXPERIMENTAL_FEATURE_DISABLED'; Description = 'The feature is currently under development. It can be enabled using winget settings.' }
	-1978335202 = @{ Hex = '0x8A15001E'; Symbol = 'APPINSTALLER_CLI_ERROR_MSSTORE_INSTALL_FAILED'; Description = 'Failed to install the Microsoft Store app' }
	-1978335201 = @{ Hex = '0x8A15001F'; Symbol = 'APPINSTALLER_CLI_ERROR_COMPLETE_INPUT_BAD'; Description = 'Failed to perform auto complete' }
	-1978335200 = @{ Hex = '0x8A150020'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INIT_FAILED'; Description = 'Failed to initialize YAML parser' }
	-1978335199 = @{ Hex = '0x8A150021'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_MAPPING_KEY'; Description = 'Encountered an invalid YAML key' }
	-1978335198 = @{ Hex = '0x8A150022'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_DUPLICATE_MAPPING_KEY'; Description = 'Encountered a duplicate YAML key' }
	-1978335197 = @{ Hex = '0x8A150023'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_OPERATION'; Description = 'Invalid YAML operation' }
	-1978335196 = @{ Hex = '0x8A150024'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_DOC_BUILD_FAILED'; Description = 'Failed to build YAML doc' }
	-1978335195 = @{ Hex = '0x8A150025'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_EMITTER_STATE'; Description = 'Invalid YAML emitter state' }
	-1978335194 = @{ Hex = '0x8A150026'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_DATA'; Description = 'Invalid YAML data' }
	-1978335193 = @{ Hex = '0x8A150027'; Symbol = 'APPINSTALLER_CLI_ERROR_LIBYAML_ERROR'; Description = 'LibYAML error' }
	-1978335192 = @{ Hex = '0x8A150028'; Symbol = 'APPINSTALLER_CLI_ERROR_MANIFEST_VALIDATION_WARNING'; Description = 'Manifest validation succeeded with warning' }
	-1978335191 = @{ Hex = '0x8A150029'; Symbol = 'APPINSTALLER_CLI_ERROR_MANIFEST_VALIDATION_FAILURE'; Description = 'Manifest validation failed' }
	-1978335190 = @{ Hex = '0x8A15002A'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_MANIFEST'; Description = 'Manifest is invalid' }
	-1978335189 = @{ Hex = '0x8A15002B'; Symbol = 'APPINSTALLER_CLI_ERROR_UPDATE_NOT_APPLICABLE'; Description = 'No applicable update found' }
	-1978335188 = @{ Hex = '0x8A15002C'; Symbol = 'APPINSTALLER_CLI_ERROR_UPDATE_ALL_HAS_FAILURE'; Description = 'winget upgrade --all completed with failures' }
	-1978335187 = @{ Hex = '0x8A15002D'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_SECURITY_CHECK_FAILED'; Description = 'Installer failed security check' }
	-1978335186 = @{ Hex = '0x8A15002E'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_SIZE_MISMATCH'; Description = 'Download size does not match expected content length' }
	-1978335185 = @{ Hex = '0x8A15002F'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_UNINSTALL_INFO_FOUND'; Description = 'Uninstall command not found' }
	-1978335184 = @{ Hex = '0x8A150030'; Symbol = 'APPINSTALLER_CLI_ERROR_EXEC_UNINSTALL_COMMAND_FAILED'; Description = 'Running uninstall command failed' }
	-1978335183 = @{ Hex = '0x8A150031'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_BREAK_ITERATOR_ERROR'; Description = 'ICU break iterator error' }
	-1978335182 = @{ Hex = '0x8A150032'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_CASEMAP_ERROR'; Description = 'ICU casemap error' }
	-1978335181 = @{ Hex = '0x8A150033'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_REGEX_ERROR'; Description = 'ICU regex error' }
	-1978335180 = @{ Hex = '0x8A150034'; Symbol = 'APPINSTALLER_CLI_ERROR_IMPORT_INSTALL_FAILED'; Description = 'Failed to install one or more imported packages' }
	-1978335179 = @{ Hex = '0x8A150035'; Symbol = 'APPINSTALLER_CLI_ERROR_NOT_ALL_PACKAGES_FOUND'; Description = 'Could not find one or more requested packages' }
	-1978335178 = @{ Hex = '0x8A150036'; Symbol = 'APPINSTALLER_CLI_ERROR_JSON_INVALID_FILE'; Description = 'Json file is invalid' }
	-1978335177 = @{ Hex = '0x8A150037'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NOT_REMOTE'; Description = 'The source location is not remote' }
	-1978335176 = @{ Hex = '0x8A150038'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_RESTSOURCE'; Description = 'The configured rest source is not supported' }
	-1978335175 = @{ Hex = '0x8A150039'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTSOURCE_INVALID_DATA'; Description = 'Invalid data returned by rest source' }
	-1978335174 = @{ Hex = '0x8A15003A'; Symbol = 'APPINSTALLER_CLI_ERROR_BLOCKED_BY_POLICY'; Description = 'Operation is blocked by Group Policy' }
	-1978335173 = @{ Hex = '0x8A15003B'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTAPI_INTERNAL_ERROR'; Description = 'Rest API internal error' }
	-1978335172 = @{ Hex = '0x8A15003C'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTSOURCE_INVALID_URL'; Description = 'Invalid rest source url' }
	-1978335171 = @{ Hex = '0x8A15003D'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTAPI_UNSUPPORTED_MIME_TYPE'; Description = 'Unsupported MIME type returned by rest API' }
	-1978335170 = @{ Hex = '0x8A15003E'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTSOURCE_INVALID_VERSION'; Description = 'Invalid rest source contract version' }
	-1978335169 = @{ Hex = '0x8A15003F'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_DATA_INTEGRITY_FAILURE'; Description = 'The source data is corrupted or tampered' }
	-1978335168 = @{ Hex = '0x8A150040'; Symbol = 'APPINSTALLER_CLI_ERROR_STREAM_READ_FAILURE'; Description = 'Error reading from the stream' }
	-1978335167 = @{ Hex = '0x8A150041'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_AGREEMENTS_NOT_ACCEPTED'; Description = 'Package agreements were not agreed to' }
	-1978335166 = @{ Hex = '0x8A150042'; Symbol = 'APPINSTALLER_CLI_ERROR_PROMPT_INPUT_ERROR'; Description = 'Error reading input in prompt' }
	-1978335165 = @{ Hex = '0x8A150043'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_SOURCE_REQUEST'; Description = 'The search request is not supported by one or more sources' }
	-1978335164 = @{ Hex = '0x8A150044'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTAPI_ENDPOINT_NOT_FOUND'; Description = 'The rest API endpoint is not found.' }
	-1978335163 = @{ Hex = '0x8A150045'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_OPEN_FAILED'; Description = 'Failed to open the source.' }
	-1978335162 = @{ Hex = '0x8A150046'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_AGREEMENTS_NOT_ACCEPTED'; Description = 'Source agreements were not agreed to' }
	-1978335161 = @{ Hex = '0x8A150047'; Symbol = 'APPINSTALLER_CLI_ERROR_CUSTOMHEADER_EXCEEDS_MAXLENGTH'; Description = 'Header size exceeds the allowable limit of 1024 characters. Please reduce the size and try again.' }
	-1978335160 = @{ Hex = '0x8A150048'; Symbol = 'APPINSTALLER_CLI_ERROR_MISSING_RESOURCE_FILE'; Description = 'Missing resource file' }
	-1978335159 = @{ Hex = '0x8A150049'; Symbol = 'APPINSTALLER_CLI_ERROR_MSI_INSTALL_FAILED'; Description = 'Running MSI install failed' }
	-1978335158 = @{ Hex = '0x8A15004A'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_MSIEXEC_ARGUMENT'; Description = 'Arguments for msiexec are invalid' }
	-1978335157 = @{ Hex = '0x8A15004B'; Symbol = 'APPINSTALLER_CLI_ERROR_FAILED_TO_OPEN_ALL_SOURCES'; Description = 'Failed to open one or more sources' }
	-1978335156 = @{ Hex = '0x8A15004C'; Symbol = 'APPINSTALLER_CLI_ERROR_DEPENDENCIES_VALIDATION_FAILED'; Description = 'Failed to validate dependencies' }
	-1978335155 = @{ Hex = '0x8A15004D'; Symbol = 'APPINSTALLER_CLI_ERROR_MISSING_PACKAGE'; Description = 'One or more package is missing' }
	-1978335154 = @{ Hex = '0x8A15004E'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_TABLE_COLUMN'; Description = 'Invalid table column' }
	-1978335153 = @{ Hex = '0x8A15004F'; Symbol = 'APPINSTALLER_CLI_ERROR_UPGRADE_VERSION_NOT_NEWER'; Description = 'The upgrade version is not newer than the installed version' }
	-1978335152 = @{ Hex = '0x8A150050'; Symbol = 'APPINSTALLER_CLI_ERROR_UPGRADE_VERSION_UNKNOWN'; Description = 'Upgrade version is unknown and override is not specified' }
	-1978335151 = @{ Hex = '0x8A150051'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_CONVERSION_ERROR'; Description = 'ICU conversion error' }
	-1978335150 = @{ Hex = '0x8A150052'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_INSTALL_FAILED'; Description = 'Failed to install portable package' }
	-1978335149 = @{ Hex = '0x8A150053'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_REPARSE_POINT_NOT_SUPPORTED'; Description = 'Volume does not support reparse points.' }
	-1978335148 = @{ Hex = '0x8A150054'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_PACKAGE_ALREADY_EXISTS'; Description = 'Portable package from a different source already exists.' }
	-1978335147 = @{ Hex = '0x8A150055'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_SYMLINK_PATH_IS_DIRECTORY'; Description = 'Unable to create symlink, path points to a directory.' }
	-1978335146 = @{ Hex = '0x8A150056'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_PROHIBITS_ELEVATION'; Description = 'The installer cannot be run from an administrator context.' }
	-1978335145 = @{ Hex = '0x8A150057'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_UNINSTALL_FAILED'; Description = 'Failed to uninstall portable package' }
	-1978335144 = @{ Hex = '0x8A150058'; Symbol = 'APPINSTALLER_CLI_ERROR_ARP_VERSION_VALIDATION_FAILED'; Description = 'Failed to validate DisplayVersion values against index.' }
	-1978335143 = @{ Hex = '0x8A150059'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_ARGUMENT'; Description = 'One or more arguments are not supported.' }
	-1978335142 = @{ Hex = '0x8A15005A'; Symbol = 'APPINSTALLER_CLI_ERROR_BIND_WITH_EMBEDDED_NULL'; Description = 'Embedded null characters are disallowed for SQLite' }
	-1978335141 = @{ Hex = '0x8A15005B'; Symbol = 'APPINSTALLER_CLI_ERROR_NESTEDINSTALLER_NOT_FOUND'; Description = 'Failed to find the nested installer in the archive.' }
	-1978335140 = @{ Hex = '0x8A15005C'; Symbol = 'APPINSTALLER_CLI_ERROR_EXTRACT_ARCHIVE_FAILED'; Description = 'Failed to extract archive.' }
	-1978335139 = @{ Hex = '0x8A15005D'; Symbol = 'APPINSTALLER_CLI_ERROR_NESTEDINSTALLER_INVALID_PATH'; Description = 'Invalid relative file path to nested installer provided.' }
	-1978335138 = @{ Hex = '0x8A15005E'; Symbol = 'APPINSTALLER_CLI_ERROR_PINNED_CERTIFICATE_MISMATCH'; Description = 'The server certificate did not match any of the expected values.' }
	-1978335137 = @{ Hex = '0x8A15005F'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALL_LOCATION_REQUIRED'; Description = 'Install location must be provided.' }
	-1978335136 = @{ Hex = '0x8A150060'; Symbol = 'APPINSTALLER_CLI_ERROR_ARCHIVE_SCAN_FAILED'; Description = 'Archive malware scan failed.' }
	-1978335135 = @{ Hex = '0x8A150061'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_ALREADY_INSTALLED'; Description = 'Found at least one version of the package installed.' }
	-1978335134 = @{ Hex = '0x8A150062'; Symbol = 'APPINSTALLER_CLI_ERROR_PIN_ALREADY_EXISTS'; Description = 'A pin already exists for the package.' }
	-1978335133 = @{ Hex = '0x8A150063'; Symbol = 'APPINSTALLER_CLI_ERROR_PIN_DOES_NOT_EXIST'; Description = 'There is no pin for the package.' }
	-1978335132 = @{ Hex = '0x8A150064'; Symbol = 'APPINSTALLER_CLI_ERROR_CANNOT_OPEN_PINNING_INDEX'; Description = 'Unable to open the pin database.' }
	-1978335131 = @{ Hex = '0x8A150065'; Symbol = 'APPINSTALLER_CLI_ERROR_MULTIPLE_INSTALL_FAILED'; Description = 'One or more applications failed to install' }
	-1978335130 = @{ Hex = '0x8A150066'; Symbol = 'APPINSTALLER_CLI_ERROR_MULTIPLE_UNINSTALL_FAILED'; Description = 'One or more applications failed to uninstall' }
	-1978335129 = @{ Hex = '0x8A150067'; Symbol = 'APPINSTALLER_CLI_ERROR_NOT_ALL_QUERIES_FOUND_SINGLE'; Description = 'One or more queries did not return exactly one match' }
	-1978335128 = @{ Hex = '0x8A150068'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_IS_PINNED'; Description = 'The package has a pin that prevents upgrade.' }
	-1978335127 = @{ Hex = '0x8A150069'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_IS_STUB'; Description = 'The package currently installed is the stub package' }
	-1978335126 = @{ Hex = '0x8A15006A'; Symbol = 'APPINSTALLER_CLI_ERROR_APPTERMINATION_RECEIVED'; Description = 'Application shutdown signal received' }
	-1978335125 = @{ Hex = '0x8A15006B'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_DEPENDENCIES'; Description = 'Failed to download package dependencies.' }
	-1978335124 = @{ Hex = '0x8A15006C'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_COMMAND_PROHIBITED'; Description = 'Failed to download package. Download for offline installation is prohibited.' }
	-1978335123 = @{ Hex = '0x8A15006D'; Symbol = 'APPINSTALLER_CLI_ERROR_SERVICE_UNAVAILABLE'; Description = 'A required service is busy or unavailable. Try again later.' }
	-1978335122 = @{ Hex = '0x8A15006E'; Symbol = 'APPINSTALLER_CLI_ERROR_RESUME_ID_NOT_FOUND'; Description = 'The guid provided does not correspond to a valid resume state.' }
	-1978335121 = @{ Hex = '0x8A15006F'; Symbol = 'APPINSTALLER_CLI_ERROR_CLIENT_VERSION_MISMATCH'; Description = 'The current client version did not match the client version of the saved state.' }
	-1978335120 = @{ Hex = '0x8A150070'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_RESUME_STATE'; Description = 'The resume state data is invalid.' }
	-1978335119 = @{ Hex = '0x8A150071'; Symbol = 'APPINSTALLER_CLI_ERROR_CANNOT_OPEN_CHECKPOINT_INDEX'; Description = 'Unable to open the checkpoint database.' }
	-1978335118 = @{ Hex = '0x8A150072'; Symbol = 'APPINSTALLER_CLI_ERROR_RESUME_LIMIT_EXCEEDED'; Description = 'Exceeded max resume limit.' }
	-1978335117 = @{ Hex = '0x8A150073'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_AUTHENTICATION_INFO'; Description = 'Invalid authentication info.' }
	-1978335116 = @{ Hex = '0x8A150074'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_TYPE_NOT_SUPPORTED'; Description = 'Authentication method not supported.' }
	-1978335115 = @{ Hex = '0x8A150075'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_FAILED'; Description = 'Authentication failed.' }
	-1978335114 = @{ Hex = '0x8A150076'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_INTERACTIVE_REQUIRED'; Description = 'Authentication failed. Interactive authentication required.' }
	-1978335113 = @{ Hex = '0x8A150077'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_CANCELLED_BY_USER'; Description = 'Authentication failed. User cancelled.' }
	-1978335112 = @{ Hex = '0x8A150078'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_INCORRECT_ACCOUNT'; Description = 'Authentication failed. Authenticated account is not the desired account.' }
	-1978335111 = @{ Hex = '0x8A150079'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_REPAIR_INFO_FOUND'; Description = 'Repair command not found.' }
	-1978335110 = @{ Hex = '0x8A15007A'; Symbol = 'APPINSTALLER_CLI_ERROR_REPAIR_NOT_APPLICABLE'; Description = 'Repair operation is not applicable.' }
	-1978335109 = @{ Hex = '0x8A15007B'; Symbol = 'APPINSTALLER_CLI_ERROR_EXEC_REPAIR_FAILED'; Description = 'Repair operation failed.' }
	-1978335108 = @{ Hex = '0x8A15007C'; Symbol = 'APPINSTALLER_CLI_ERROR_REPAIR_NOT_SUPPORTED'; Description = "The installer technology in use doesn't support repair." }
	-1978335107 = @{ Hex = '0x8A15007D'; Symbol = 'APPINSTALLER_CLI_ERROR_ADMIN_CONTEXT_REPAIR_PROHIBITED'; Description = 'Repair operations involving administrator privileges are not permitted on packages installed within the user scope.' }
	-1978335106 = @{ Hex = '0x8A15007E'; Symbol = 'APPINSTALLER_CLI_ERROR_SQLITE_CONNECTION_TERMINATED'; Description = 'The SQLite connection was terminated to prevent corruption.' }
	-1978335105 = @{ Hex = '0x8A15007F'; Symbol = 'APPINSTALLER_CLI_ERROR_DISPLAYCATALOG_API_FAILED'; Description = 'Failed to get Microsoft Store package catalog.' }
	-1978335104 = @{ Hex = '0x8A150080'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICABLE_DISPLAYCATALOG_PACKAGE'; Description = 'No applicable Microsoft Store package found from Microsoft Store package catalog.' }
	-1978335103 = @{ Hex = '0x8A150081'; Symbol = 'APPINSTALLER_CLI_ERROR_SFSCLIENT_API_FAILED'; Description = 'Failed to get Microsoft Store package download information.' }
	-1978335102 = @{ Hex = '0x8A150082'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICABLE_SFSCLIENT_PACKAGE'; Description = 'No applicable Microsoft Store package download information found.' }
	-1978335101 = @{ Hex = '0x8A150083'; Symbol = 'APPINSTALLER_CLI_ERROR_LICENSING_API_FAILED'; Description = 'Failed to retrieve Microsoft Store package license.' }
	-1978335100 = @{ Hex = '0x8A150084'; Symbol = 'APPINSTALLER_CLI_ERROR_SFSCLIENT_PACKAGE_NOT_SUPPORTED'; Description = 'The Microsoft Store package does not support download command.' }
	-1978335099 = @{ Hex = '0x8A150085'; Symbol = 'APPINSTALLER_CLI_ERROR_LICENSING_API_FAILED_FORBIDDEN'; Description = 'Failed to retrieve Microsoft Store package license. The Microsoft Entra Id account does not have required privilege.' }
	-1978335098 = @{ Hex = '0x8A150086'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_ZERO_BYTE_FILE'; Description = 'Downloaded zero byte installer; ensure that your network connection is working properly.' }
}

$KnownVerbatimToCode = @{
	'No applicable upgrade found' = -1978335189
	'Found an existing package already installed' = -1978335135
	'None of the installers are applicable' = -1978335216
	'No packages found'		      = -1978335212
	'Command requires administrator privileges' = -1978335207
	'Installer failed security check' = -1978335187
	'Download size does not match' = -1978335186
	'Uninstall command not found' = -1978335185
	'Running MSI install failed'  = -1978335159
	'Failed to open the source'   = -1978335163
	'Microsoft Store.*blocked by policy' = -1978335205
}

foreach ($kvp in $KnownVerbatimToCode.GetEnumerator())
{
	$code = [int]$kvp.Value
	if ($WingetErrorCatalog.Contains($code))
	{
		$cat = $WingetErrorCatalog[$code]
		$desc = "$($cat.Description) ($($cat.Symbol))"
		$tSuccess = $TreatAsSuccessCodes -contains $code
		if ($kvp.Key -match '(?i)no applicable upgrade found|found an existing package already installed') { $tSuccess = $true }
		Add-Rule -Rules $PatternRules -Regex "(?i)$($kvp.Key)" -Description $desc -TreatAsSuccess $tSuccess
	}
}


foreach ($code in $WingetErrorCatalog.Keys)
{
	$meta = $WingetErrorCatalog[$code]
	if ($null -eq $meta -or [string]::IsNullOrWhiteSpace($meta.Description)) { continue }
	$rx = ConvertTo-RegexFromPhrase -Text $meta.Description
	if ($null -ne $rx)
	{
		$desc = "$($meta.Description) ($($meta.Symbol))"
		$tSuccess = $TreatAsSuccessCodes -contains $code
		Add-Rule -Rules $PatternRules -Regex $rx -Description $desc -TreatAsSuccess $tSuccess
	}
}
foreach ($line in $BenignVerbatim)
{
	$rx = "(?i)$([regex]::Escape($line))"
	Add-Rule -Rules $PatternRules -Regex $rx -Description "Benign outcome: $line" -TreatAsSuccess $true
}

if ($wingetOption -eq 1)
{
	$install = "!!WingetCommand!!"
	if ($install -like "!!doe*")
	{
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
		{
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
			
		}
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
		{
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
			
		}
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
		{
			
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
			
		}
		
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
		{
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
		}
		$rawExit = [int]$LASTEXITCODE
		$log = Get-Content $loglocation -Raw
		$decision = $null
		foreach ($rule in $PatternRules)
		{
			if ($log -match $rule.Regex) { $decision = $rule; break }
		}
		
		if ($decision)
		{
			if ($decision.TreatAsSuccess)
			{
				$excode = 0
			}
			else
			{
				# ensure rawExit is numeric
				$excode = if ([int]$rawExit -ne 0) { [int]$rawExit }
				else { 1 }
			}
			
			Write-Log $loglocation "`r`n[Decision] Matched pattern: $($decision.Regex)"
			Write-Log $loglocation "[Decision] TreatAsSuccess: $($decision.TreatAsSuccess)"
		}
		else
		{
			$excode = [int]$rawExit
			
			if ($WingetErrorCatalog.Contains([int]$excode))
			{
				$m = $WingetErrorCatalog[[int]$excode]
				Write-Log $loglocation "`r`n[ExitCode] $($m.Hex) ($excode) $($m.Symbol) - $($m.Description)"
				
				if ($TreatAsSuccessCodes -contains $excode)
				{
					$excode = 0
					Write-Log $loglocation "[Decision] Exit code treated as success by policy."
				}
			}
			else
			{
				$hexUnknown = Convert-ToHex32 $excode
				Write-Log $loglocation "`r`n[ExitCode] $hexUnknown ($excode) - Unknown code"
			}
		}
		Write-Host $log
		$hexOut = Convert-ToHex32 $excode
		Write-Host "ExitCode=$excode (hex $hexOut)"
		
		
		
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
		
		
	}
	else
	{
		& $wingetexe uninstall --id $WinGetID -h *>&1 |
		Tee-Object -FilePath $loglocation | Out-Null
		$rawExit = [int]$LASTEXITCODE
		$log = Get-Content $loglocation -Raw
		$decision = $null
		foreach ($rule in $PatternRules)
		{
			if ($log -match $rule.Regex) { $decision = $rule; break }
		}
		
		if ($decision)
		{
			if ($decision.TreatAsSuccess)
			{
				$excode = 0
			}
			else
			{
				# ensure rawExit is numeric
				$excode = if ([int]$rawExit -ne 0) { [int]$rawExit }
				else { 1 }
			}
			
			Write-Log $loglocation "`r`n[Decision] Matched pattern: $($decision.Regex)"
			Write-Log $loglocation "[Decision] TreatAsSuccess: $($decision.TreatAsSuccess)"
		}
		else
		{
			$excode = [int]$rawExit
			
			if ($WingetErrorCatalog.Contains([int]$excode))
			{
				$m = $WingetErrorCatalog[[int]$excode]
				Write-Log $loglocation "`r`n[ExitCode] $($m.Hex) ($excode) $($m.Symbol) - $($m.Description)"
				
				if ($TreatAsSuccessCodes -contains $excode)
				{
					$excode = 0
					Write-Log $loglocation "[Decision] Exit code treated as success by policy."
				}
			}
			else
			{
				$hexUnknown = Convert-ToHex32 $excode
				Write-Log $loglocation "`r`n[ExitCode] $hexUnknown ($excode) - Unknown code"
			}
		}

		Write-Host $log
		$hexOut = Convert-ToHex32 $excode
		Write-Host "ExitCode=$excode (hex $hexOut)"
		
		
		
		
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
	}
}
else
{
	$install = "!!WingetCommand!!"
	if ($install -like "!!doe*")
	{
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
		{
			winget -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine
			
		}
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
		{
			winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
			
		}
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
		{
			
			winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget
			
		}
		
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
		{
			winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
		}
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
		
	}
	else
	{
		winget uninstall --id $WinGetID -h
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
	}
}



if ($install -like "!!doe*")
{
	try
	{
		#Searches for startmenu items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
		
	}
	try
	{
		#Searches for Desktop items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
	
}
#### Place extra actions here:










if ($decision)
{
	write-host "[Decision] Matched pattern: $($decision.Regex)"
	Write-Host "[Decision] TreatAsSuccess: $($decision.TreatAsSuccess)"
	if ($($decision.TreatAsSuccess) -like 'False')
	{
		$excode = 1
	}
}
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
if ($excode -eq 1) { $warning = 'Error'; }
else
{
	$warning = 'Information'; if ($install -like "!!doe*") { fDetectionInRegistry -succes $true }
	else
	{
		remove-item $regkeyApp
	}
}
#End; Write Log file
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}
Else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }


'@
			$installfile = $installfile.Replace('!!WinGetID!!', $WinGetID)
			$installfile = $installfile.Replace('!!DisplayName!!', $DisplayName)
			$installfile = $installfile.Replace('!!logdir!!', $logdir)
			$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$installfile = $installfile.Replace('!!version!!', $version)
			if ($wlo -ne $null)
			{
				$installfile = $installfile.Replace('!!locale!!', $wlo)
				$installfile = $installfile.Replace("!!localeSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!localeSelected!!", $false) }
			if ($wve -ne $null)
			{
				$installfile = $installfile.Replace('!!versionWinget!!', $wve)
				$installfile = $installfile.Replace("!!versionSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!versionSelected!!", $false) }
			$installfile = $installfile.Replace('!!includeWingetRequirment!!', $includeWingetRequirment)
			
			
			
			
			$installfile = $installfile.Replace('!!WingetCommand!!', "!!doeinstall!!")
			$installFile | Out-File "$outputDirectory\$DisplayName\$version\source\install.ps1" -Force
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$DisplayName\$version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
			$installFile | Out-File "$outputDirectory\$DisplayName\$version\source\uninstall.ps1" -Force
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\source\install.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\source\uninstall.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("You can test using Powershell ISE (button in GUI) or start the creation of intunewinfile`r`n")
			$winget_test_install_button1.Enabled = $true
			$winget_test_install_button1.Visible = $true
			$winget_uninstall_test_button.Enabled = $true
			$winget_uninstall_test_button.Visible = $true
			$winget_maakPackage_button1.Enabled = $true
			$winget_maakPackage_button1.Visible = $true
			$winget_final_panel7.Enabled = $true
		}
	}
	
}

$winget_test_install_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		$voorIntall = Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs"
		powershell_ise -file "$config_packagefolder\$DisplayName\$wingetversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	$winget_gotobuildingBlocks_buttonTestInstallPowershel.Enabled = $true
}

$winget_uninstall_test_button_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		
		powershell_ise -file "$config_packagefolder\$DisplayName\$wingetversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	$winget_addBuildingBlocksCSVbuttonOptionalAddBuildingB.Enabled = $true
	
}

$winget_show_version_button1_Click = {
	#TODO: Place custom script here
	$winget_show_string = $winget_WingetID_textbox1.text
	$winget_show_versions = winget show $winget_show_string --versions --accept-source-agreements
	
	
	$winget_output_textbox3.Text = "Search results: `r`n"
	foreach ($twi in $winget_show_versions)
	{
		
		$winget_output_textbox3.AppendText("$twi `r`n")
	}
}

$wsearch_s_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$wsearch_s_button1_Click = {
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$wsearchstring = $wsearch_s_textbox1.text
	$wsearch__winget_search_output = winget search $wsearchstring --accept-source-agreements
	
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			## - Display custom data created:
			$wsearch_datagridview1.DataSource = $table;
			
			
			
			
			
			
			
		}
		
	}
	
	
	
	
}


Write-Host $wsearch_datagridview1
$wsearch_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$cunfig_folder_pacakaging_button1_Click = {
	#TODO: Place custom script here
	if ($config_packagefolder_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_packagefolder_textbox.Text = $config_packagefolder_folderbrowsermoderndialog1.SelectedPath
	}
}

$config_logfolder_target_button1_Click = {
	#TODO: Place custom script here
	if ($config_logfolder_target_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_logfoldertarger_textbox.Text = $config_logfolder_target_folderbrowsermoderndialog1.SelectedPath
	}
}

$tools_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$tools_search_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_csv_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$upload_logo_button2_Click = {
		$dlg = $upload_logo_openfiledialog1.ShowDialog()
		if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
		[string]$logoPath = $upload_logo_openfiledialog1.FileName
		[string]$configPath = $config_csv_openfiledialog1.FileName
		
		if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
		if (-not (Test-Path -LiteralPath $configPath)) { [void][System.Windows.Forms.MessageBox]::Show('config.csv not selected.'); return }
		$destDir = Split-Path -Parent $configPath
		$destPng = Join-Path $destDir 'logo.png'
		
		# Size check (≤ 1 MB)
		$fi = Get-Item -LiteralPath $logoPath
		if ($fi.Length -gt 1MB)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
			return
		}
		$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
		
		switch ($ext)
		{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			Write-Host "WEBP conversion started..."
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
		[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
}

$timer1_Tick = {
	#TODO: Place custom script here
	
}

$weblink_logo_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$msi_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_Empty_Scheduled_Task_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Basic template: Creates install.ps1 and uninstall.ps1. With detection method in registry for Intune. And logging to the in Config defined log target"
}

$powershell_scheduledtask_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Template scheduled task: Creates install.ps1 that creates scheduled task to run Powershell script. Uninstall.ps1 cleans up the scheduled task"
}

$powershell_package_name_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package Name (String)"
}

$powershell_package_version_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package Version (String)"
}

$powershell_create_package_dir_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Creates package directory based on the chosen package folder (Config) and Package Name & Version"
}

$powershell_open_package_directory_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Open Package\source directory; Here you can place additional files when needed."
}


$config_listbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Select a customer / tenant"
}

$config_customername_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Customer name"
}

$config_logfoldertarger_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Log folder target. Location is used for Powershell transcript logging used by the packages; Also used for MSIEXEC logging when using an MSI source"
}

$config_packagefolder_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package folder. Must be a local folder. For example: when you create a package with Package Name: 'IntunePrepTool' with Package Version '1.0.3.5', and your package folder is c:\sources\gotomars. The folder created for this package = c:\sources\gotomars\IntunePrepTool\1.0.3.5\"
}

$config_tenanturl_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Tenant url is used for the upload function"
}

$helpbutton1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Opens https://github.com/rink-turksma/IntunePrepTool in Edge; If you need more information."
}

$config_delete_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Deletes selected customer. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_new_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click here to create new customer. Click save when done. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_save_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Save to append new customer to list. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_check_updates_button1_Click = {
	#TODO: Place custom script here
	$config_check_updates = @'
winget upgrade rink-turksma.IntunePrepTool
'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetupdate.ps1" -PathType Leaf))
		{
			$config_check_updates | Out-File "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$config_check_updates_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click to open Powershell ISE; Run script to upgrade IntunePrepTool using Winget; When you get the message: 'No applicable upgrade found.' You're already up to date. "
}

$winget_WingetID_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Exact Winget ID here; You can search for the Winget ID using Tabpage Tools"
}

$winget_checkurl_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Shows download URL in Popup window for chosen WingetID"
}

$winget_show_version_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Shows available versions for chosen WingetID; Output in textbox on the right side"
}

$toolstripstatuslabel1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_package_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_displayname_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package name (string)"
}

$versie_textbox2_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package version (string)"
}

$winget_locale_checkbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "'Winget Show' (Also available in tabpage Tools) can be used to find out if the chosen package is available in other languages. Check if you want to specify Locale. Like 'en-US' ; "
}

$global_selected_customer_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$config_listbox_SelectedValueChanged = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text + $config_listbox.SelectedItem
}

$winget_version_checkbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Check checkbox to select specify version. When you don't the latest version is used."
}

$winget_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When youre test and edit the installation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_uninstall_test_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When youre test and edit the uninstallation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_maakPackage_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create Intunewin file; don't forget to upload logo after creating Intunewinfile if you wan't to use the upload option."
}

$msi_buttonOpenMSIFile_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Open *.msi file to use for this package."
}

$msi_packagenaam_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package name (string)."
}

$msi_versie_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package version (string)."
}

$msi_buttonCreatePackageDirecto_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "After selecting MSI, Package name and package version, click Create package directory; The MSI file will be copied to the generated to the package directory"
}

$msi_OpenSourceDir_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click Open source directory to open the source directory for your package.You can add extra files when needed."
}

$msi_install_par_textbox3_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "MSIEXEC install parameters here; after creating package directory, a basic install string is already visible. Edit when needed. Leave the logging options as is. "
}

$msi_button1CreateInstallScript_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click create Install script to create the install.ps1 and i.cmd file; install.ps1 will provide detection method and logging; i.cmd is just the above filled install parameters in as batch file;  "
}

$msi_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click Test install to test your installation. Powershell_ISE will read the MSIEXEC log file and will show you a possible uninstall string. That you can use for uninstall script. Also when shorcuts are created the install.ps1 will give you the option to remove it."
}

$msi_uninstall_par_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Paste the suggested uninstall string from the install.ps1 here. Then click create uninstall script"
}

$msi_button3CreateUninstallScri_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create uninstall script"
}

$msi_button4TestUninstallPowers_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Test uninstall using Powershell_ISE; You can edit the uninstall.ps1 directly. If you need to change the u.cmd file. Please click Open source directory and edit. "
}

$msi_button5CreateIntunewinFile_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create intunewin package. This can take a while, depending on the size of your package. Application (STA) will not respond during creation of Intunewin"
}

$msi_buttonUploadLogoPNG_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When you plan to use Upload function. Please chose PNG file first. Used in Company portal"
}

$winget_remediations_createscripts_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Upload not yet available for Remediations.. For now use the Intune Admin Portal")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Please reopen IntunePrepTool to create more Remediations scripts")
				
				
			}
		}
		
		
	}
	
	
	
	
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
	
	
	
}

$configToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $true
	$config_tabpage.Visible = $true
	$config_tabpage.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$wingetToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_winget_tabcontrol2.Enabled = $true
	$package_winget_tabcontrol2.Visible = $true
	$package_winget_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}
$scheduledTaskToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'Fill'
	$package_ScheduledTask_tabcontrol2.Enabled = $true
	$package_ScheduledTask_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}


$mSIXToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$MSIX_tabcontrol1.Dock = 'Fill'
	$MSIX_tabcontrol1.Enabled = $true
	$MSIX_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$mSIToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $true
	$package_msi_tabcontrol2.Visible = $true
	$package_msi_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$eXEToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $true
	$package_exe_tabcontrol2.Visible = $true
	$package_exe_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$main_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$wingetUpdateToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Dock = 'Fill'
	$Remediations_winget_tabcontrol2.Enabled = $true
	$Remediations_winget_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$weblinkToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Dock = 'Fill'
	$package_weblink_tabcontrol2.Visible = $true
	$package_weblink_tabcontrol2.Enabled = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$intunewinToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Dock = 'Fill'
	$upload_intunewin_tabcontrol2.Enabled = $true
	$upload_intunewin_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$wingetSearchShowVersionToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Enabled = $true
	$tools_winget_searchtabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$findUninstallStringsToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'Fill'
	$tools_uninstallstring_tabcontrol1.Enabled = $true
	$tools_uninstallstring_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromWingetToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $true
	$download_tabcontrol1.Visible = $true
	$download_tabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromMSStoreUsingMSStoreURLToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $true
	$download_MSSTore_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Dock = 'Fill'
	
}


$powershellToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $true
	$Powershell.Visible = $true
	$Powershell.Dock = 'Fill'
	
	
}
$updateMSIOrEXEPackageToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $true
	$updatepackage_msi_tabcontrol1.Visible = $true
	$updatepackage_msi_tabcontrol1.Dock = 'Fill'
	
}

$updateEXEPackageToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $true
	$updatepackage_exe_tabcontrol1.Visible = $true
	$updatepackage_exe_tabcontrol1.Dock = 'Fill'
	
}

$chocolateyFindToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}
$chocolateyFindToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$chocolateyToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}




$fileWizzardToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'

	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}






$Weblink_intunewin_tabpage6_Click = {
	#TODO: Place custom script here
	
}

$weblink_packagename_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$remediations_winget_maxversion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_remediations_maxversion_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	
}

$remediate_winget_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_wingetid_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$remadiations_winget_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$remediations_winget_upload_button1_Click = {
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				
				
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				
				
				
				$encoding = [System.Text.Encoding]::UTF8
				$bytes = $encoding.GetBytes($remediate_detectFile)
				$Encoded_remediate_detectFile = [Convert]::ToBase64String($bytes)
				$Bytes2 = $encoding.GetBytes($remediate_remediateFile)
				$Encoded_remediate_remediateFile = [Convert]::ToBase64String($Bytes2)
				$UploadRemediationsFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	6/5/2023 3:38 PM
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	upload.ps1
	===========================================================================
	.DESCRIPTION
		Part of IntunePrepTool
		https://github.com/rink-turksma/IntunePrepTool
		Upload Remediations to Intune
#>
	Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
	else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
	$displayName = "!!displayName!!"
	$publisher = "!!publisher!!"
	$detectionScriptContent = '!!detectionScriptContent!!'
	$remediationScriptContent = '!!remediationScriptContent!!'
	$tenantID = "!!tenantid!!"
	$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547"; $RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	$MsalToken = Get-MsalToken -TenantId $tenantID -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	$body = @"
{"displayName":"$displayName","description":"Uploaded by IntunePrepTool","publisher":"$publisher","runAs32Bit":false,"runAsAccount":"system","enforceSignatureCheck":false,"detectionScriptContent":"$detectionScriptContent","remediationScriptContent":"$remediationScriptContent","roleScopeTagIds":["0"]}
"@
	$uri = "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts"
	$createdPolicy = Invoke-RestMethod -Uri $uri -Method POST -Body $body -Headers @{ Authorization = $MsalToken.CreateAuthorizationHeader() } -ContentType 'application/json'
	Write-Host "Remediationa policy created successfully with ID: $($createdPolicy.id)" -ForegroundColor Green
	Write-Host "Please assign and schedule with MS Intune Admin console" -ForegroundColor Green
	
'@
				$displayName = $winget_remediations_name_textbox1.Text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!publisher!!", $config_customername)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!displayName!!", $displayName)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!detectionScriptContent!!", $Encoded_remediate_detectFile)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!remediationScriptContent!!", $Encoded_remediate_remediateFile)
				$tenatURL = $upload_tenantURL_textbox.text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!tenantid!!", $tenatURL)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"
				}
				$UploadRemediationsFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1" -Force
				$remadiations_winget_textbox2.AppendText("Created Upload.ps1")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("After uploading; Please go to Intune Management Portal and assign devices or users. And add a schedule")
				
				if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE now?', 'upload.ps1 created', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
				{
					
					
					
					powershell_ise -file "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
			}
		}
	}
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
}

$remediations_winget_open_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
	$remediate_winget_version = $remediate_winget_version_textbox1.Text
	Invoke-Item "$config_packagefolder\$winget_remediations_name\$remediate_winget_version"
}

$powershell_scheduledtask_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	if ($powershell_scheduledtask_radiobutton.Checked -eq $true)
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $true
		$package_scheduled_task_WingetID_textbox.Visible = $true
		$package_scheduled_task_WingetID_label3.Enabled = $true
		$package_scheduled_task_WingetID_label3.Visible = $true
		#$package_ScheduledTask_create_scripts_button1.Enabled = $true
		#$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	else
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $false
		$package_scheduled_task_WingetID_textbox.Visible = $false
		$package_scheduled_task_WingetID_label3.Enabled = $false
		$package_scheduled_task_WingetID_label3.Visible = $false
		
	}
}

$powershell_Empty_Scheduled_Task_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	#$package_ScheduledTask_create_scripts_button1.Enabled = $true
	#$package_ScheduledTask_create_scripts_button1.Visible = $true
}



$package_scheduledtasK_option_weekly_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $true
		$package_scheduledtask_weekly_day_combobox1.Visible = $true
		$package_scheduledtask_weekly_time_combobox1.Enabled = $true
		$package_scheduledtask_weekly_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $true
		
	}
	else
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $false
		$package_scheduledtask_weekly_day_combobox1.Visible = $false
		$package_scheduledtask_weekly_time_combobox1.Enabled = $false
		$package_scheduledtask_weekly_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $false
		
	}
}

$package_scheduledtask_weekly_day_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$datetimepicker1_ValueChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_winget_max_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduled_Task_maxVersion_label4_Click = {
	#TODO: Place custom script here
	
}

$powershell_create_package_dir_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		if ($powershell_package_name_textbox1.Text -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package name textbox', 'Select Package Name')
		}
		else
		{
			if ($powershell_package_version_textbox1.Text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package version textbox', 'Select Package Version')
			}
			else
			{
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
				$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
				$package_scheduledTask_name = $powershell_package_name_textbox1.Text
				$package_scheduledTask_name = $package_scheduledTask_name -replace (" ", "")
				$powershell_package_name_textbox1.Text = $package_scheduledTask_name
				$package_scheduledTask_version = $powershell_package_version_textbox1.text
				
				
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"
				}
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"
				}
				$package_ScheduledTask_output_textbox1.Text = "`nNew package direcotory created: `r`n"
				$package_ScheduledTask_output_textbox1.AppendText("$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$powershell_open_package_directory_button1.Enabled = $true
				$powershell_open_package_directory_button1.Visible = $true
				$package_scheduledtask_system_panel5.Enabled = $true
				$package_scheduledtask_system_panel5.Visible = $true
				#$package_ScheduledTask_create_scripts_button1.Enabled = $true
				#$package_ScheduledTask_create_scripts_button1.Visible = $true
				$scheduledtask_buttonOpenSourceDirectory.Enabled = $true
				$scheduledtask_buttonOpenSourceDirectory.Visible = $true
				
				
				
			}
		}
	}
}

$powershell_package_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_open_package_directory_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	Invoke-Item "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\"
}

$package_ScheduledTask_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_ScheduledTask_create_scripts_button1_Click = {
	#TODO: Place custom script here
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	if ($package_scheduledTaskWarning -eq $true)
	{
		[void][System.Windows.Forms.MessageBox]::Show('For user context select logon or on schedule first; For system context. Select at startup or on schedule option first', 'Select option first')
	}
	else
	{
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$package_scheduledTask_name = $powershell_package_name_textbox1.Text
		$package_scheduledTask_version = $powershell_package_version_textbox1.text
		#$package_scheduledtask_system_panel3.Visible = $true
		#$package_scheduledtask_system_panel3.Enabled = $true
		
		
		
		$ScheduledTaskFile = @'
<#Place code here#>











'@
		$logdir = "$config_logfoldertarget\scheduledTasks"
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!ps1name!!", "scheduledTask_$package_scheduledTask_name.ps1")
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_name!!", $package_scheduledTask_name)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_version!!", $package_scheduledTask_version)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!logdir!!", $logdir)
		$ScheduledTaskFile | Out-File  "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1" -Force -Confirm:$false -ErrorAction SilentlyContinue
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$package_ScheduledTask_output_textbox1.AppendText("Template script to be scheduled created")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Please add your Powershell code between 'Place your Powershell code here' and 'End of your Powershell script'")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Save when done")
		
		$package_scheduledTask_Edit_script_button1.Enabled = $true
		$package_scheduledTask_Edit_script_button1.Visible = $true
		$package_scheduledtasK_option_startup_checkbox1.Enabled = $true
		$package_scheduledtasK_option_startup_checkbox1.Visible = $true
		$package_scheduledtasK_option_weekly_checkbox1.Enabled = $true
		$package_scheduledtasK_option_weekly_checkbox1.Visible = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Enabled = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Visible = $true
	}
	
}



$package_scheduledTask_Edit_script_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Powershell_ISE will open now. Please place powershell code between "Place your Powershell code here" and "End of your Powershell script"; Save when done', 'Powershell_ISE') # Casting the method to [void] suppresses the output. 
	
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	
	
	
}

$package_scheduledtasK_option_startup_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_createIntunewin_scripts_button1_Click = {
	#TODO: Place custom script here
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	
	
	$package_scheduledTask_Edit_script_test_install_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_install_button1.Visible = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Enabled = $true
	
	
	$ScheduledTaskInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	6-10-2024 17:54
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$systemContext = "!!systemContext!!"
$onSchedule = "!!onSchedule!!"
$StartupTask = "!!StartupTask!!"
$logonTask = "!!LogonTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!"
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$DailyTask = "!!DailyTask!!"
$DailyTaskHour = "!!DailyTaskHour!!"
$DailyTaskAMPM = "!!DailyTaskAMPM!!"

$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $version) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
if (test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force }
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
copy-item $psFile -Destination "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force

#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
# BEGIN: 3d5f4a6gch7
#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
$Acl = Get-Acl "$logdir\scheduledTasks"
$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators", "Modify", "Allow")
$System = New-Object System.Security.Principal.NTAccount("SYSTEM")
$Ar2 = New-Object System.Security.AccessControl.FileSystemAccessRule($System, "Modify", "Allow")
$Acl.SetAccessRule($Ar)
$Acl.SetAccessRule($Ar2)
Set-Acl "$logdir\scheduledTasks" $Acl
# END: 3d5f4a6gch7

try
{
	
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	# Creates the scheduled task
	
	
	$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -executionpolicy bypass -Command `"& '$logdir\scheduledTasks\scheduledTask_$appName.ps1'`""
	if ($logonTask -eq $true)
	{
		$trigger0 = New-ScheduledTaskTrigger -AtLogOn
	}
	else
	{
		$trigger0 = $null
	}
	
	if ($StartupTask -eq $true)
	{
		$trigger1 = New-ScheduledTaskTrigger -AtStartup -RandomDelay 00:00:30
	}
	else
	{
		$trigger1 = $null
	}
	if ($WeeklyTask -eq $true)
	{
		$trigger2 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $WeeklyTaskDay -At $WeeklyTaskHour$WeeklyTaskAMPM
	}
	else
	{
		$trigger2 = $null
	}
	if ($DailyTask -eq $true)
	{
		$trigger3 = New-ScheduledTaskTrigger -Daily -At $DailyTaskHour$DailyTaskAMPM
	}
	else
	{
		$trigger3 = $null
	}
	$triggers = @()
	if ($trigger0 -ne $null)
	{
		$triggers += $trigger0
	}
	if ($trigger1 -ne $null)
	{
		$triggers += $trigger1
	}
	if ($trigger2 -ne $null)
	{
		$triggers += $trigger2
	}
	if ($trigger3 -ne $null)
	{
		$triggers += $trigger3
	}
	
	if ($systemContext -eq $true)
	{
		$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	}
	else
	{
		$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -RunLevel Limited
	}
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	Register-ScheduledTask -Action $action -Trigger $triggers -Principal $principal -TaskName $appName -Settings $settings -Description "Scheduled Task for $appName" -Force -ErrorAction Stop
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	
	$excode = 0;
	
}
catch
{
	write-host "Error creating scheduled task" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error'; }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	
	$ScheduledTaskUnInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the deletion of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will delete the powershell script used by the task" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 


try
{
	# Script deletes the scheduled task here
	write-host "Script will delete the scheduled task" -ForegroundColor Green
	Unregister-ScheduledTask -TaskName $appName -Confirm:$false -ErrorAction Stop
	write-host "Scheduled Task deleted" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error with deleting scheduled task" -ForegroundColor Yellow
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
remove-item $regKeyApp -Confirm:$false -force }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$RegisterDetectionroot = "Intune_" + $config_customername
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Weekly or at startup', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				Write-Host "Eerste stap"
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			Write-Host "Check"
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $true)
			
			if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $false)
			}
			
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			Write-Host "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
			
		}
		
		
		
		
	}
	
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Select At logon or at schedule', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $true)
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $false)
			}
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
		}
	}
	
}

$windowsFirewallToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$config_InstallRequriedPSmodules_Click = {
	#TODO: Place custom script here
	$config_install_required_ps_modules = @'

<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	17-5-2024 15:24
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	InstallRequiredPowershellModules.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$problemPSModule = $null;;
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = $null;
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = $null;
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = $null
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if ($problemPSModule -eq 1)
{
	#Nuget installation
	$nugetUrl = "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
	$nugetInstallPath = "$env:ProgramFiles\NuGet"
	if (-not (Test-Path -Path $nugetInstallPath))
	{
		New-Item -ItemType Directory -Path $nugetInstallPath -Force
	}
	$nugetExePath = Join-Path -Path $nugetInstallPath -ChildPath "nuget.exe"
	Invoke-WebRequest -Uri $nugetUrl -OutFile $nugetExePath
	if (Test-Path -Path $nugetExePath)
	{
		Write-Host "NuGet has been installed successfully at $nugetExePath"
	}
	else
	{
		Write-Host "NuGet installation failed"
	}
	$path = [Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
	if ($path -notlike "*$nugetInstallPath*")
	{
		[Environment]::SetEnvironmentVariable("Path", "$path;$nugetInstallPath", [System.EnvironmentVariableTarget]::Machine)
		Write-Host "NuGet has been added to the system PATH"
	}
	else
	{
		Write-Host "NuGet is already in the system PATH"
	}
	& $nugetExePath | Select-String "NuGet Version"
	
	
	Get-PackageProvider -Name Nuget -Force
	
	#Installation Powershell Modules
	Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name IntuneWin32App)
	{
		$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
		
		if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
		{
			Write-Host "IntuneWin32App 1.4.4 already installed"
		}
		else
		{
			Write-Host "Required Version not found.. Now installing"
			Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Authentication 2.27.0 already installed"
		}
		else
		{
			Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Applications 2.27.0 already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name CredentialManager)
	{
		$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
		{
			Write-Host "CredentialManager 2.0.0 Powershell module already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Identity.SignIns 2.27.0 Powershell Module already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	"true" | Out-File 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Force -Confirm:$false
	
}
else
{
	write-host "Powershell Modules already installed!"
	"true" | Out-File 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Force -Confirm:$false
}


'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -PathType Leaf))
		{
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -Confirm:$false -Force
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$downloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$wingetToolStripMenuItem1_Click = {
	#TODO: Place custom script here
	
}

$config_download_folder_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_downloadFolderBrowse_Click = {
	#TODO: Place custom script here
	if ($config_download_folderbrowsermoderndialog2.ShowDialog() -eq 'OK')
	{
		$config_download_folder_textbox3.Text = $config_download_folderbrowsermoderndialog2.SelectedPath
	}
}

$download_winget_tab_Click = {
	#TODO: Place custom script here
	
}

$download_winget_search_button1_Click = {
	
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
	
	
}

$download_winget_search_textbox5_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$download_winget_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_version_listbox1.Items.Clear()
	
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	
	
	foreach ($wsearch_55 in $downloadwingetsearchversionselected)
	{
		
		
		if (($wsearch_55 -notlike "Found*") -and ($wsearch_55 -notlike "*-*") -and ($wsearch_55 -notlike "*Version*") -and ($wsearch_55 -notlike $null) -and ($wsearch_55 -notlike "* *"))
		{
			
			$download_winget_version_listbox1.Items.Add($wsearch_55)
			
			
		}
		
	}
	
	
	
	
}

$download_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	#Write-Host $download_datagridview1.SelectedRows.Item.ToString()
}

$download_winget_version_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_download_and_add_button1.Visible = $true
	$download_winget_download_and_add_button1.Enabled = $true
}

$download_winget_download_and_add_button1_Click = {
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	$download_winget_explorer_button1.Enabled = $true
	$download_winget_explorer_button1.Visible = $true
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	if (!(Test-Path -Path $download_winget_path))
	{
		
		New-Item -ItemType Directory -Path $download_winget_path
	}
	#$downloadWingetToLib = winget download --download-directory $download_winget_path --id $winget_download_selected_id --accept-package-agreements --accept-source-agreements
	
	#$download_winget_output_textbox3.Text = $downloadWingetToLib
	#$config_downloadpath
	#Write-Host $download_winget_version_listbox1.SelectedItem
	$download_winget_selectedversion = $download_winget_version_listbox1.SelectedItem
	$download_winget_package = @'
winget download --download-directory '!!@download_winget_path@!!' --id !!@winget_download_selected_id@!! --accept-package-agreements --accept-source-agreements --version !!@download_winget_selectedversion@!!
'@
	$download_winget_package = $download_winget_package.Replace("!!@winget_download_selected_id@!!", $winget_download_selected_id)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_selectedversion@!!", $download_winget_selectedversion)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_path@!!", $download_winget_path)
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -PathType Leaf))
		{
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -Confirm:$false -Force
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		
		powershell_ise 'C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1'
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}


$download_winget_explorer_button1_Click = {
	#TODO: Place custom script here
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	explorer $download_winget_path
}

$config_help_button1_Click = {
	#TODO: Place custom script here
	
}

$config_exit_help_button1_Click = {
	#TODO: Place custom script here
	
}

$exe_maak_uninstall_script_button1_Click = {
	#TODO: Place custom script here
	$exe_maak_intuneWIN_button1.Enabled = $true
	$exe_maak_intuneWIN_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	
	$exe_uninstallFile = @'
<#	
    .NOTES
    ===========================================================================
     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
     Created on:   	21-5-2023 18:04
     Created by:   	Rink Turksma
     Organization: 	
     Filename:     	uninstall.ps1
    ===========================================================================
    .DESCRIPTION
        Parameters will be filled by IntunePrepTool.
#>
#App Parameters
$appName = "!!AppName!!"
$version = "!!version!!"
$exeFile = "!!EXEFile!!"
$exeParameters = "!!EXEPARMS!!" ##Check EXE PARAMETERS.. 
#Customer variables
$logDir = "!!logdir!!"
$registerDetectionRoot = "!!RegisterDetectionroot!!"
#Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
#Create log directory in programdata if it does not exist.
if (!(Test-Path -Path $logDir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
    New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application Key in the Registry Root.
if (!(Test-Path -Path $regkeyApp))
{
    New-Item $regkeyApp -ItemType Key -Force | out-null
}



function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution..
	### Eventually you will have, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  
#The code you provided is a comment in PowerShell. It indicates that the following code block is related to a transcript that will be saved in a text file under the $logdir directory and will also be available in the event viewer.
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $EXEFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Uninstall completed" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
    write-host "Error executing $EXEbestand" -ForegroundColor Yellow
	Write-Host "Uinstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:





<#----Below is the end of the installation script---#>
#Now the Transcript logging is started
Stop-Transcript
#After this command, the log is automatically saved in the $logdir location
#Here is a way to split the log so that we only have the last run.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
    $lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try / catch block in the execution, we set $excode to 0 or 1
# Based on this, the Log in the Event viewer is set to Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful application message or an unsuccessful one.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$MSIPARSInput = '"' + $exe_msiexecuninstall.Text + '"'
		
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
		
		try
		{
			$exepnaam = $exe_packagenaam_textbox1.text
			$exeversie = $exe_versie_textbox1.text
			$outputDirectory = $config_packagefolder
			$jjmsii = $exe_msiexecuninstall.text
			
			$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
			$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
			$exe_output_textbox1.AppendText("`nu.cmd created `r`n")
			$exe_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
			
			
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
		}
		
		
	}
	else
	{
		
		if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
		{
			$EXEbestand = $exe_uninstall_exe_path_textbox2.Text
			
		}
		else
		{
			$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		}
		
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		#$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$EXEPARSInput = $exe_parsUnInstall_textbox1.Text
		
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!AppName!!"', $appnaam)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!logdir!!', $logdir)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!version!!', $versie)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEFile!!"', $EXEbestand)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEPARMS!!"', $EXEPARSInput)
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		try
		{
			$exe_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUbinstall.ps1 NOT created `r`n")
		}
	}
}

$exe_radiobutton3_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_msiexecuninstall_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_search_button1_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_uninstallstring_search_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$buttonSearch32Bit_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}




$package_scheduledTask_Edit_script_test_install_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $powershell_package_name_textbox1.Text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$package_ScheduledTask_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$package_ScheduledTask_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$package_ScheduledTask_output_textbox1.AppendText("`r`n")
	
	$package_ScheduledTask_output_textbox1.AppendText("Install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("un-install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$package_ScheduledTask_output_textbox1.AppendText("$regkeyApp `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Please reopen tool to make another Intunewin package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$package_ScheduledTask_output_textbox1.AppendText("Config.csv written to: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$package_ScheduledTask_output_textbox1.AppendText("  `r`n")
	$package_scheduledTask_Edit_script_UploadLogo_button1.Enabled = $true
	$package_scheduledTask_Edit_script_UploadLogo_button1.Visible = $true
	$package_ScheduledTask_output_textbox1.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
}

$package_scheduledTask_Edit_script_UploadLogo_button1_Click = {
	#TODO: Place custom script here
	
	$msipnaam = $powershell_package_name_textbox1.text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if ([System.Windows.Forms.MessageBox]::Show("Click yes to open the upload screen. Then load the $outputDirectory\$msipnaam\$msiversie\output\config.csv file there", 'Upload Now?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$package_ScheduledTask_tabcontrol2.Enabled = $false
		$package_ScheduledTask_tabcontrol2.Visible = $false
		
		
		$upload_intunewin_tabcontrol2.Enabled = $true
		$upload_intunewin_tabcontrol2.Visible = $true
		$upload_intunewin_tabcontrol2.Dock = 'Fill'
	}
	
}

$reloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}


$reopenIntunePrepToolToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	& "C:\Program Files\IntunePrepTool\IntunePrepTool.exe"
'@
	if (Test-Path "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1")
	{
		powershell.exe -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
	else
	{
		$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1" -Confirm:$false -Force
		Start-Sleep 1
		powershell -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
}

$buttonUser_folder_showInfo_Click = {
	#TODO: Place custom script here
	#$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547";
	#$RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	#$MsalToken = Get-MsalToken -TenantId 'CSNTestRink.onmicrosoft.com' -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	#$webbrowser1
}

$package_scheduledtask_usercontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		#$package_scheduledTask_systemcontext.Checked = $false
		
		$package_scheduledTask_systemcontext.Enabled = $true
		$package_scheduledTask_systemcontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $true
		$package_scheduledtask_user_panel4.Visible = $true
		$package_scheduledtask_system_panel3.Enabled = $false
		$package_scheduledtask_system_panel3.Visible = $false
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
	}
	
}

$Package_scheduledtask_User_atlogon_checkbox_logon_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledTask_systemcontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		#$package_scheduledtask_usercontext.Checked = $false
		$package_scheduledtask_usercontext.Enabled = $true
		$package_scheduledtask_usercontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $false
		$package_scheduledtask_user_panel4.Visible = $false
		$package_scheduledtask_system_panel3.Enabled = $true
		$package_scheduledtask_system_panel3.Visible = $true
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	
}

$package_scheduledtask_system_panel3_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$package_scheduledtasK_user_schedule_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
		
	}
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false)
	{
		if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
}

$package_scheduledtasK_system_onschedule_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
	}
	if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
	{
		if ($package_scheduledtasK_user_schedule_checkbox.checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
	
	
}

$config_app_refresh_button1_Click = {
	#TODO: Place custom script here
	
}

$config_treeview3_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$customPrivacyURL = $custinfo.customPrivacyURL
				$config_tenant_info_CustomPrivacyURL_textbox3.Text = $customPrivacyURL
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
}

$addTenantToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $false
	$config_tenant_info_panel4.Visible = $false
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
	
	
	
	
}

$config_tenant_add_menustrip2_ItemClicked = [System.Windows.Forms.ToolStripItemClickedEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$config_app_regg_add_tenant_button2_Click = {
	#TODO: Place custom script here
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
}

$treeview2_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$config_tenant_add_button2_Click = {
	#TODO: Place custom script here
	
	$tenantName = $config_tenant_name_textbox3.Text
	$tenantName  = $tenantName -replace (" ", "")
	
	$appRegName = $config_tenant_appRegName_textbox3.Text
	$appRegName = $appRegName -replace (" ", "")
	if ($config_tenant_checkboxYes.Checked -eq $true)
	{
		$customPrivacyURL = $config_tenant_customprivacy_textbox3.text
	}
	else
	{
		$customPrivacyURL = $null
	}
	
	Set-Location $PSScriptRoot
	
	if ([System.Windows.Forms.MessageBox]::Show('Please logon to the tenant with Global Admin rights. App registration will be added. Please wait a few seconds!', 'Logon to tenant', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		

		
		if ($config_tenant_checkboxYes.Checked -eq $true)
		{
			& 'C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe' -AppRegName $AppRegName -CustomerName $tenantName -CustomPrivacyUrl $CustomPrivacyUrl
		}
		else
		{
			& 'C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe' -AppRegName $AppRegName -CustomerName $tenantName -CustomPrivacyUrl 'nvt'
		}
		
		
		
		
		
		
		if (($config_add_Tenant_radiobutton2.Checked -eq $false) -and ($config_add_Tenant_radiobutton1.Checked -eq $false))
		{
			([System.Windows.Forms.MessageBox]::Show('Please select Windows Credential Manager or Plain Text mode', 'Please select savingmode first', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		}
		refreshTenants
		refreshTenantsUpload
		
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('All Done.', 'Customer added') # Casting the method to [void] suppresses the output. 
		
		
	}
	
	
	
}

$config_tenant_name_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_tenant_appRegName_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$tenanturl_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduledtasK_option_Daily_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $true
		$package_scheduledtask_daily_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $true
	}
	else
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $false
		$package_scheduledtask_daily_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $false
	}
	
	
	
	
}

$package_scheduledtask_daily_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$infoToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
	
	
	
}

$labelTenantName_Click = {
	#TODO: Place custom script here
	
}



$removeToolStripMenuItem_Click = {
	
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$config_tenant_info_secret_show_button2_Click = {
	#TODO: Place custom script here
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_secret_textbox3.Text = $checkCred.Password
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_secret_textbox3.Text = $custinfo.clientsecret
			}
		}
		
	}
}


$msix_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	if ($msixpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msixversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\output"
			}
			$msix_output_textbox3.Text = "`nNew package direcotory created: `r`n"
			$msix_output_textbox3.AppendText("$outputDirectory\$msixpnaam\$msixversie\source")
			$msix_output_textbox3.AppendText("`r`n")
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
				$msix_buttonOpenSourceDirectory.Enabled = $true
				$msix_buttonOpenSourceDirectory.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			
			
			
			
		}
	}
}

$msix_packagename_textbox3_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # 
}

$msix_packageVersion_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_download_winget_MSIX_bundle_Click = {
	#TODO: Place custom script here
	$config_install_required_winget= @'
# Resolve Winget path
$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($ResolveWingetPath) {
    $WingetPath = $ResolveWingetPath[-1].Path
}
$wingetexe = $ResolveWingetPath

# Check Winget version
if (Test-path $wingetexe) {
    Write-Host "We are now checking the version of Winget"
    $wingetOption = 1
    $version = & $wingetexe --version
    Write-Host $version
} else {
    Write-Host "We are now checking the version of Winget"
    $wingetOption = 2
    $version = winget --version
    Write-Host $version
}

# Install Winget if needed
if ($version -notlike 'v1.11.430') {
    Write-Host "Winget Version does not match.. installing now"
    [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
    $msixUrl  = "https://github.com/microsoft/winget-cli/releases/download/v1.11.430/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    $msixPath = "$($env:TEMP)\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    (New-Object System.Net.WebClient).DownloadFile($msixUrl, $msixPath)

    try {
        Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
        Write-Host "Winget installation completed successfully."
    } catch {
        if ($_.Exception.Message -match "Microsoft.VCLibs.140.00.UWPDesktop") {
            Write-Host "Now downloading: Missing dependency 'Microsoft.VCLibs.140.00.UWPDesktop'."
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            $dependencyURL = 'https://github.com/microsoft/winget-cli/releases/download/v1.11.430/DesktopAppInstaller_Dependencies.zip'
            $dependencyPath =  "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
            (New-Object System.Net.WebClient).DownloadFile($dependencyURL, $dependencyPath)
            unblock-file "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
            Expand-Archive -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip" -DestinationPath "$($env:TEMP)\DesktopAppInstaller_Dependencies"
            write-host "Now installing dependency"
            try {
            Add-AppxPackage -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies\x64\Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64.appx" -ErrorAction Stop
            write-host "Installing depedency done"
            }
            catch {
            Write-host "Installing depedency failed"
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
            }
            try {
            write-host "Now trying to install Winget again"
            Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
            write-host "Install winget done" 
            }
            catch {
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
            }
        } else {
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
        }
    }

    # Re-check Winget version after attempted install
    $ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
    if ($ResolveWingetPath) {
        $WingetPath = $ResolveWingetPath[-1].Path
    }
    $wingetexe = $ResolveWingetPath

    if (Test-path $wingetexe) {
        Write-Host "Re-checking Winget version..."
        $version = & $wingetexe --version
        Write-Host $version
    } else {
        Write-Host "Winget executable could not be found after installation attempt."
    }
} else {
    Write-Host "Winget is up to date."
}


'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installWinget.ps1" -PathType Leaf))
		{
			$config_install_required_winget | Out-File "C:\Program Files\IntunePrepTool\installWinget.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installWinget.ps1" -Confirm:$false -Force
			$config_install_required_winget | Out-File "C:\Program Files\IntunePrepTool\installWinget.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installWinget.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
	
	
	
	
	
	#Start-Process -FilePath "C:\Program Files\IntunePrepTool\MicrosoftDesktopApp.exe" -WindowStyle Normal
}

$MSIX_open_MSIX_button2_Click = {
	#TODO: Place custom script here
	$MSIX_openfiledialog1.ShowDialog()
	$msix_label4.Text = $msix_openfiledialog1.SafeFileName
	$msix_label4.Visible = $true;
	
}

$MSIX_CreateScripts_button2_Click = {
	
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		write-host "Package installed!"
		$excode = 0
	}
	else
	{
      	$MSIXName = $MSIXFile.Replace(".msixbundle", "")
        $PackageFullName = (Get-AppxPackage | where { $_.PackageFamilyName -like "*$MSIXName*" } | Select PackageFullName).PackageFullName
		Remove-AppxPackage -Package $PackageFullName -AllUsers -ErrorAction Stop
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}

if ($install -like "!!doe*")
{
	try
	{
		# Searches for start menu items created in the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startmenuItems)
		{
			Write-Host "`r`n"
			Write-Host "A start menu *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$startmenuI`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	} catch {
		Write-Host "Error looking for *.lnk files in start menu" -ForegroundColor Yellow
	}

	try {
		# Searches for Desktop items created in the last 10 minutes
		$desktopItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($desktopItem in $desktopItems) {
			Write-Host "`r`n"
			Write-Host "A Desktop *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$desktopItem`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	}
	catch
	{
		Write-Host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
		Write-Host "`r`n"
		Write-Host "Latest installed PackageFullName is:" -ForegroundColor Yellow
		$lastInstalledPackage = Get-AppxPackage | Sort-Object { $_.InstallDate } -Descending | Select-Object -Last 1
        #$lastInstalledPackage | Format-List
        $packageFullName = $lastInstalledPackage.PackageFullName
		Write-Host "$packageFullName" -ForegroundColor Green


}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -Force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$msixpnaam\$msixversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	#$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	#$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test install using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_install_button.Enabled = $true
	$MSIX_test_install_button.Visible = $true
	#$MSIX_test_uninstall_button.Enabled = $true
	#$MSIX_test_uninstall_button.Visible = $true
	#$MSIX_Create_Package.Enabled = $true
	#$MSIX_Create_Package.Visible = $true
	$MSIX_packageFullName_textbox3.Enabled = $true
	$MSIX_packageFullName_textbox3.Visible = $true
	$MSIX_create_uninstall_Script_button2.Enabled = $true
	$MSIX_create_uninstall_Script_button2.Visible = $true
	$msix_fullPackageName_label5.Enabled = $true
	$msix_fullPackageName_label5.Visible = $true
	
	
	
	
}

$msix_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	Invoke-Item "$config_packagefolder\$msixpnaam\$msixversie\source\"
}

$MSIX_test_install_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msix_GotoBuildingBlocks_Button.Enabled = $true
	}
}

$MSIX_test_uninstall_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msix_addBuildingBlokcsCSV_buttonOptionalAddBuildingB.Enabled = $true
	}
}

$MSIX_create_uninstall_Script_button2_Click = {
	#TODO: Place custom script here
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$PackageFullName = "!!PackageFullName!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		$excode = 0
	}
	else
	{
		Get-AppxProvisionedPackage -Online | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxProvisionedPackage -Online -ErrorAction Stop
		Get-AppxPackage -AllUsers | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxPackage -AllUsers -ErrorAction Stop
		write-host "Uninstall of $PackageFullName completed" -ForegroundColor Green
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$packageFullName = $MSIX_packageFullName_textbox3.Text
	$installfile = $installfile.Replace('!!PackageFullName!!', $packageFullName)
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test uninstall using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_uninstall_button.Enabled = $true
	$MSIX_test_uninstall_button.Visible = $true
	$MSIX_Create_Package.Enabled = $true
	$MSIX_Create_Package.Visible = $true
}

$download_winget_Search_store_Button_Click = {
	#TODO: Place custom script here
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
}

$Download_MSSTORE_download_button_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_MSStore_path = "$config_downloadpath\MSStore"
	$MSDownloadLink = $Download_MSSTORE_textbox3.Text
	$MSDownloadLink = $MSDownloadLink.Replace(" ", "")
	if (!(Test-Path -Path $download_MSStore_path))
	{
		
		New-Item -ItemType Directory -Path $download_MSStore_path
	}
	$download_MSSTore_package = @'
# Using: https://github.com/maxbakhub/winposh/blob/main/WindowsDesktopManagement/Download-AppxPackage.ps1
# Found on:
# https://woshub.com/how-to-download-appx-installation-file-for-any-windows-store-app/

function Download-AppxPackage {
[CmdletBinding()]
param (
  [string]$Uri,
  [string]$Path = "."
)
   
  process {
    $Path = (Resolve-Path $Path).Path
    #Get Urls to download
    $WebResponse = Invoke-WebRequest -UseBasicParsing -Method 'POST' -Uri 'https://store.rg-adguard.net/api/GetFiles' -Body "type=url&url=$Uri&ring=Retail" -ContentType 'application/x-www-form-urlencoded'
    $LinksMatch = $WebResponse.Links | where {$_ -like '*.appx*' -or $_ -like '*.appxbundle*' -or $_ -like '*.msix*' -or $_ -like '*.msixbundle*'} | where {$_ -like '*_neutral_*' -or $_ -like "*_"+$env:PROCESSOR_ARCHITECTURE.Replace("AMD","X").Replace("IA","X")+"_*"} | Select-String -Pattern '(?<=a href=").+(?=" r)'
    $DownloadLinks = $LinksMatch.matches.value 

    function Resolve-NameConflict{
    #Accepts Path to a FILE and changes it so there are no name conflicts
    param(
    [string]$Path
    )
        $newPath = $Path
        if(Test-Path $Path){
            $i = 0;
            $item = (Get-Item $Path)
            while(Test-Path $newPath){
                $i += 1;
                $newPath = Join-Path $item.DirectoryName ($item.BaseName+"($i)"+$item.Extension)
            }
        }
        return $newPath
    }
    #Download Urls
    foreach($url in $DownloadLinks){
        $FileRequest = Invoke-WebRequest -Uri $url -UseBasicParsing #-Method Head
        $FileName = ($FileRequest.Headers["Content-Disposition"] | Select-String -Pattern  '(?<=filename=).+').matches.value
        $FilePath = Join-Path $Path $FileName; $FilePath = Resolve-NameConflict($FilePath)
        [System.IO.File]::WriteAllBytes($FilePath, $FileRequest.content)
        echo $FilePath
    }
  }
}

Download-AppxPackage "!!MSStoreLink!!" "!!DLPath!!"
'@
	
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!MSStoreLink!!", "$MSDownloadLink")
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!DLPath!!", "$download_MSStore_path")
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -PathType Leaf))
		{
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -Confirm:$false -Force
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		
		powershell_ise "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		PowershellISEOnTop
	}
	
}


$MSIX_TIP_button2_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://store.rg-adguard.net/'
}

$MSIX_Create_Package_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msix_output_textbox3.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$msixpnaam\$msixversie\source\" -s "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -o "$config_packagefolder\$msixpnaam\$msixversie\output\" -q
	Rename-Item -Path "$config_packagefolder\$msixpnaam\$msixversie\output\install.intunewin" -NewName "$config_packagefolder\$msixpnaam\$msixversie\output\$msixpnaam.intunewin"
	$msix_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msipnaam\$msixversie\output\$msixpnaam.intunewin")
	$msix_output_textbox3.AppendText("`r`n")
	
	$msix_output_textbox3.AppendText("Install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msix_output_textbox3.AppendText("un-install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msix_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msixpnaam\"
	$regkeyApp
	$msix_output_textbox3.AppendText("$regkeyApp `r`n")
	$msix_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$msix_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: $msixversie `r`n")
	$msix_output_textbox3.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$msixpnaam.intunewin"
			DisplayName   = $msixpnaam
			Publisher	  = $config_customername
			AppVersion    = $msixversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$msixpnaam\$msixversie\output\"
	$msix_output_textbox3.AppendText("Config.csv written to: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\output\config.csv")
	$msix_output_textbox3.AppendText("  `r`n")
	$MSIX_UploadLogo_button.Enabled = $true
	$MSIX_UploadLogo_button.Visible = $true
	#.AppendText("First use Upload Logo to upload *.png file. `r`n")
	#$msix_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $msix_buildingblocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$msixpnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$msix_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$msix_output_textbox3.AppendText("$config_buildingblockspath\$msixpnaam\BuildingBlocks.csv `r`n")
		$msix_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$msix_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$msix_output_textbox3.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$msix_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
	
}

$MSIX_UploadLogo_button_Click = {
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msix_packagename_textbox3.text
	$msiversie = $msix_packageVersion_textbox3.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
	
	
	
	
}


$powershell_open_install_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_install_OpenFIledialog1.ShowDialog()
	$powershell_install_Script_label5.Text = $Powershell_install_OpenFIledialog1.SafeFileName
	$powershell_install_Script_label5.Visible = $true;
	
	
}

$powershell_open_uninstall_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_uninstall_OpenFIledialog1.ShowDialog()
	$powershell_uninstall_Script_label5.Text = $Powershell_uninstall_OpenFIledialog1.SafeFileName
	$powershell_uninstall_Script_label5.Visible = $true;
}

$powershell_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellpnaam = $powershellpnaam -replace (" ", "")
	$powershell_packagename_textbox.text = $powershellpnaam
	$powershellversie = $powershell_packageversion_textbox.Text
	
	if ($powershellpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($powershellversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
			}
			$powershell_output_textbox5.Text = "`nNew package direcotory created: `r`n"
			$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("Now select Powershell script for install and uninstall first")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("when needed, Add extra files in Package directory by using the 'Open: Source Directory' button")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_panel4.Enabled = $true
			$powershell_panel4.Visible = $true
			$powershell_opensource_button2.Enabled = $true
			$powershell_opensource_button2.Visible = $true
			<#
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			#>
			
			
			
		}
	}
}

$powershell_generateNEWPS_ps_button2_Click = {
	#TODO: Place custom script here
	if (($powershell_install_Script_label5.text -like "label5") -or ($powershell_uninstall_Script_label5.text -like "label5"))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Use button to select script', 'Please select install and / or uninstall source script first!')
	}
	else
	{
		if (($powershell_radiobutton2.Checked -eq $false) -and ($powershell_radiobutton1.Checked -eq $false))
		{
			[void][System.Windows.Forms.MessageBox]::Show('Select user or system context first', 'Please select user or system context first')
		}
		else
		{
			
			$powershell_output_textbox5.AppendText("`Generating install and uninstall powershell scripts...`r`n")
			
			$powershelll_user_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1  }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
			$powershelll_user_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1  }
else { remove-item $regkeyApp; exit 0 }
'@
			
if ($powershell_radiobutton2.Checked -eq $true)
	{
	$powershelll_installFile = $powershelll_user_installFile
	$powershell_uninstallFile = $powershelll_user_uninstallFile
	}
	if ($powershell_radiobutton1.Checked -eq $true) {
	$powershelll_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
			$powershell_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
				
			}
			
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
			$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
			$powershellpnaam = $powershell_packagename_textbox.text
			$powershellversie = $powershell_packageversion_textbox.Text
			$fid = $config_packagefolder; $outputDirectory = $fid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			[string]$powershell_install_org_path = $Powershell_install_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_install_org_path -Confirm:$false
			$powershellInputInstall = Get-Content -Path $powershell_install_org_path
			#Write-Host $powershellInputInstall
		
			$powershelll_installFile = $powershelll_installFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershelll_installFile = $powershelll_installFile.Replace('!!logdir!!', $logdir)
			$powershelll_installFile = $powershelll_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershelll_installFile = $powershelll_installFile.Replace('!!versie!!', $powershellversie)
			$powershelll_installFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			$powershelll_installFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			foreach ($line in $powershelll_installFile)
			{
				if ($line -like "#PowershellInstallStart*")
				{
					
					foreach ($inputLine in $powershellInputInstall)
					{
						
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
				}
				
				
			}
				
			
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$powershellpnaam\$powershellversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			
			
			
			
			
			
			[string]$powershell_uninstall_org_path = $Powershell_uninstall_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_UNinstall_org_path -Confirm:$false
			$powershellInputUNInstall = Get-Content -Path $powershell_UNinstall_org_path
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!logdir!!', $logdir)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!versie!!', $powershellversie)
			$powershell_uninstallFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			$powershell_uninstallFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			foreach ($line in $powershell_uninstallFile)
			{
				if ($line -like '#PowershellUninstallStart*')
				{
					
					foreach ($inputLine in $powershellInputUNInstall)
					{
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
				}
				
				
			}
			$powershell_output_textbox5.AppendText("`New install.ps1 and uninstall.ps1 created!`r`n")
			$powershell_output_textbox5.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
			$Powershell_testUnInstall_button2.Enabled = $true
			$Powershell_testUnInstall_button2.Visible = $true
			$Powershell_testInstall_button2.Enabled = $true
			$Powershell_testInstall_button2.Visible = $true
			$Powershell_CreateIntuneWIn_button2.Enabled = $true
			$Powershell_CreateIntuneWIn_button2.Visible = $true
			
		}
	}

}

$powershell_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	Invoke-Item "$config_packagefolder\$powershellpnaam\$powershellversie\source\"
}

$powershell_install_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_uninstall_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_packagename_textbox_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$Powershell_testInstall_button2_Click = {
	#TODO: Place custom script here
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$usercontext = 'In User context'
		$sysemcontext = $null;
		
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$usercontext = 'in Sytem context'
		$sysemcontext = 'Testing Sytem context as Elevated user;'
	}
	if ([System.Windows.Forms.MessageBox]::Show("Please test your script. After editing. Please use the save button in Powershell_ISE", "Openening Powershell_ISE in $32or64", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.Text
		$powershellversie = $powershell_packageversion_textbox.Text
		$installScript = Join-Path -Path $config_packagefolder -ChildPath "$powershellpnaam\$powershellversie\source\install.ps1"
		$ise32Path = "$env:windir\SysWOW64\WindowsPowerShell\v1.0\PowerShell_ISE.exe"
		$ise64Path = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe"
		if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
		{
				Start-Process -FilePath $ise32Path -ArgumentList $installScript
		}
		else
		{
				Start-Process -FilePath $ise64Path -ArgumentList $installScript
		}
		PowershellISEOnTop
		
	}
}

$Powershell_testUnInstall_button2_Click = {
	#TODO: Place custom script here
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$usercontext = 'In User context'
		$sysemcontext = $null;
		
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$usercontext = 'in Sytem context'
		$sysemcontext = 'Testing Sytem context as Elevated user;'
	}
	if ([System.Windows.Forms.MessageBox]::Show("Please test your script. After editing. Please use the save button in Powershell_ISE", "Openening Powershell_ISE in $32or64", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.Text
		$powershellversie = $powershell_packageversion_textbox.Text
		$installScript = Join-Path -Path $config_packagefolder -ChildPath "$powershellpnaam\$powershellversie\source\uninstall.ps1"
		$ise32Path = "$env:windir\SysWOW64\WindowsPowerShell\v1.0\PowerShell_ISE.exe"
		$ise64Path = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe"
		if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
		{
				Start-Process -FilePath $ise32Path -ArgumentList $installScript
		}
		else
		{
				Start-Process -FilePath $ise64Path -ArgumentList $installScript
		}
		PowershellISEOnTop
		
	}
}

$Powershell_CreateIntuneWIn_button2_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$powershell_output_textbox5.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$powershellpnaam\$powershellversie\source\" -s "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -o "$outputDirectory\$powershellpnaam\$powershellversie\output\" -q
	Rename-Item -Path "$outputDirectory\$powershellpnaam\$powershellversie\output\install.intunewin" -NewName "$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin"
	$powershell_output_textbox5.AppendText("`nIntunewin file created: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin")
	$powershell_output_textbox5.AppendText("`r`n")
	
	$powershell_output_textbox5.AppendText("Install command is: `r`n")
	if ($32or64 -like "32 Bit Mode")
	{
		$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
		$powershell_output_textbox5.AppendText("un-install command is: `r`n")
		$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
		$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	}
	else
	{
		$powershell_output_textbox5.AppendText("%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1 `r`n")
		$powershell_output_textbox5.AppendText("un-install command is: `r`n")
		$powershell_output_textbox5.AppendText("%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file uninstall.ps1 `r`n")
		$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	}
	
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		if ($32or64 -like "32 Bit Mode")
		{
			$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		}
		else
		{
			$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\$RegisterDetectionroot\"
		}
		
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	$powershell_output_textbox5.AppendText("$regkeyApp `r`n")
	$powershell_output_textbox5.AppendText("Detection Method is: 'String Comparison' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: 'Version' `r`n")
	$powershell_output_textbox5.AppendText("Detection Operator is: 'Equals' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: $powershellversie `r`n")
	$powershell_output_textbox5.AppendText("Please reopen tool to make another Powershell package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
		[string]$context
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$context = 'user'
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$context = 'system'
	}
	$IntuneWinPackageConfig = $null;
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $true)
	{
		$icmd = '%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1'
		$ucmd = 'SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1'
	}
	else
	{
		$icmd = "powershell -executionpolicy bypass -file install.ps1"
		$ucmd = "powershell -executionpolicy bypass -file uninstall.ps1"
	}
	
	
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$powershellpnaam.intunewin"
			DisplayName   = $powershellpnaam
			Publisher	  = $config_customername
			AppVersion    = $powershellversie;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = $icmd
			uninstallCMD  = $ucmd
			context		  = $context
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$powershellpnaam\$powershellversie\output\"
	$powershell_output_textbox5.AppendText("Config.csv written to: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv")
	$powershell_output_textbox5.AppendText("  `r`n")
	$Powershell_upload_logo_button.Enabled = $true
	$Powershell_upload_logo_button.Visible = $true
	$powershell_output_textbox5.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
	$powershell_output_textbox5.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
}

$Powershell_upload_logo_button_Click = {
	#TODO: Place custom script here
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $powershell_packagename_textbox.text
	$msiversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
	
}


$updatepackage_msi_open_config_button1_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$updatepackage_msi_appname_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appname_new_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appversion_textbox3.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$updatepackage_msi_appcustomer_textbox3.Text = $updatepackage_customername
	$updatepackage_msi_panel5.Enabled = $true
	$updatepackage_msi_panel5.Visible = $true
	$updatepackage_msi_panel4.Visible = $true
	$updatepackage_msi_panel4.Enabled = $true
}

$updatepackage_msi_label5_Click = {
	#TODO: Place custom script here
	
}

$labelAppName_Click = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_Yes_radiobutton1_CheckedChanged = {
	#TODO: Place custom script here
	if ($updatepackage_msi_Yes_radiobutton1.Checked -eq $true)
	{
		$updatepackage_msi_panel6.Enabled = $true
		$updatepackage_msi_panel6.Visible = $true
	}
	else
	{
		$updatepackage_msi_panel6.Enabled = $false
		$updatepackage_msi_panel6.Visible = $false
	}
}

$updatepackage_msi_clone_button_Click = {
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($updatepackage_msi_change_customer_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($updatepackage_msi_appversion_new_textbox3.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $updatepackage_msi_change_customer_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$updatepackage_msi_appname_new_textbox3.text = $powershellpnaam
		$powershellversie = $updatepackage_msi_appversion_new_textbox3.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_msi_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_msi_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_msi_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$versie  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_msi_output_textbox4.AppendText("config.csv creation done; Please open new package source dir and change MSI file and other source files; Step 3")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("Replace MSI file for newer version with a. MSI file with the same name or b. change the Install parameters below")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
	}
	
}


$updatepackage_msi_appname_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_appversion_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_panel5_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$updatepackage_msi_installParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_open_source_dir_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	
}

$updatepackage_msi_testinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Add-Type -AssemblyName PresentationFramework
	$imagePath = "C:\Program Files\IntunePrepTool\update_package_msi_copy_uninstallstring.png"
	$window = New-Object system.windows.window
	$window.Title = "IntunePrepTool MSI uninstall command help"
	$window.Width = 603
	$window.Height = 700
	$window.WindowStartupLocation = 'CenterScreen'
	$dockPanel = New-Object System.Windows.Controls.DockPanel
	$image = New-Object System.Windows.Controls.Image
	$image.Source = [System.Windows.Media.Imaging.BitmapImage]::new([Uri]::new($imagePath))
	$image.Stretch = "Fill"
	$button = New-Object System.Windows.Controls.Button
	$button.Content = "Understood, open PowerShell_ISE now"
	$button.Width = 250
	$button.HorizontalAlignment = "Center"
	$button.VerticalAlignment = "Bottom"
	$button.Add_Click({
			powershell_ise -file "$newpackage_sourcepath\install.ps1"
			$window.Close() # Close the window after opening PowerShell ISE
		})
	[System.Windows.Controls.DockPanel]::SetDock($button, [System.Windows.Controls.Dock]::Bottom)
	$dockPanel.Children.Add($button)
	$dockPanel.Children.Add($image)
	$window.Content = $dockPanel
	$window.ShowDialog()
	
	
	$updatepackage_msi_panel66.Enabled = $true
}

$updatepackage_msi_saveinstallparemeters_button_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_testinstall_button1.Enabled = $true
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_installParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\i.cmd" -encoding ascii -Force -ErrorAction Stop
}

$updatepackage_msi_testuninstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_uninstallParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\u.cmd" -encoding ascii -Force -ErrorAction Stop
	$updatepackage_msi_testuinstall_button1.Enabled = $true
}

$updatepackage_msi_uninstallParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_testuinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
	$updatepackage_msi_panel67.Enabled = $true
}

$updatepackage_msi_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_msi_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_msi_output_textbox4.AppendText("`r`n")
	
	$updatepackage_msi_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
	
}



$exe_open_Azure_OpenAI_Example_button1_Click = {
	#TODO: Place custom script here
	
	if (!(Test-Path "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"))
	{
		[void][System.Windows.Forms.MessageBox]::Show("Go to config tab to configure Azure AI OpenAI Deployment", 'Please setup Azure AI Config first')
	}
	else
	{
		$OpenAICSV = Import-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"
		
		
		$exe_appDname = $exe_packagenaam_textbox1.Text
		$EXEName = $exe_openfiledialog1.SafeFileName
		$apiKey = $OpenAICSV.Key
		$endpoint = $OpenAICSV.endpointURL
		$deployname = $OpenAICSV.deploymentName
		$uri = $endpoint + "openai/deployments/" + $deployname + "/chat/completions?api-version=2024-02-15-preview"
		$body = @"
{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Show example of silent install parameters for $exe_appDname EXE file: $EXEName"
        }
      ]
    }
  ],
  "temperature": 0.4,
  "top_p": 0.95,
  "max_tokens": 800
}
"@
		
		
		$headers = @{
			"Content-Type" = "application/json"
			"api-key"	   = $apiKey
		}
		try
		{
			$request = Invoke-RestMethod -Method POST -Uri $uri -ContentType "application/json" -Body $body -Headers $headers -ErrorAction Stop
			$text = $request.choices.message.content
			$startPattern = '```sh'
			$endPattern = '```'
			$start = $text.IndexOf($startPattern) + $startPattern.Length
			$end = $text.IndexOf($endPattern, $start)
			
			
			if ($start -ge 0 -and $end -gt $start)
			{
				$command = $text.Substring($start, $end - $start).Trim()
				
				$commandParts = $command -split " "
				$commandWithoutExe = $commandParts[1 .. ($commandParts.Length - 1)] -join " "
				
				$exe_parsInstall_textbox1.Text = "`"$commandWithoutExe`""
				$text = $text -replace '```sh', ""
				$text = $text -replace '`', ""
				$exe_richtextbox3.Text = $text
				$exe_panel5.Enabled = $true
				$exe_panel5.Visible = $true
				$exe_open_Azure_OpenAI_Example_button1.Text = "Retry Azure OpenAI"
				
			}
			
		}
		catch
		{
			
			if ($_.Exception.Message -like 'The remote server returned an error: (429) Too Many Requests.')
			{
				
				[void][System.Windows.Forms.MessageBox]::Show('Please wait 30 seconds before trying again', '(429) Too Many Requests.')
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show("($_.Exception.Message)", 'Error message')
			}
		}
	}
}

$config_openAI_save_button2_Click = {
	#TODO: Place custom script here
	class openAIAzure {
		[string]$key
		[string]$endpointURL
		[string]$deploymentName
		
	}
	$openAIAzure = $null;
	$openAIAzure += @([openAIAzure]@{
			key		       = $config_openAI_textbox6.Text
			endpointURL    = $config_openAI_textbox7.Text
			deploymentName = $config_openAI_textbox8.Text
			
		})
	
	$openAIAzure | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv" -NoTypeInformation -Force
	[void][System.Windows.Forms.MessageBox]::Show('U can use the Azure OpenAI button in the tool now', 'CSV file with config written to  c:\users\$env:USERNAME\.IntunePrepTool\')
	
}


$config_openAI_help_Click = {
	#TODO: Place custom script here
	Invoke-Item "C:\Program Files\IntunePrepTool\IntunePrepTool-AzureOpenAI-setup-Screenshots.pdf"

}




$config_openAI_textbox8_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox7_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox6_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_radiobutton2_CheckedChanged={
	#TODO: Place custom script here
	
}

$updatePackageIntunewinToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$updatepackage_exe_open_config_button1_Click={
	#TODO: Place custom script here
	$update_exe_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$update_exe_appname_old_textbox5.Text = $ConfigCSVImport.DisplayName
	$update_exe_new_appname_textbox7.Text = $ConfigCSVImport.DisplayName
	$update_exe_appversion_old_textbox4.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$update_exe_customer_old_textbox3.Text = $updatepackage_customername
	$updatepackage_EXE_panel6.Enabled = $true
	$updatepackage_EXE_panel6.Visible = $true
	$update_exe_panel4.Visible = $true
	$update_exe_panel4.Enabled = $true
}

$update_exe_buttonStep2CloneToNewDirec_Click={
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($update_exe_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($update_exe_new_appversion_textbox6.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $update_exe_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $update_exe_new_appname_textbox7.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$update_exe_new_appname_textbox7.text = $powershellpnaam
		$powershellversie = $update_exe_new_appversion_textbox6.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_exe_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_exe_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $update_exe_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_exe_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appName =*') -or ($lni -like '$version  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$appName =*') -or ($lni -like 'Versie =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("Replace EXE file for newer version with a. EXE file with the same name or b. change the Install parameters below")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		<#
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		#>
		$update_exe_panel6.Enabled = $true
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		foreach ($lni2 in $installparameters)
		{
			if ($lni2 -like '$exeParameters =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exeparameters2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exeparameters2 = $null
				}
				$exeparameters2 = $exeparameters2 -replace "^ ", ""
				$exeparameters2 = $exeparameters2.split("#")[0]
				$update_exe_installPar_textbox3.Text = $exeparameters2
			}
			if ($lni2 -like '$exeFile =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exefilename2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exefilename2 = $null
				}
				$exefilename2 = $exefilename2 -replace "^ ", ""
				
				$update_exe_Exefilename_textbox3.Text = $exefilename2
			}
			
		}

	
		$IsThisLineThereInUninstall = $old_uninstallps1 | ForEach-Object {
			if ($_ -match 'Please see u\.cmd for MSI parameters used by this script')
			{
				$_.Trim() 
			}
		} | Where-Object { $_ }
		if ($IsThisLineThereInUninstall)
		{
			Write-Host "De regel is aanwezig: $IsThisLineThereInUninstall"
			$update_exe_uninstall_panel6.Enabled = $false
			$update_exe_uninstall_panel6.Visible = $false
			$update_Exe_Uninstall_MSI_panel6.Enabled = $true
			$update_Exe_Uninstall_MSI_panel6.Visible = $true
			$update_exe_msi_uninstallcommandsOld = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\u.cmd"
			$udpdate_exe_msi_uninstall_textbox4.Text = $update_exe_msi_uninstallcommandsOld
			[void][System.Windows.Forms.MessageBox]::Show('See Find Uninstall String in the tools menu to search for new uninstall productcode and change the uninstall parameters after testing installation', 'Change uninstall string')
			
		}
		else
		{
			$oldInstallExeFilename = $old_installps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeFilename = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeParameters = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeParameters\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			#Write-Host "Old Install EXE Filename: $oldInstallExeFilename"
			#Write-Host "Old Uninstall EXE Filename: $oldUnInstallExeFilename"
			if ($oldInstallExeFilename -like $oldUnInstallExeFilename)
			{
				#Write-Host "Same EXE as install: $oldUnInstallExeFilename)"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
			Else
			{
				#Write-Host "Uninstall EXE path is $oldUnInstallExeFilename"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
		}
		
		
		
	}
}

$update_exe_buttonStep3OpenSourceDirec_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	$update_exe_buttonStep4SaveInstallPara.Enabled = $true
}

$update_exe_buttonStep4SaveInstallPara_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$installparameters = Get-Content "$newpackage_sourcepath\install.ps1"
	Remove-Item "$newpackage_sourcepath\install.ps1"
	foreach ($lni2 in $installparameters)
	{
		if (($lni2 -like '$exeParameters =*') -or ($lni2 -like '$exeFile =*'))
		{
			
			
			if ($lni2 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_installPar_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
			if ($lni2 -like '$exeFile =*')
			{
				
				'$exeFile = ' + $update_exe_Exefilename_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
		}
		else
		{
			$lni2 | Out-File "$newpackage_sourcepath\install.ps1" -Append
		}
		
	}
	$update_exe_buttonStep5TestAndEditInst.Enabled = $true
}

$update_exe_buttonStep5TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\install.ps1"
	
}

$buttonStep7TestAndEditUnin_Click={
	#TODO: Place custom script here
	
}

$update_exe_uninstall_msi_save_button3_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$udpdate_exe_msi_uninstall_textbox4.Text | Out-File "$newpackage_sourcepath\u.cmd" -Force
	$update_exe_uninstall_MSI_Test_button2.Enabled = $true
}

$update_exe_uninstall_MSI_Test_button2_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$buttonStep6SaveUninstallPa_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$uninstall_exe_uninstall = Get-Content "$newpackage_sourcepath\uninstall.ps1"
	Remove-Item "$newpackage_sourcepath\uninstall.ps1" -Confirm:$false -Force
	foreach ($lni5 in $uninstall_exe_uninstall)
	{
		if (($lni5 -like '$exeFile =*') -or ($lni5 -like '$exeParameters =*'))
		{
			if ($lni5 -like '$exeFile =*')
			{
				'$exeFile = ' + $update_exe_filetpathUninstall_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
			if ($lni5 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_uninstall_parameters_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
		}
		else
		{
			$lni5 | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			
		}
		
	}
	$update_exe_testuninstall_exe_buttonStep7TestAndEditInst.Enabled = $true
	
}

$update_exe_testuninstall_exe_buttonStep7TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$update_exe_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $update_exe_new_appname_textbox7.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_exe_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_exe_output_textbox4.AppendText("`r`n")
	
	$updatepackage_exe_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
}


$tools_choco_search_button2_Click={
	#TODO: Place custom script here
	
	
	function chocoSearch
	{
		param (
			[Parameter(Mandatory = $true)]
			[string]$name,
			[bool]$approvedOnly = $false
		)
		
		$chocoSearch = choco find $name --order-by-popularity
		if ($chocoSearch.Count -gt 2)
		{
			$chocoSearch = $chocoSearch[1 .. ($chocoSearch.Count - 2)]
		}
		
		$results = @()
		
		foreach ($ch in $chocoSearch)
		{
			$splitLine = $ch.Split(" ", 3, [System.StringSplitOptions]::RemoveEmptyEntries)
			if ($splitLine.Count -lt 2)
			{
				continue
			}
			
			$currentName = $splitLine[0]
			$currentVersion = $splitLine[1]
			$remaining = ""
			if ($splitLine.Count -eq 3)
			{
				$remaining = $splitLine[2]
			}
			if ($ch -match 'found|know|Learn')
			{
				continue
			}
			$isApproved = ($remaining -match '\[Approved\]')
			if ($approvedOnly -and -not $isApproved)
			{
				continue
			}
			$obj = [pscustomobject]@{
				Name	 = $currentName
				Version  = $currentVersion
				Approved = $isApproved
			}
			
			$results += $obj
		}
		
		return $results
	}
	$sChoco = $tools_choco_search_textbox3.Text
	
	
	if ($tools_choco_checkbox1.Checked -eq $true)
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $true
	}
	else
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $false
	}
	try
	{
		New-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script
	}
	

	$tools_choco_treeview2.BeginUpdate()
	$tools_choco_treeview2.Refresh()
	$tools_choco_treeview2.Nodes.Clear()
	#$tools_choco_treeview2.CheckBoxes = $true
	$Root = $tools_choco_treeview2.Nodes.Add("Choco Packages")
	foreach ($p in $chocoOutput)
	{
		#$upload_treeview2.Nodes.Add($tenantCSV.customername)
		$node = $Root.Nodes.Add($p.Name)
		
		$node.ContextMenuStrip = $tools_choco_contextmenustrip1
		#$node.Tag = $tenantCSV.target
		$node.Name = $p.Name
		
		
	}
	$Root.Expand()
	$tools_choco_treeview2.EndUpdate()
}

$config_tenants_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}



$tools_choco_contextmenustrip1_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$choco_toolstripmenuitem1_Click= {
	#TODO: Place custom script here
	

}
$tools_choco_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$chocoAll = Get-Variable -Name 'chocoOutput2' -Scope Script -ValueOnly
	$tools_choco_details_richtextbox1.text = ""
	
	foreach ($ch1 in $chocoAll)
	{
		if ($ch1.Name -eq $tools_choco_treeview2.SelectedNode.Name)
		{
			$tools_choco_panel6.Enabled = $true
			$tools_choco_selected_label6.Enabled = $true
			$tools_choco_selected_label6.Visible = $true
			$tools_choco_selected_label6.Text = $ch1.Name
			$chocoDetails = choco find $ch1.Name --exact --detail
			foreach ($ch2 in $chocoDetails)
			{
				$tools_choco_details_richtextbox1.AppendText("`r`n")
				$tools_choco_details_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}



$tools_choco_createdir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $tools_choco_displayname_textbox3.text
	$exeversie = $tools_choco_appversion_textbox3.text
	$exepnaam = $exepnaam -replace (" ", "")
	$tools_choco_displayname_textbox3.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$tools_choco_output_textbox3.Text = "`nNew package directory created: `r`n"
			$tools_choco_output_textbox3.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$tools_choco_output_textbox3.AppendText("`r`n")
			$tools_choco_panel7.Enabled = $true
			$tools_choco_open_PackageDir_button2.Enabled = $true
			$tools_choco_buttonOpenPackageDirectory.Enabled = $true
			$tools_choco_buttonOpenPackageDirectory.Visible = $true
		}
	}
}
$tools_choco_displayname_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_appversion_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_createscriots_button2_Click={
	#TODO: Place custom script here
	$choco_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:19
	 Created by:   	Rink Turksma
	 Organization: 	https://githhub.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"
$paramsChoco = "!!paramsChocho!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
if (!(test-path -Path "$env:programdata\chocolatey"))
	{
		write-host "Installing Chocolatey"
		[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
	}


write-host "Now installing: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green
try
{
	write-host "Choco installation started" -ForegroundColor Green
	if ($paramsChoco -eq 'false')
	{
		choco install $chocoName --exact --yes --force
	}
	else
	{
		choco install $chocoName --exact --params $paramsChoco --yes --force
	}
	write-host "Installation success" -ForegroundColor Green
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	write-host "Now creating weekly scheduled task to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek Monday -At 10:00
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}

if ($startupUpdateTask -eq 'true')
{
	write-host "Now creating scheduled task at startup to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -AtStartup
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}


try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	fDetectionInRegistry -succes $true
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	$choco_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:25
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
write-host "Now uninstalling: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green




try
{
	write-host "Choco uninstallation started" -ForegroundColor Green
	choco uninstall $chocoName --exact --yes --force
	write-host "UnInstallation success" -ForegroundColor Green
}
catch
{
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}
if ($startupUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
	
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000)
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	remove-item $regkeyApp
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$RegisterDetectionroot = "Intune_" + $config_customername
	$appVersion = $tools_choco_appversion_textbox3.text
	$appName = '"' + $tools_choco_displayname_textbox3.text + '"'
	$appName2 = $tools_choco_displayname_textbox3.text
	$chocoName = $tools_choco_selected_label6.Text
	
	$choco_installFile  = $choco_installFile.Replace('"!!AppName!!"', $appName)
	$choco_installFile  = $choco_installFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_installFile  = $choco_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_installFile  = $choco_installFile.Replace('!!version!!', $appVersion)
	$choco_installFile = $choco_installFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true' 
	$choco_installFile = $choco_installFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true) { $paramschoco = $tools_choco_parammstextbox3.Text; $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', $paramschoco) }
	else { $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', 'false') }
	try
	{
		$choco_installFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$appName2\$appVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	$choco_uninstallFile = $choco_uninstallFile.Replace('"!!AppName!!"', $appName)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!version!!', $appVersion)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true'
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	try
	{
		$choco_uninstallFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\uninstall.ps1" -Force -ErrorAction Stop
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
		$tools_choco_panel11.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 NOT created `r`n")
	}
}

$tools_choco_open_PackageDir_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$AppVersion = $tools_choco_appversion_textbox3.text
	Invoke-Item "$config_packagefolder\$appName\$appVersion\"
}

$tools_choco_testinstall_button2_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$appName = $tools_choco_displayname_textbox3.text
		$appVersion = $tools_choco_appversion_textbox3.text
		powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$tools_choco_testUNinstall_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	$tools_choco_addBuildingBlocksCSVButton.Enabled = $true
}

$config_download_Choco_MSIX_bundle_Click={
	#TODO: Place custom script here
	
	$config_install_required_chocolatey = @'
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$picturebox1_Click={
	#TODO: Place custom script here
	
}

$tools_choco_AddParams_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true)
	{
		$tools_choco_parammstextbox3.Enabled = $true
		$tools_choco_parammstextbox3.Visible = $true
	}
	else
	{
		$tools_choco_parammstextbox3.Enabled = $false
		$tools_choco_parammstextbox3.Visible = $false
	}
}

$tools_choco_create_intunewin_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$appName\$appVersion\source\" -s "$config_packagefolder\$appName\$appVersion\source\install.ps1" -o "$config_packagefolder\$appName\$appVersion\output\" -q
	Rename-Item -Path "$config_packagefolder\$appName\$appVersion\output\install.intunewin" -NewName "$config_packagefolder\$appName\$appVersion\output\$appName.intunewin"
	$tools_choco_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\$appName.intunewin")
	$tools_choco_output_textbox3.AppendText("`r`n")
	
	$tools_choco_output_textbox3.AppendText("Install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("un-install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$appName\"
	$regkeyApp
	$tools_choco_output_textbox3.AppendText("$regkeyApp `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: $appVersion `r`n")
	$tools_choco_output_textbox3.AppendText("Please reopen tool to make another Chocolatey package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$appName.intunewin"
			DisplayName   = $appName
			Publisher	  = $config_customername
			AppVersion    = $appVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$appName\$appVersion\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$appName\$appVersion\output\"
	$tools_choco_output_textbox3.AppendText("Config.csv written to naar: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\config.csv")
	$tools_choco_output_textbox3.AppendText("  `r`n")
	$buildingBlokcsCSV = $choco_buildingBlocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$config_packagefolder\$appName\$appVersion\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appName\BuildingBlocks.csv" -force -NoTypeInformation
		$tools_choco_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$tools_choco_output_textbox3.AppendText("$config_buildingblockspath\$appName\BuildingBlocks.csv `r`n")
		$tools_choco_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$tools_choco_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$tools_choco_output_textbox3.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$tools_choco_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
	
}

$tools_choco__upload_logo_button2_Click={
	#TODO: Place custom script here
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $tools_choco_displayname_textbox3.text
	$msiversie = $tools_choco_appversion_textbox3.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
	$tools_choco_output_textbox3.AppendText("`r`n")
	$tools_choco_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}

$winget_search_button2_Click={
	$downloadWingetSearchText = $winget_search_textbox3.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$winget_output_textbox3.Text = $null
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	$winget_search_treeview2.BeginUpdate()
	$winget_search_treeview2.Refresh()
	$winget_search_treeview2.Nodes.Clear()
	$Root = $winget_search_treeview2.Nodes.Add("Winget Packages")
	$wingetOutp1 = @()
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$wingetOutp2 = $row_download_winget | Select ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$wingetOutp1 += [PSCustomObject]@{ ID = $wingetOutp2 }
				$node = $Root.Nodes.Add($download_winget_listboxInput)
				$node.Name = $wingetOutp2
			}
			$table_download_winget.AcceptChanges();	
			
		}
		
	}
	$Root.Expand()
	$winget_search_treeview2.EndUpdate()
	try
	{
		New-Variable -Name 'wingetOutput' -Value $wingetOutp1 -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'wingetOutput' -Value $wingetOutp1 -Scope Script
	}
	
	
}

$winget_search_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$wingetAll = Get-Variable -Name 'wingetOutput' -Scope Script -ValueOnly
	$winget_show_info_richtextbox1.text = $null;
	foreach ($ch1 in $wingetAll.ID)
	{
		if ($ch1 -eq $winget_search_treeview2.SelectedNode.Name)
		{
			#$tools_choco_panel6.Enabled = $true
			#$tools_choco_selected_label6.Enabled = $true
			#$tools_choco_selected_label6.Visible = $true
			#$tools_choco_selected_label6.Text = $ch1.Name
			#$winget_settings_panel7.Enabled = $true;
			$winget_selected_panel7.Enabled = $true
			$winget_createPackageDIR_panel7.Enabled = $true
			$wingetDetails = winget show --id $ch1
			$ch1 = $ch1.Replace('"','')
			$winget_WingetID_textbox1.Text = $ch1
			foreach ($ch2 in $wingetDetails)
			{
				$winget_show_info_richtextbox1.AppendText("`r`n")
				$winget_show_info_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}

$winget_CreatePackageDir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$version = $versie_textbox2.Text
		if ($version -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
		
			if (!(Test-Path -Path "$config_packagefolder\$DisplayName\$version\source"))
			{
				
				New-Item -ItemType Directory -Path "$config_packagefolder\$DisplayName\$version\source"
			}
			if (!(Test-Path -Path "$config_packagefoldery\$DisplayName\$version\output"))
			{
				
				New-Item -ItemType Directory -Path "$config_packagefolder\$DisplayName\$version\output"
			}
			$winget_open_package_dir_button3.Enabled = $true
			$winget_settings_panel7.Enabled = $true
			$winget_buttonAddCustomDescription.Enabled = $true
			$winget_buttonAddCustomDescription.Visible = $true
			
		}
	}
}
$winget_open_package_dir_button3_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$version = $versie_textbox2.Text
	Invoke-Item "$config_packagefolder\$DisplayName\$version"
}

$checkbox1_CheckedChanged={
	#TODO: Place custom script here
	
}

$radiobutton64Bit_CheckedChanged={
	#TODO: Place custom script here
	
}

$config_version_label1_Click={
	#TODO: Place custom script here
	
}

$config_install_sandbox_buttonInstallSanboxPowersh_Click={
	#TODO: Place custom script here
	$config_install_required_chocolatey = @'
Enable-WindowsOptionalFeature -FeatureName "Containers-DisposableClientVM" -All -Online
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installSandbox.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey | Out-File "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installSandbox.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey | Out-File "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$config_add_Tenant_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}



$registryToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}


$capture_registry_loadTreeview_button2_Click={
	#TODO: Place custom script here

		

	
	
}

$Registry_capture_panel7_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$capture_registry_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	#Source https://www.sapien.com/forums/viewtopic.php?t=11679
	if ($_.Node.Nodes.Count -eq 0)
	{
		foreach ($keyName in ($_.Node.Tag.GetSubkeyNames()))
		{
			Try
			{
				$regKey = $_.Node.Tag.OpenSubKey($keyName)
				$n = New-Object System.Windows.Forms.TreeNode
				$n.Name = $regKey.PsPath
				$n.Text = $keyName
				$n.Tag = $regKey
				$_.Node.Nodes.Add($n)
			}
			Catch
			{
				Write-Host $_
			}
		}
	}

}

$registry_capture_tabpage5_Click={
	#TODO: Place custom script here
	
}

$Registry_Capture_Step2_CreateBackup_button2_Click = {
	if ($registry_name_textbox3.Text -notlike $null)
	{
		
		$node = $capture_registry_treeview2.SelectedNode
		$nodeTexts = @()
		while ($node)
		{
			$nodeTexts += $node.Text
			$node = $node.Parent
		}
		$reversedNodeTexts = @()
		for ($i = $nodeTexts.Count - 1; $i -ge 0; $i--)
		{
			$reversedNodeTexts += $nodeTexts[$i]
		}
		$rootHive = ""
		$allNodesString = $rootHive + ($reversedNodeTexts -join "\")
		
		$RegistryCaptureScript = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	22-3-2025 20:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	regcompare.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$regexportpath = "!!regexportpath!!"
$backupFolder = "!!backupFolder!!"
if (!(Test-Path $backupFolder))
{
	New-Item -Path $backupFolder -ItemType Directory | Out-Null
}
$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$preBackupPath = Join-Path $backupFolder "PreChanges_$timeStamp.reg"
$postBackupPath = Join-Path $backupFolder "PostChanges_$timeStamp.reg"
$DiffRegName = "!!DiffRegName!!"
$diffPath = Join-Path $backupFolder "$DiffRegName`_$timeStamp.reg"

Write-Host "Exporting registry from: $regExportPath"  
Write-Host "Creating first registry backup (pre-changes)..."  
reg export "$regExportPath" "$preBackupPath" /y | Out-Null
Write-Host "  Pre-changes backup saved to: $preBackupPath`n"
Write-Host "Make any desired changes to your registry/application now." -ForegroundColor Green
Write-Host "Press ENTER when finished..." -ForegroundColor Green
Read-Host
Write-Host "`nCreating second registry backup (post-changes)..."  
reg export "$regExportPath" "$postBackupPath" /y | Out-Null
Write-Host "  Post-changes backup saved to: $postBackupPath`n"  
Write-Host "Now comparing backups to find differences..."  

function Compare-RegFiles
{
	param (
		[string]$OldRegPath,
		[string]$NewRegPath,
		[string]$DiffOutPath
	)
	
	$oldLines = [System.IO.File]::ReadAllLines($OldRegPath)
	$newLines = [System.IO.File]::ReadAllLines($NewRegPath)
	$oldHashSet = [System.Collections.Generic.HashSet[string]]::new($oldLines)
	$differences = New-Object System.Collections.Specialized.OrderedDictionary
	$currentKey = $null
	foreach ($line in $newLines)
	{
		if ($line -match '^\[\S+\]$')
		{
			$currentKey = $line
			continue
		}
		if ($line -match '^\S+=' -and $currentKey)
		{
			if (-not $oldHashSet.Contains($line))
			{
				if (-not $differences.Contains($currentKey))
				{
					$differences[$currentKey] = [System.Collections.Generic.List[string]]::new()
				}
				$differences[$currentKey].Add($line)
			}
		}
	}
	if ($differences.Count -gt 0)
	{
		Set-Content -Path $DiffOutPath -Value "Windows Registry Editor Version 5.00`r`n"
		foreach ($key in $differences.Keys)
		{
			Add-Content -Path $DiffOutPath -Value "`r`n$key"
			foreach ($val in $differences[$key])
			{
				Add-Content -Path $DiffOutPath -Value $val
			}
		}
		Write-Host "Differences found! Saved to: $DiffOutPath" -ForegroundColor Green
		$DiffOutPath | out-file "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt" -force
	}
	else
	{
		Write-Host "No differences detected."  
		if (Test-Path $DiffOutPath)
		{
			Remove-Item $DiffOutPath -ErrorAction SilentlyContinue
		}
	}
}

Compare-RegFiles -OldRegPath $preBackupPath `
				 -NewRegPath $postBackupPath `
				 -DiffOutPath $diffPath


Write-Host "`nRemoving the two backup files..."  
Remove-Item -Path $preBackupPath -ErrorAction SilentlyContinue
Remove-Item -Path $postBackupPath -ErrorAction SilentlyContinue

Write-Host "`nAll done. Please close this Powershell_ISE window and continue in the IntunePrepTool"


'@
		if (Get-Process -Name "powershell_ise" -ErrorAction SilentlyContinue)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please close any existing Powershell_ISE windows, When done.. Start again', 'Please close existing Powershell_ISE windows')
		}
		else
		{
			
			if ($registry_name_textbox3.text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please select Name first, When done.. Start again', 'Please select Name first')
			}
			else
			{
				if ($Registry_HKLM_radiobutton1.Checked -eq $true)
				{
					$regName = "HKLM_"
				}
				if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
				{
					$regName = "HKCU_"
				}
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!regexportpath!!", $allNodesString)
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$BackupLocation = $config_packagefolder + '\' + "0_BuildingBlocks\Registry"
				$BackupLocation = $BackupLocation -replace ("\\", "\")
				$regName2 = $regName + $registry_name_textbox3.text
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!DiffRegName!!", $regName2)
				
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!backupFolder!!", $BackupLocation)
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!DiffRegName!!", $regName2)
				
				
				
				if (!(Test-Path "C:\Program Files\IntunePrepTool\regcompare.ps1" -PathType Leaf))
				{
					$RegistryCaptureScript | Out-File "C:\Program Files\IntunePrepTool\regcompare.ps1"
					powershell_ise -file "C:\Program Files\IntunePrepTool\regcompare.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
				else
				{
					try
					{
						Remove-Item "C:\Program Files\IntunePrepTool\regcompare.ps1" -Confirm:$false -ErrorAction Stop
						$RegistryCaptureScript | Out-File "C:\Program Files\IntunePrepTool\regcompare.ps1"
						powershell_ise -file "C:\Program Files\IntunePrepTool\regcompare.ps1"
						Start-Sleep 1
						PowershellISEOnTop
					}
					catch
					{
						[void][System.Windows.Forms.MessageBox]::Show('When done.. Start again', 'Please close existing Powershell_ISE windows')
					}
					
					
				}
			}
		}
	}
	else
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Enter name and start again please', 'Please enter Name first')
	}
	
	
	
}



$Registry_load_button2_Click={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$capture_registry_treeview2.Refresh()
		$capture_registry_treeview2.Nodes.Clear()
		$capture_registry_treeview2.Refresh()
		if ($Registry_HKLM_radiobutton1.Checked -eq $true)
		{
			$regKey = Get-Item HKLM:\ -ErrorAction SilentlyContinue
		}
		if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
		{
			$regKey = Get-Item HKCU:\
		}
		
		$n = New-Object System.Windows.Forms.TreeNode
		$n.Name = $regKey.PsPath
		$n.Text = $regKey.Name
		$n.Tag = $regKey
		$capture_registry_treeview2.Nodes.Add($n)
		
		
	
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$toolstripstatuslabel1.Text = "Selected Customer: $config_customername"
	}
	
}

$registry_capture_label5_Click={
	#TODO: Place custom script here
	
}

$registry_name_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$registry_button2_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Please remove all irrelevant items and then click Save in Notepad.', 'Edit .reg file in Notepad')
	$regfile = Get-Content "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt"
	notepad $regfile
	
}

$buttonStep6AddBuildingBloc_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$BackupLocation = $config_packagefolder + '\' + "1_BuildingBlocksPackages\Registry"
	$BackupLocation = $BackupLocation -replace ("\\", "\")
	$regfile = Get-Content "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt"
	
	if ($Registry_HKLM_radiobutton1.Checked -eq $true)
	{
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if([System.Windows.Forms.MessageBox]::Show('In this case, a separate package is not needed. You can also add the created .reg file to your existing MSI, MSIX, or EXE package. Do you want to continue creating a separate package?', 'HKLM selected',[System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
			$systemoruser = "system"
			$regName = "HKLM_"
			$registry_output_textbox3.Text = "Creating Building Block Package in the System context"
			$registry_output_textbox3.AppendText("  `r`n")
			$BuildingBlockRegistrySystem = @'
if (Test-Path 'hklm.reg') {
    Write-Host "hklm.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hklm.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}

'@
			$BackupLocation = $BackupLocation + "\system\"
			$regName2 = $regName + $registry_name_textbox3.text
			$BackupLocation = $BackupLocation + $regName2
			if (!(Test-Path $backupLocation))
			{
				New-Item -Path $backupLocation -ItemType Directory -Force | Out-Null
				$registry_output_textbox3.AppendText("$backupLocation created")
				$registry_output_textbox3.AppendText("  `r`n")
			}
			else
			{
				$registry_output_textbox3.AppendText("$backupLocation already exists")
				$registry_output_textbox3.AppendText("  `r`n")
			}
			$BuildingBlockRegistrySystem | Out-File "$BackupLocation\BuildingBlock.ps1"
			$registry_output_textbox3.AppendText("BuildingBlock.ps1 created")
			$registry_output_textbox3.AppendText("  `r`n")
			Copy-Item $regfile "$backupLocation\hklm.reg"
			$registry_output_textbox3.AppendText("hklm.reg created")
			$registry_output_textbox3.AppendText("  `r`n")
			$registry_output_textbox3.AppendText("You can use this Building Block with other Building Blocks by selecting the System Context when creating the Intunewin file using the 'Building Blocks → Intunewin' function.")
			$registry_buidingblocksfiledir_textbox3.Text = $BackupLocation
			
		}
	}
	if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
	{
		$systemoruser = "user"
		$regName = "HKCU_"
		$registry_output_textbox3.Text = "Creating Building Block Package in the User context"
		$registry_output_textbox3.AppendText("  `r`n")
		$BuildingBlockRegistryUser = @'
if (Test-Path 'hkcu.reg') {
    Write-Host "hkcu.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hkcu.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
'@
		$BackupLocation = $BackupLocation + "\User\"
		$regName2 = $regName + $registry_name_textbox3.text
		$BackupLocation = $BackupLocation + $regName2
		if (!(Test-Path $backupLocation))
		{
			New-Item -Path $backupLocation -ItemType Directory -Force | Out-Null
			$registry_output_textbox3.AppendText("$backupLocation created")
			$registry_output_textbox3.AppendText("  `r`n")
		}
		else
		{
			$registry_output_textbox3.AppendText("$backupLocation already exists")
			$registry_output_textbox3.AppendText("  `r`n")
		}
		$BuildingBlockRegistryUser | Out-File "$BackupLocation\BuildingBlock.ps1"
		$registry_output_textbox3.AppendText("BuildingBlock.ps1 created")
		$registry_output_textbox3.AppendText("  `r`n")
		Copy-Item $regfile "$BackupLocation\hkcu.reg"
		$registry_output_textbox3.AppendText("hkcu.reg created")
		$registry_output_textbox3.AppendText("  `r`n")
		$registry_output_textbox3.AppendText("You can use this Building Block with other Building Blocks by selecting the User Context when creating the Intunewin file using the 'Building Blocks → Intunewin' function.")
		#$registry_buidingblocksfiledir_textbox3.Text = $BackupLocation
		
		
	}
	
	

	
	
	
	
}

$msi_addBuildBlock_regHKLM_Click={
	#TODO: Place custom script here
	<#
	$msi_add_HKLM_openfiledialog1.ShowDialog()
	$msi_reg_hklm_label5.Text = $msi_add_HKLM_openfiledialog1.SafeFileName
	$msi_reg_hklm_label5.Visible = $true
	$msi_reg_hklm_label5.Enabled = $true
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$paname = $msi_packagenaam_textbox1.text
	$paversion = $msi_versie_textbox1.text
	$selectedpadir = "$config_packagefolder\$paname\$paversion\source"
	$msi_output_textbox1.AppendText("`n.reg file will now be copied`r`n")
	[string]$msi_reg_hklm_org_path = $msi_add_HKLM_openfiledialog1.FileNames
	Copy-Item -Path $msi_reg_hklm_org_path -Destination "$selectedpadir\hklm.reg"
	$msi_output_textbox1.AppendText("`n.reg file copy done to HKLM.reg `r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("There`'s no need to recreate your install.ps1 script when already created. The created install.ps1 already checks for a file named 'hklm.reg' and imports it when available.", 'HKLM.reg file added') # Casting the method to [void] suppresses the output. 
	#>
}

$buttonOptionalOpenRegedit_Click={
	#TODO: Place custom script here
	regedit
}

$capture_registry_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$node = $capture_registry_treeview2.SelectedNode
	$nodeTexts = @()
	while ($node)
	{
		$nodeTexts += $node.Text
		$node = $node.Parent
	}
	$reversedNodeTexts = @()
	for ($i = $nodeTexts.Count - 1; $i -ge 0; $i--)
	{
		$reversedNodeTexts += $nodeTexts[$i]
	}
	$rootHive = ""
	$allNodesString = $rootHive + ($reversedNodeTexts -join "\")
	$registry_selected_textbox3.Text = $allNodesString
}

$Registry_OpenBuildingBLockLocationbutton2_Click={
	#TODO: Place custom script here
	explorer $registry_buidingblocksfiledir_textbox3.Text
}

$file_loadFolder_button2_Click={
	#TODO: Place custom script here
	$file_folderbrowsermoderndialog2.ShowDialog()
	$file_selected_source_folder_textbox3.Text = $file_folderbrowsermoderndialog2.SelectedPath
	$file_folder_destination_textbox3.Text = $file_folderbrowsermoderndialog2.SelectedPath
}

$hscrollbar1_Scroll=[System.Windows.Forms.ScrollEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ScrollEventArgs]
	#TODO: Place custom script here
	
}

$addFolderToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-BuildingBlocksFilesAndFolders_psf) -eq 'OK')
	{
		
	}
	
	<#
	$file_folder_panel8.Enabled = $true
	$file_folder_panel8.Visible = $true
	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
#>
	}

$file_folder_cancel_buttonAdd_Click={
	#TODO: Place custom script here
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false

}

$file_folder_add_button2_Click={
	#TODO: Place custom script here
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false
	
	if ($file_folder_skip_checkbox1.Checked -eq $true) {
		$file_folder_SKIP = $true
	}
	if ($file_folder_skip_checkbox1.Checked -eq $FALSE)
	{
		$file_folder_SKIP = $false
	}
	
	if ($file_folder_overwrite_checkbox1.Checked -eq $true)
	{
		$file_folder_overwrite = $true
	}
	if ($file_folder_overwrite_checkbox1.Checked -eq $FALSE)
	{
		$file_folder_overwrite = $false
	}
	
	
	$row = $table.NewRow();
	$row["Sort"] = 'folder';
	$row["Source"] = $file_selected_source_folder_textbox3.text;
	$row["Destination"] = $file_folder_destination_textbox3.Text;
	$row["Skip"] = $file_folder_SKIP;
	$row["Overwrite"] = $file_folder_overwrite;
	$table.Rows.Add($row);
	
	## - Save changes to the table:
	$table.AcceptChanges();
	## - Display custom data created:
	#$files_folders_datagridview1.DataSource = $table;
	
	
}

$config_tenant_info_secret_delete_button2_Click={
	#TODO: Place custom script here
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$file_file_cancel_buttonAdd_Click={
	#TODO: Place custom script here
	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
}

$addFileToolStripMenuItem_Click={
	#TODO: Place custom script here
	$file_file_panel8.Enabled = $true
	$file_file_panel8.Visible = $true
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false
}

$file_loadFile_button2_Click={
	#TODO: Place custom script here
	$file_file_openfiledialog1.ShowDialog()
	$file_selected_source_file_textbox3.Text = $file_file_openfiledialog1.FileNames
	$file_file_destination_textbox3.Text = $file_file_openfiledialog1.FileNames
}

$file_file_add_button2_Click={
	#TODO: Place custom script here
	if ($file_file_skip_checkbox1.Checked -eq $true)
	{
		$file_file_SKIP = $true
	}
	if ($file_file_skip_checkbox1.Checked -eq $FALSE)
	{
		$file_file_SKIP = $false
	}
	
	if ($file_file_overwrite_checkbox1.Checked -eq $true)
	{
		$file_file_overwrite = $true
	}
	if ($file_file_overwrite_checkbox1.Checked -eq $FALSE)
	{
		$file_file_overwrite = $false
	}
	
	
	$row = $table.NewRow();
	$row["Sort"] = 'file';
	$row["Source"] = $file_selected_source_file_textbox3.text;
	$row["Destination"] = $file_file_destination_textbox3.Text;
	$row["Skip"] = $file_file_SKIP ;
	$row["Overwrite"] = $file_file_overwrite;
	$table.Rows.Add($row);
	
	## - Save changes to the table:
	$table.AcceptChanges();

	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
}

$showCompleteToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-ChildForm_psf) -eq 'OK')
	{
		
	}
}

$addRegistryToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-BuildingBlocksRegistry_psf) -eq 'OK')
	{
		
	}
}

$file_folder_tablelayoutpanel1_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$toolstripstatuslabel1_Click={
	#TODO: Place custom script here
	
}

$statusbar1_PanelClick=[System.Windows.Forms.StatusBarPanelClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.StatusBarPanelClickEventArgs]
	#TODO: Place custom script here
	
}

$user_folder_context_system_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}

$BuildingBlocks_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$building_blocks_show_Refresh_button1_Click={
	#TODO: Place custom script here
	
}

$buttonAddFileOrFolder_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage5
	if ((Show-BuildingBlocksFilesAndFolders_psf) -eq 'OK')
	{
		
	}
}

$buildingblocks_buttonAddRegistryCapture_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage6
	if ((Show-BuildingBlocksRegistry_psf) -eq 'OK')
	{
		
	}
}

$buildingBlocks_clear_button1_Click={
	#TODO: Place custom script here
	$BuildingBlocksTable.Clear()
	$BuildingBlocks_datagridview1.DataSource = $BuildingBlocksTable;
	$BuildingBlocksTable2.Clear()
	$BuildingBlocks_datagridview2.DataSource = $BuildingBlocksTable2;
	$BuildingBlocksTable3.Clear()
	$BuildingBlocks_datagridview3.DataSource = $BuildingBlocksTable3;
	
	#$buildingBlocks_panel85.Enabled = $false;
	$bb_usePackageInProgress_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $true
	$bb_usePackageInProgress_radiobutton1.Enabled = $true
	$buildingblocks_Name_textbox4.Text = $null
	$buildingblocks_version_textbox3.Text = $null
}

$tablelayoutpanel9_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$buildingblocks_add_Shortcuts_button1_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage7
	if ((Show-BuildingBlocksShortcut_psf) -eq 'OK')
	{
		
	}
}

$buttonBuild_Click={
	#TODO: Place custom script here
	if ($buildingblocks_Name_textbox4.Text -like $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Select name and try again please!", 'Please select a name for Building Blocks first') # Casting the method to [void] suppresses the output.
	}
	else
	{
		class IntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
			[string]$context
		}
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
		if ($config_buildingblockspath -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please add Building Blocks location for your customer in the Start / Config menu first", 'Building Blocks location missing!')
		}
		else
		{
			$BBAppName = $buildingblocks_Name_textbox4.Text
			if (Test-Path "$config_buildingblockspath\$BBAppName")
			{
				[void][System.Windows.Forms.MessageBox]::Show("Please remove $config_buildingblockspath\$BBAppName before you can continue", 'Location Already exists')
			}
			else
			{
				$bbSystemContext = $false
				$bbUserContext = $false
				$newNameBuildingBlocks = $buildingblocks_Name_textbox4.Text
				$newNameBuildingBlocks = $newNameBuildingBlocks -replace (' ', '')
				$buildingblocks_Name_textbox4.Text = $newNameBuildingBlocks
				$buildingblocks_output_textbox5.Text = "Building Block Name: $newNameBuildingBlocks"
				$buildingblocks_output_textbox5.AppendText("  `r`n")
				$BuildingBlocksSystemLocation = $config_buildingblockspath + '\' + $newNameBuildingBlocks + "\System"
				$BuildingBlocksSystemLocation = $BuildingBlocksSystemLocation -replace ("\\", "\")
				$BuildingBlocksUserLocation = $config_buildingblockspath + '\' + $newNameBuildingBlocks + "\User" + "\BuildingBlocksData"
				$BuildingBlocksUserLocation = $BuildingBlocksUserLocation -replace ("\\", "\")
				$buildingBlockFolder = $config_buildingblockspath + '\' + $newNameBuildingBlocks
				$buildingBlockFolder = $buildingBlockFolder -replace ("\\", "\")
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show("IntunePrepTool may temporarily become unresponsive while creating the building blocks.", 'Please wait while the building block(s) are being created.') # Casting the method to [void] suppresses the output.
				$is = 1;
				$iu = 1;
				
				
				
				if ($BuildingBlocksTable -notlike $null)
				{
					
					foreach ($r in $BuildingBlocksTable)
					{
						$BuildingBlocksFilesAndFolders = @'
$sort = "!!sort!!"
$source = "!!source!!"
$destination = "!!destination!!"
$skip = "!!skip!!"
$overwrite = "!!overwrite!!"
#Replace when needed
$destination = $destination -replace("%USERPROFILE%", $env:USERPROFILE)
$destination = $destination -replace("%APPDATA%", $env:APPDATA)
$destination = $destination -replace("%LOCALAPPDATA%", $env:LOCALAPPDATA)
Set-Location $PSScriptRoot

if (($skip -eq $true) -and ($overwrite -eq $true))
{
	Write-Host "Overwrite takes precedence over skip."
	$skip = $false
}

if (($skip -eq $false) -and ($overwrite -eq $false))
{
	Write-Host "No Skip or Overwrite selected; Overwrite takes precedence over skip."
	$overwrite = $true
}

if ($overwrite -eq $true)
{
	if ($sort -like 'folder')
	{
		if (-not (Test-Path $destination))
		{
			New-Item -ItemType Directory -Path $destination | Out-Null
		}
		Get-ChildItem -Path "Data" -Recurse | ForEach-Object {
			$targetPath = Join-Path $destination $_.FullName.Substring((Get-Item "Data").FullName.Length)
			
			if ($_.PSIsContainer)
			{
				if (-not (Test-Path $targetPath))
				{
					New-Item -ItemType Directory -Path $targetPath | Out-Null
				}
			}
			else
			{
				try
				{
					Copy-Item $_.FullName -Destination $targetPath -Force -ErrorAction Stop
					$fn = $_.FullName
					Write-Host "Copy from $fn to  $targetPath done!"
				}
				catch
				{
					$fn = $_.FullName
					Write-Error "Copy from $fn to  $targetPath failed!"
				}
				
			}
		}
	}
	
	if ($sort -like 'file')
	{
		$parentfolder = Split-Path $destination -Parent
		if (-not (Test-Path $parentfolder))
		{
			New-Item -ItemType Directory -Path $parentfolder | Out-Null
		}
		try
		{
			Copy-Item $source -Destination $destination -Force -ErrorAction Stop
			Write-Host "Copy from $source to  $destination done!"
		}
		catch
		{
			Write-Error "Copy from $source to  $destination failed!"
		}
		
	}
}

if ($skip -eq $true)
{
	if ($sort -like 'folder')
	{
		if (-not (Test-Path $destination))
		{
			New-Item -ItemType Directory -Path $destination | Out-Null
		}
		Get-ChildItem -Path "Data" -Recurse | ForEach-Object {
			$targetPath = Join-Path $destination $_.FullName.Substring((Get-Item "Data").FullName.Length)
			
			if ($_.PSIsContainer)
			{
				if (-not (Test-Path $targetPath))
				{
					New-Item -ItemType Directory -Path $targetPath | Out-Null
				}
			}
			else
			{
				if (-not (Test-Path $targetPath))
				{
					try
					{
						Copy-Item $_.FullName -Destination $targetPath -ErrorAction Stop
						$fn = $_.FullName
						Write-Host "Copy from $fn to $targetPath done!"
					}
					catch
					{
						Write-Error "Copy from $fn to $targetPath failed!"
					}
					
				}
			}
		}
	}
	
	if ($sort -like 'file')
	{
		$parentfolder = Split-Path $destination -Parent
		if (-not (Test-Path $parentfolder))
		{
			New-Item -ItemType Directory -Path $parentfolder | Out-Null
		}
		if (-not (Test-Path $destination))
		{
			try
			{
				Copy-Item $source -Destination $destination -ErrorAction Stop
				Write-Host "Copy from $source to $destination done!"
			}
			catch
			{
				Write-Host "Copy from $source to $destination failed!"
			}
			
		}
	}
}
'@
						$BuildingBlocksFilesAndFoldersUninstall = @'
$sort = "!!sort!!"
$destination = "!!destination!!"
#Replace when needed
$destination = $destination -replace("%USERPROFILE%", $env:USERPROFILE)
$destination = $destination -replace("%APPDATA%", $env:APPDATA)
$destination = $destination -replace("%LOCALAPPDATA%", $env:LOCALAPPDATA)
Set-Location $PSScriptRoot
if ($sort -like 'folder') {
remove-item $destination -recurse -confirm:$false -force
}
if ($sort -like 'file') {
remove-item $destination -confirm:$false -force
}
write-host "Uninstall file or folder action done!"
'@
						
						if ($r["Context"] -like 'system')
						{
							$bbSystemContext = $true
							$buildingblocks_output_textbox5.AppendText('File or folder actions in the system context will now be added.')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\data"
							$BuildingBlocksISLocation = $BuildingBlocksISLocation -replace ("\\", "\")
							
							if (!(test-Path $BuildingBlocksISLocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksISLocation
							}
							$sourceIs = $($r["Source"])
							$sourceIs = $sourceIs -replace ("\\", "\")
							$sort = $r["Sort"]
							$source = $r["Source"]
							if ($sort -like 'file')
							{
								$newsourcevar = $source.Split('\')[-1]
								$newsourcevar = "Data\$newsourcevar"
							}
							if ($sort -like 'folder')
							{
								$newsourcevar = "Data\*"
								
							}
							$buildingblocks_output_textbox5.AppendText("Data is being copied to the Building Blocks location.`r`n")
							if ($sort -like 'file')
							{
								$sourcefilename = $sourceIs.Split('\')[-1]
								$dest = $BuildingBlocksISLocation + "\$sourcefilename"
								Copy-Item $sourceIs -Destination $dest
							}
							if ($sort -like 'folder')
							{
								Write-Host "Copy $sourceIs to $BuildingBlocksISLocation"
								Copy-Item "$sourceIs\*" -Destination "$BuildingBlocksISLocation" -Recurse -Container
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!source!!", $newsourcevar)
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!skip!!", $r["Skip"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!overwrite!!", $r["Overwrite"])
							$instfile = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\i.ps1"
							
							$BuildingBlocksFilesAndFolders | Out-File $instfile -force
							if ($r["Uninstall"] -like $true)
							{
								$uninstfile = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\u.ps1"
								$BuildingBlocksFilesAndFoldersUninstall | Out-File $uninstfile -force
							}
							
							$is = $is + 1
						}
						if ($r["Context"] -like 'user')
						{
							$bbUserContext = $true;
							$buildingblocks_output_textbox5.AppendText('File or folder actions in the user context will now be added.')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							$BuildingBlocksIULocation = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\data"
							if (!(test-Path $BuildingBlocksIULocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksIULocation
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$sourceIu = $($r["Source"])
							$sort = $r["Sort"]
							$source = $r["Source"]
							if ($sort -like 'file')
							{
								$newsourcevar = $source.Split('\')[-1]
								$newsourcevar = "Data\$newsourcevar"
							}
							if ($sort -like 'folder')
							{
								$newsourcevar = "Data\*"
								
							}
							$buildingblocks_output_textbox5.AppendText("Data is being copied to the Building Blocks location.`r`n")
							
							if ($sort -like 'file')
							{
								$sourcefilename = $sourceIu.Split('\')[-1]
								$dest = $BuildingBlocksIULocation + "\$sourcefilename"
								Copy-Item $sourceIu -Destination $dest
							}
							if ($sort -like 'folder')
							{
								Copy-Item "$sourceIU\*" -Destination $BuildingBlocksIULocation -Recurse
								
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!source!!", $newsourcevar)
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!skip!!", $r["Skip"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!overwrite!!", $r["Overwrite"])
							$instfile = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\i.ps1"
							$BuildingBlocksFilesAndFolders | Out-File $instfile -force
							if ($r["Uninstall"] -like $true)
							{
								$uninstfile = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\u.ps1"
								$BuildingBlocksFilesAndFoldersUninstall | Out-File $uninstfile -force
							}
							
							
							$iu = $iu + 1
						}
						
					}
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No file or folder activity detected.")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				if ($BuildingBlocksTable3 -notlike $null)
				{
					foreach ($r3 in $BuildingBlocksTable3)
					{
						
						$BuildingBlockRegistryScript = @'
Set-Location $PSScriptRoot
$regfilename = "!!regfilename!!"
if (Test-Path $regfilename) {
    $output = reg import $regfilename /reg:64 2>&1
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Registry Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Registry Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
'@
						$is = 1;
						$iu = 1;
						if ($r3["Context"] -like 'system')
						{
							$bbSystemContext = $true
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\Registry$is"
							$sourceReg = $($r3["Source"])
							if (!(test-Path $BuildingBlocksISLocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksISLocation
							}
							$buildingblocks_output_textbox5.AppendText('Registry file is now being copied to Building Block Location')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							try
							{
								Copy-Item $sourceReg -Destination "$BuildingBlocksISLocation\hklm.reg" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks done!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks failed!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$BuildingBlockRegistryScript = $BuildingBlockRegistryScript -replace ("!!regfilename!!", 'hklm.reg')
							try
							{
								$BuildingBlockRegistryScript | Out-File "$BuildingBlocksISLocation\i.ps1" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("i.ps1 created!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("failed to create i.ps1")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							
							$is = $is + 1
						}
						if ($r3["Context"] -like 'user')
						{
							$bbUserContext = $true
							$BuildingBlocksIULocation = $BuildingBlocksUserLocation + "\Registry$iu"
							$sourceReg = $($r3["Source"])
							if (!(test-Path $BuildingBlocksIULocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksIULocation
							}
							try
							{
								Copy-Item $sourceReg -Destination "$BuildingBlocksIULocation\hkcu.reg" -force
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks done!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks failed!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$BuildingBlockRegistryScript = $BuildingBlockRegistryScript -replace ("!!regfilename!!", 'hkcu.reg')
							try
							{
								$BuildingBlockRegistryScript | Out-File "$BuildingBlocksIULocation\i.ps1" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("i.ps1 created!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("failed to create i.ps1")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$iu = $iu + 1
						}
						
						
						
						
					}
					$buildingblocks_output_textbox5.AppendText("Registry done")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No Registry actions found")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				if ($BuildingBlocksTable2 -ne $Null)
				{
					$i = 1;
					foreach ($r2 in $BuildingBlocksTable2)
					{
						$BuildingBlockShortcutScript = @'	
$Context = "!!context!!"
$Name = "!!name!!"
$TargetLocation = "!!targetlocation!!"
$Arguments = "!!arguments!!"
$ICOFile = "!!icofile!!" ; $ICOFile = $ICOFile + ".ico"
$Subfolder = "!!subfolder!!"
$Desktop = "!!desktop!!"
$StartMenu = "!!startmenu!!"

Set-Location $PSScriptRoot
if ($Context -like 'user') {
    $folderPath = Join-Path $env:AppData "IntunePrepTool\ICONS"
    if (-not (Test-Path $folderPath)) {
        New-Item -ItemType Directory -Path $folderPath -Force | Out-Null
    }
    $destinationFile = Join-Path $folderPath (Split-Path $ICOFile -Leaf)
    Copy-Item -Path $ICOFile -Destination $destinationFile -Force
}
elseif ($Context -like 'system') {
    $folderPath = Join-Path $env:ProgramData "IntunePrepTool\ICONS"
    if (-not (Test-Path $folderPath)) {
        New-Item -ItemType Directory -Path $folderPath -Force | Out-Null
    }
    $destinationFile = Join-Path $folderPath (Split-Path $ICOFile -Leaf)
    Copy-Item -Path $ICOFile -Destination $destinationFile -Force
}


function fCreateShortcut
{
    <#
    .SYNOPSIS
    Creates a shortcut in the Desktop and/or Start Menu, for user or system context.

    .PARAMETER TargetFile
    The path to the executable or file the shortcut should point to.

    .PARAMETER ShortcutName
    The name of the shortcut (without .lnk extension).

    .PARAMETER Icon
    (Optional) Path to the icon file.

    .PARAMETER ShortcutArguments
    (Optional) Arguments to pass to the target.

    .PARAMETER Location
    One or more of 'Desktop' and/or 'StartMenu'.

    .PARAMETER Scope
    'User' or 'System' (default is 'User').

    .PARAMETER Subfolder
    (Optional) Subfolder within the Desktop or Start Menu path.
    #>
	
	param (
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[Parameter(Mandatory = $true)]
		[string]$ShortcutName,
		[string]$Icon = "",
		[string]$ShortcutArguments = "",
		[Parameter(Mandatory = $true)]
		[ValidateSet("Desktop", "StartMenu")]
		[string[]]$Location,
		[ValidateSet("User", "System")]
		[string]$Scope = "User",
		[string]$Subfolder = ""
	)
	
	$WorkingDir = Split-Path -Path $TargetFile -Parent
	
	foreach ($loc in $Location)
	{
		switch ($Scope)
		{
			'User' {
				$BasePath = switch ($loc)
				{
					'Desktop'   { [Environment]::GetFolderPath("Desktop") }
					'StartMenu' { [Environment]::GetFolderPath("StartMenu") }
				}
			}
			'System' {
				$BasePath = switch ($loc)
				{
					'Desktop'   { "$env:PUBLIC\Desktop" }
					'StartMenu' { "$env:ProgramData\Microsoft\Windows\Start Menu\Programs" }
				}
			}
		}
		
		$FullPath = if ($Subfolder)
		{
			Join-Path -Path $BasePath -ChildPath $Subfolder
		}
		else
		{
			$BasePath
		}
		if (-not (Test-Path $FullPath))
		{
			New-Item -Path $FullPath -ItemType Directory -Force | Out-Null
		}
		$ShortcutPath = Join-Path -Path $FullPath -ChildPath "$ShortcutName.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutPath)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.WorkingDirectory = $WorkingDir
		if ($Icon)
		{
			$Shortcut.IconLocation = $Icon
		}
		if ($ShortcutArguments)
		{
			$Shortcut.Arguments = $ShortcutArguments
		}
		$Shortcut.Save()
	}
}

if ($Desktop -like 'true') {
    fCreateShortcut -TargetFile $TargetLocation `
                    -Scope $Context `
                    -ShortcutName $Name `
                    -Location Desktop `
                    -Icon $destinationFile `
                    -ShortcutArguments $Arguments `
                    -Subfolder $Subfolder
Write-Host "Shortcut created successfully in: Desktop"
}

if ($StartMenu -like 'true') {
    fCreateShortcut -TargetFile $TargetLocation `
                    -Scope $Context `
                    -ShortcutName $Name `
                    -Location StartMenu `
                    -Icon $destinationFile `
                    -ShortcutArguments $Arguments

}
Write-Host "Shortcut created successfully in: Startmenu"
'@
						$BuildingBlockUninstallShortcutScript = @'	
$Context = "!!context!!"
$Name = "!!name!!"
$TargetLocation = "!!targetlocation!!"
$Arguments = "!!arguments!!"
$ICOFile = "!!icofile!!" ; $ICOFile = $ICOFile + ".ico"
$Subfolder = "!!subfolder!!"
$Desktop = "!!desktop!!"
$StartMenu = "!!startmenu!!"

Set-Location $PSScriptRoot

$Locations = @()
if ($Desktop)   { $Locations += 'Desktop' }
if ($StartMenu) { $Locations += 'StartMenu' }

foreach ($loc in $Locations)
{
    switch ($Context) {
        'User' {
            $BasePath = switch ($loc) {
                'Desktop'   { [Environment]::GetFolderPath('Desktop') }
                'StartMenu' { [Environment]::GetFolderPath('StartMenu') }
            }
        }
        'System' {
            $BasePath = switch ($loc) {
                'Desktop'   { Join-Path $env:Public 'Desktop' }
                'StartMenu' { Join-Path $env:ProgramData 'Microsoft\Windows\Start Menu\Programs' }
            }
        }
    }
    $FullPath = if ($Subfolder) {
        Join-Path -Path $BasePath -ChildPath $Subfolder
    }
    else {
        $BasePath
    }
    $ShortcutPath = Join-Path -Path $FullPath -ChildPath ("$Name.lnk")
    if (Test-Path $ShortcutPath) {
        Remove-Item $ShortcutPath -Force
        Write-Host "Removed shortcut: $ShortcutPath"
    }
    if ((Test-Path $FullPath) -and !(Get-ChildItem -Path $FullPath -Force)) {
        Remove-Item $FullPath -Force
        Write-Host "Removed empty folder: $FullPath"
    }
}
if ($ICOFile)
{
    if ($Context -like 'user') {
        $iconFolderPath = Join-Path $env:AppData ".IntunePrepTool\ICONS"
    }
    elseif ($Context -like 'system') {
        $iconFolderPath = Join-Path $env:ProgramData ".IntunePrepTool\ICONS"
    }
    $destinationFile = Join-Path $iconFolderPath (Split-Path $ICOFile -Leaf)
    if (Test-Path $destinationFile) {
        Remove-Item $destinationFile -Force
        Write-Host "Removed icon: $destinationFile"
    }
}

Write-Host "`nUninstall script completed."
'@
						
						
						
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!context!!", $r2["Context"])
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!context!!", $r2["Context"])
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!name!!", $($r2["Name"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!name!!", $($r2["Name"]))
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!targetlocation!!", $($r2["Target location"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!targetlocation!!", $($r2["Target location"]))
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!arguments!!", $($r2["Arguments"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!arguments!!", $($r2["Arguments"]))
						
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!subfolder!!", $($r2["Subfolder"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!subfolder!!", $($r2["Subfolder"]))
						if ($r2["Desktop"] -like 'true')
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!desktop!!", $true)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!desktop!!", $true)
						}
						else
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!desktop!!", $false)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!desktop!!", $false)
						}
						if ($r2["Startmenu"] -like 'true')
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!startmenu!!", $true)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!startmenu!!", $true)
						}
						else
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!startmenu!!", $false)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!startmenu!!", $false)
						}
						if ($r2["Context"] -like 'system')
						{
							$bbSystemContext = $true;
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\BuildingBlocksData" + "\shortcut$i"
						}
						if ($r2["Context"] -like 'user')
						{
							$bbUserContext = $true;
							$BuildingBlocksISLocation = $BuildingBlocksUserLocation + "\shortcut$i"
						}
						
						
						if (!(test-Path $BuildingBlocksISLocation))
						{
							New-Item -ItemType Directory -Path $BuildingBlocksISLocation
						}
						$icoName = -join (
							(97 .. 122) |
							Get-Random -Count 6 |
							ForEach-Object { [char]$_ }
						)
						$icoName = 'shortcut-' + $icoName
						$buildingblocks_output_textbox5.AppendText("Shortcut actions found!")
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						Copy-Item $($r2["ICO File"]) "$BuildingBlocksISLocation\$icoName.ico" -Force
						$buildingblocks_output_textbox5.AppendText('The ICO file (shortcut) is now being copied to the Building Block location.')
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!icofile!!", $icoName)
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!icofile!!", $icoName)
						$buildingblocks_output_textbox5.AppendText('Scripts (shortcuts) are now being copied to the Building Block location.')
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						$BuildingBlockShortcutScript | Out-File "$BuildingBlocksISLocation\i.ps1" -Force
						$BuildingBlockUninstallShortcutScript | Out-File "$BuildingBlocksISLocation\u.ps1" -Force
						$buildingblocks_output_textbox5.AppendText("done!")
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						
						
						
						
						$i = $i + 1
					}
					
					
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No Shortcut actions found")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				
				
				$buildingblocks_output_textbox5.AppendText("Building Blocks created: $buildingBlockFolder")
				$buildingblocks_output_textbox5.AppendText("  `r`n")
				#$buildingBlocks_panel85.Enabled = $true;
				if ($bbUserContext -like $true)
				{
					$userContext_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!" ; $version = $version + "user"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextInstall_$appname$version.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 

	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\i.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
		
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1 }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
					$userContext_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!" ; $version = $version + "user"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextUninstall_$appname$version.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
	
	
}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1 }
else { remove-item $regkeyApp; exit 0 }
'@
					$buildingblocks_output_textbox5.AppendText("`Generating install and uninstall powershell scripts for the User Context Package...`r`n")
					$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
					$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
					$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
					$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
					$appname = $buildingblocks_Name_textbox4.text
					$appversion = $buildingblocks_version_textbox3.Text
					$RegisterDetectionroot = "Intune_" + $config_customername
					$userContext_installFile = $userContext_installFile.Replace('!!AppName!!', "$appname")
					$userContext_installFile = $userContext_installFile.Replace('!!logdir!!', $config_logfoldertarget)
					$userContext_installFile = $userContext_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
					$userContext_installFile = $userContext_installFile.Replace('!!version!!', $appversion)
					$userContext_installFile | Out-File "$config_buildingblockspath\$appname\User\install.ps1" -Force
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!AppName!!', "$appname")
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!version!!', $appversion)
					$userContext_uninstallFile | Out-File "$config_buildingblockspath\$appname\User\uninstall.ps1" -Force
					$buildingblocks_output_textbox5.AppendText("`install.ps1 and uninstall.ps1 created! `r`n")
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show(
						'The IntunePrepTool will not respond until packaging is complete. Large packages may take several minutes. Please wait.',
						'Creating User Context Package'
					) # Casting the method to [void] suppresses the output. 
					if (!(Test-Path "$config_buildingblockspath\$appname\output-UserContext\"))
					{
						mkdir "$config_buildingblockspath\$appname\output-UserContext\" -Force
					}
					
					
					& .\IntuneWinAppUtil.exe -c "$config_buildingblockspath\$appname\User\" -s "$config_buildingblockspath\$appname\User\install.ps1" -o "$config_buildingblockspath\$appname\output-UserContext\" -q
					Rename-Item -Path "$config_buildingblockspath\$appname\output-UserContext\install.intunewin" -NewName "$config_buildingblockspath\$appname\output-UserContext\$appname.intunewin"
					$buildingblocks_output_textbox5.AppendText("`nIntunewin file created: `r`n")
					$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-UserContext\$appname.intunewin")
					$buildingblocks_output_textbox5.AppendText("`r`n")
					
					$context = 'user'
					$icmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File install.ps1"
					$ucmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File uninstall.ps1"
					$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
					$regkeyApp = "$regkeyRoot$appname"
					$usercontextVersion = $appversion + "user"
					$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
							IntuneWinFile = "$appname.intunewin"
							DisplayName   = $appname
							Publisher	  = $config_customername
							AppVersion    = $usercontextVersion;
							reglocation   = $regkeyApp
							regValue	  = 'Version'
							installCMD    = $icmd
							uninstallCMD  = $ucmd
							context	      = $context
						})
					$IntuneWinPackageConfig | Export-Csv "$config_buildingblockspath\$appname\output-UserContext\config.csv" -NoTypeInformation
					$buildingblocks_output_textbox5.AppendText("`Config.csv created: `r`n")
					$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-UserContext\config.csv")
					$buildingblocks_output_textbox5.AppendText("`r`n")
					if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
					{
						if ($bbSystemContext -like $false)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $false
									usercontext				     = $true
									systemcontextconfig		     = $null;
									systembuildingblockslocation = $null;
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv";
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
							
						}
						
					}
					else
					{
						if ($bbSystemContext -like $false)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $false
									systemcontext			     = $false
									usercontext				     = $true
									systemcontextconfig		     = $null;
									systembuildingblockslocation = $null;
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv";
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Building Blocks - Standalone Package Info')
							
						}
					}
					
				}
				if ($bbSystemContext -like $true)
				{
					$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
					$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
					$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
					$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
					$appname = $buildingblocks_Name_textbox4.text
					$appversion = $buildingblocks_version_textbox3.Text
					
					if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
					{
						if ($bbUserContext -like $true)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $true
									usercontext				     = $true
									systemcontextconfig		     = $null
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv"
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
						}
						else
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $true
									usercontext				     = $false
									systemcontextconfig		     = $null;
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig		     = $null;
									userbuildingblockslocation   = $null;
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
						}
					}
					else
					{
						
						
						$systemContext_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksSystemContextInstall_$appname$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 

	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\i.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
		
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1 }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
						$systemContext_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextUninstall_$appname$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
	
	
}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1 }
else { remove-item $regkeyApp; exit 0 }
'@
						$buildingblocks_output_textbox5.AppendText("`Generating install and uninstall powershell scripts for the System Context Package...`r`n")
						$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
						$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
						$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
						$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
						$appname = $buildingblocks_Name_textbox4.text
						$appversion = $buildingblocks_version_textbox3.Text
						$RegisterDetectionroot = "Intune_" + $config_customername
						$systemContext_installFile = $systemContext_installFile.Replace('!!AppName!!', "$appname")
						$systemContext_installFile = $systemContext_installFile.Replace('!!logdir!!', $config_logfoldertarget)
						$systemContext_installFile = $systemContext_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
						$systemContext_installFile = $systemContext_installFile.Replace('!!version!!', $appversion)
						$systemContext_installFile | Out-File "$config_buildingblockspath\$appname\System\install.ps1" -Force
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!AppName!!', "$appname")
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!version!!', $appversion)
						$systemContext_uninstallFile | Out-File "$config_buildingblockspath\$appname\System\uninstall.ps1" -Force
						$buildingblocks_output_textbox5.AppendText("`install.ps1 and uninstall.ps1 created! `r`n")
						#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
						[void][System.Windows.Forms.MessageBox]::Show(
							'The IntunePrepTool will not respond until packaging is complete. Large packages may take several minutes. Please wait.',
							'Creating System Context Package'
						) # Casting the method to [void] suppresses the output. 
						if (!(Test-Path "$config_buildingblockspath\$appname\output-SystemContext\"))
						{
							mkdir "$config_buildingblockspath\$appname\output-SystemContext\" -Force
						}
						
						
						& .\IntuneWinAppUtil.exe -c "$config_buildingblockspath\$appname\System\" -s "$config_buildingblockspath\$appname\System\install.ps1" -o "$config_buildingblockspath\$appname\output-SystemContext\" -q
						Rename-Item -Path "$config_buildingblockspath\$appname\output-SystemContext\install.intunewin" -NewName "$config_buildingblockspath\$appname\output-SystemContext\$appname.intunewin"
						$buildingblocks_output_textbox5.AppendText("`nIntunewin file created: `r`n")
						$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-SystemContext\$appname.intunewin")
						$buildingblocks_output_textbox5.AppendText("`r`n")
						
						$context = 'system'
						$icmd = "powershell -executionpolicy bypass -file install.ps1"
						$ucmd = "powershell -executionpolicy bypass -file uninstall.ps1"
						$regkeyRoot = "HKEY_LOCAL_MACHINE\Software\$RegisterDetectionroot\"
						$regkeyApp = "$regkeyRoot$appname"
						$IntuneWinPackageConfig = $null;
						$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
								IntuneWinFile = "$appname.intunewin"
								DisplayName   = $appname
								Publisher	  = $config_customername
								AppVersion    = $appversion;
								reglocation   = $regkeyApp
								regValue	  = 'Version'
								installCMD    = $icmd
								uninstallCMD  = $ucmd
								context	      = $context
							})
						$IntuneWinPackageConfig | Export-Csv "$config_buildingblockspath\$appname\output-SystemContext\config.csv" -NoTypeInformation
						$buildingblocks_output_textbox5.AppendText("`Config.csv created: `r`n")
						$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-SystemContext\config.csv")
						$buildingblocks_output_textbox5.AppendText("`r`n")
						
						if ($bbUserContext -like $true)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress   = $false
									systemcontext	    = $true
									usercontext		    = $true
									systemcontextconfig = "$config_buildingblockspath\$appname\output-SystemContext\config.csv"
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig   = "$config_buildingblockspath\$appname\output-UserContext\config.csv"
									userbuildingblockslocation = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Building Blocks - Standalone Package Info')
						}
						else
						{
							
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress   = $false
									systemcontext	    = $true
									usercontext		    = $false
									systemcontextconfig = "$config_buildingblockspath\$appname\output-SystemContext\config.csv"
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig   = $null
									userbuildingblockslocation = $null;
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - Standalone Package Info')
							
						}
					}
				}
				
			}
		}
	}
	
	
}

$buildingblocks_Name_textbox4_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		
	}
}

$config_buildingBlocksBrowse_button1_Click={
	#TODO: Place custom script here
	if ($config_buildingBlcoks_folderbrowsermoderndialog3.ShowDialog() -eq 'OK')
	{
		$config_buildingblocks_textbox3.Text = $config_buildingBlcoks_folderbrowsermoderndialog3.SelectedPath
	}
}

$config_install_orca_buttonInstallOrcaPowershel_Click={
	#TODO: Place custom script here
$installOrca = @'



[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
$WinSDKSetup = "C:\windows\Temp\winsdksetup.exe"
try {
Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/?linkid=2313119" -OutFile $WinSDKSetup -ErrorAction Stop
Write-Host "Downloaded winsdksetup.exe to $WinSDKSetup"
}
catch {
Write-Error "Failed downloading winsdksetup.exe"
}

$exeParameters = '/layout "C:\Program Files\IntunePrepTool" /q /features OptionId.MSIInstallTools /quiet /norestart'

try
{
	Start-Process -FilePath $WinSDKSetup -ArgumentList $exeParameters -Wait -NoNewWindow -ErrorAction Stop
	write-host "Installation completed of $WinSDKSetup" -ForegroundColor Green
	
	
}
catch
{
	write-host "Error executing "C:\windows\Temp\winsdksetup.exe"" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	
	
}

try
{
	$startPMSI = Start-Process msiexec.exe `
    -ArgumentList '/i', '"C:\Program Files\IntunePrepTool\Installers\Orca-x86_en-us.msi"', '/qn', '/l*v', '"C:\Windows\Temp\OrcaMSI.txt"' `
    -Wait `
    -NoNewWindow `
    -ErrorAction Stop

	write-host $startPMSI
	$msilog = get-content 'c:\windows\temp\OrcaMSI.txt'
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Install done!" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green

	}
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content 'c:\windows\temp\OrcaMSI.txt'
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
}
write-host "Cleaning temp install files now" -ForegroundColor Green
Remove-Item $WinSDKSetup -Confirm:$false
Remove-Item -Path "C:\Program Files\IntunePrepTool\Installers" -Recurse -Force -Confirm:$false
Remove-Item  "C:\Windows\Temp\OrcaMSI.txt" -Confirm:$false

'@

	
	if (!(Test-Path "c:\program files\IntunePrepTool\installOrca.ps1" -PathType Leaf))
	{
		$installOrca  | Out-File "c:\program files\IntunePrepTool\installOrca.ps1"
	}
	else
	{
		Remove-Item -Path "c:\program files\IntunePrepTool\installOrca.ps1" -Confirm:$false -Force
		$installOrca | Out-File "c:\program files\IntunePrepTool\installOrca.ps1"
	}
	
	powershell_ise -file "c:\program files\IntunePrepTool\installOrca.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$msi_open_Orca_button1_Click={
	#TODO: Place custom script here
	if (Test-Path "C:\Program Files (x86)\Orca\Orca.exe" -Type Leaf)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		$MSINewname = $msi_openfiledialog1.FileName
		$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
		$MSINewname = $MSINewname.Replace(" ", "")
		$MSIbestand = "$config_packagefolder\$msipnaam\$msiversie\source\$MSINewname"
		Start-Process "C:\Program Files (x86)\Orca\Orca.exe" -ArgumentList $MSIbestand
	}
	else
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Use the Install Orca (PowerShell_ISE) button in the Start/Config menu.", 'Please install Orca first') # Casting the method to [void] suppresses the output.
		
	}
	
}

$msi_gotobuildingblocks_button2TestInstallPowershe_Click={
	#TODO: Place custom script here
	
}

$msi_buttonOptionalGoToBuilding_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'msi'| Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'msi' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $msi_packagenaam_textbox1.text
	$buildingblocks_version_textbox3.text = $msi_versie_textbox1.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
	
	
}

$msi_addBuildingBlocksSystemContextbutton5CreateIntunewinFile_Click= {
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $msi_packagenaam_textbox1.text
			$PacVersion = $msi_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$MSI_buildigblocks_Package_InProgresstextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			$MSI_buildigblocks_Package_InProgresstextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
		}
	}
}

$bb_gobackToPackageInProgress_button1_Click={
	#TODO: Place custom script here
	if (!(Test-Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Type Leaf))
	{
		
	}
	else
	{
		$BBWheretoGoBack = get-content 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt'
		if ($BBWheretoGoBack -like 'msi')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $true
			$package_msi_tabcontrol2.Visible = $true
			$package_msi_tabcontrol2.Dock = 'Fill'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'exe')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $true
			$package_exe_tabcontrol2.Visible = $true
			$package_exe_tabcontrol2.Dock = 'Fill'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'msix')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'Fill'
			$MSIX_tabcontrol1.Enabled = $true
			$MSIX_tabcontrol1.Visible = $true
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'choco')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $true
			$tools_chocolatey_tabcontrol1.Visible = $true
			$tools_chocolatey_tabcontrol1.Dock = 'Fill'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'winget')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $true
			$package_winget_tabcontrol2.Visible = $true
			$package_winget_tabcontrol2.Dock = 'Fill'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
	}
	
}

$bb_standalone_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($bb_standalone_radiobutton1.Enabled -eq $true)
	{
		#$bb_usePackageInProgress_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $true
		$buildingblocks_version_textbox3.Enabled = $true
	}
	if ($bb_standalone_radiobutton1.Enabled -eq $false)
	{
		#$bb_usePackageInProgress_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $false
		$buildingblocks_version_textbox3.Enabled = $false
		
	}
	
}

$bb_usePackageInProgress_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($bb_usePackageInProgress_radiobutton1.Enabled -eq $true)
	{
		#$bb_standalone_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $false
		$buildingblocks_version_textbox3.Enabled = $false
		
		
	}
	if ($bb_usePackageInProgress_radiobutton1.Enabled -eq $false)
	{
		#$bb_standalone_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $true
		$buildingblocks_version_textbox3.Enabled = $true
	}
	if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
	{
		if (($buildingblocks_Name_textbox4.Text -like $Null) -or ($buildingblocks_version_textbox3.Text -like $Null))
		{
			[void][System.Windows.Forms.MessageBox]::Show(
				"Please go to your MSI, MSIX, EXE, Chocolatey or Winget package. After testing install, then use the '(Optional) Go to Building Blocks' button",
				"Button '(Optional) Go to Building Blocks' not used!"
			)
		}
	}
	
	
}

$buildingblocks_add_script_buttonAddShotcut_Click={
	#TODO: Place custom script here
	
}

$exe_open_withqquestion_button1_Click={
	#TODO: Place custom script here
	[void][System.Windows.Forms.MessageBox]::Show(
		"If the EXE file supports this, a popup will open with all the install parameters. If the EXE file does not support it, it might launch the setup. In that case, please close it before continuing.",
		'Testing opening EXE file with /?'
	)
	[string]$exe_org_path = $exe_openfiledialog1.FileNames
	Unblock-File -Path $exe_org_path -Confirm:$false
	Start-Process $exe_org_path -ArgumentList '/?' -WindowStyle Normal
	
}

$exe_test_done_button1CreateInstallScript_Click={
	#TODO: Place custom script here
	$exe_preBackupPath64 = Get-Variable -Name exe_preBackupPath64 -ValueOnly -Scope Script
	$exe_preBackupPath32 = Get-Variable -Name exe_preBackupPath32 -ValueOnly -Scope Script
	$backupFolder = "$env:LOCALAPPDATA\temp"
	$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$PostBackupPath64 = Join-Path $backupFolder "PostChanges64_$timeStamp.reg"
	$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$PostBackupPath32 = Join-Path $backupFolder "PostChanges32_$timeStamp.reg"
	$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	reg export "$regExportPath" "$PostBackupPath32" /y | Out-Null
	$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	reg export "$regExportPath" "$PostBackupPath64" /y | Out-Null
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$regDiffFile64 = Join-Path $backupFolder "Difffile64_$timeStamp.reg"
	$regDiffFile32 = Join-Path $backupFolder "Difffile32_$timeStamp.reg"
	function Compare-RegFiles
	{
		param (
			[string]$OldRegPath,
			[string]$NewRegPath,
			[string]$DiffOutPath
		)
		
		$oldLines = [System.IO.File]::ReadAllLines($OldRegPath)
		$newLines = [System.IO.File]::ReadAllLines($NewRegPath)
		$oldHashSet = [System.Collections.Generic.HashSet[string]]::new($oldLines)
		$differences = New-Object System.Collections.Specialized.OrderedDictionary
		$currentKey = $null
		foreach ($line in $newLines)
		{
			if ($line -match '^\[\S+\]$')
			{
				$currentKey = $line
				continue
			}
			if ($line -match '^\S+=' -and $currentKey)
			{
				if (-not $oldHashSet.Contains($line))
				{
					if (-not $differences.Contains($currentKey))
					{
						$differences[$currentKey] = [System.Collections.Generic.List[string]]::new()
					}
					$differences[$currentKey].Add($line)
				}
			}
		}
		if ($differences.Count -gt 0)
		{
			Set-Content -Path $DiffOutPath -Value "Windows Registry Editor Version 5.00`r`n"
			foreach ($key in $differences.Keys)
			{
				Add-Content -Path $DiffOutPath -Value "`r`n$key"
				foreach ($val in $differences[$key])
				{
					Add-Content -Path $DiffOutPath -Value $val
				}
			}
			$DiffOutPath | out-file "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt" -force
		}
		else
		{
			if (Test-Path $DiffOutPath)
			{
				Remove-Item $DiffOutPath -ErrorAction SilentlyContinue
			}
		}
	}
	
	Compare-RegFiles -OldRegPath $exe_preBackupPath64 `
					 -NewRegPath $PostBackupPath64 `
					 -DiffOutPath $regDiffFile64
	
	Compare-RegFiles -OldRegPath $exe_preBackupPath32 `
					 -NewRegPath $PostBackupPath32 `
					 -DiffOutPath $regDiffFile32
	Remove-Item $PostBackupPath64 -Confirm:$false
	Remove-Item $exe_preBackupPath64 -Confirm:$false
	Remove-Item $PostBackupPath32 -Confirm:$false
	Remove-Item $exe_preBackupPath32 -Confirm:$false
	
	foreach ($file in @($regDiffFile64, $regDiffFile32))
	{
		if (Test-Path $file -PathType Leaf)
		{
			$regString = Get-Content $file
			$regInfo = @{ }
			
			foreach ($line in $regString)
			{
				if ($line -match '^\s*\"(?<key>.+?)\"=\"(?<value>.*)\"')
				{
					$regInfo[$matches['key']] = $matches['value']
				}
				elseif ($line -match '^\s*\"(?<key>.+?)\"=dword:(?<value>.+)')
				{
					$regInfo[$matches['key']] = [Convert]::ToInt32($matches['value'], 16)
				}
				elseif ($line -match '^\s*\"(?<key>.+?)\"=(?<value>.+)')
				{
					$regInfo[$matches['key']] = $matches['value'].Trim().Trim('"')
				}
			}
			
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("DisplayName: " + $regInfo["DisplayName"] + "`r`n")
			$exe_output_textbox1.AppendText("DisplayVersion: " + $regInfo["DisplayVersion"] + "`r`n")
			$exe_output_textbox1.AppendText("InstallDate: " + $regInfo["InstallDate"] + "`r`n")
			$exe_output_textbox1.AppendText("UninstallString: " + $regInfo["UninstallString"] + "`r`n")
			$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
			$wattezoeken = $regInfo["DisplayName"]
			$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
			if ($InstallsUninstallString -notlike $null)
			{
				
				foreach ($ius in $InstallsUninstallString)
				{
					$exe_output_textbox1.AppendText("Another possible uninstall string: " + $ius.UninstallString + "`r`n")
					$uninststr = $ius.UninstallString
					if ($uninststr -like '*.exe*') { $exe_uninstall_exe_path_textbox2.Text = $uninststr; $exe_radiobuttonUninstallEXEPath.Checked = $true; $exe_parsUnInstall_textbox1.Text = $exe_parsInstall_textbox1.Text }
					if ($uninststr -like '*{*')
					{
						$newuni = $uninststr.Split("{")[1]
						$newuni = $newuni.Split("}")[0]
						$exe_radiobutton3.Checked = $true
						$MSIXECUninstall = $exe_msiexecuninstall.Text
						$MSIXECUninstall = $MSIXECUninstall -replace ("PlaceProductIDhere", $newuni)
						$exe_msiexecuninstall.Text = $MSIXECUninstall;
					}
				}
			}
			$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
			$wattezoeken = $regInfo["DisplayName"]
			$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
			if ($InstallsUninstallString -notlike $null)
			{
				
				foreach ($ius in $InstallsUninstallString)
				{
					$exe_output_textbox1.AppendText("Another possible uninstall string: " + $ius.UninstallString + "`r`n")
					$uninststr = $ius.UninstallString
					if ($uninststr -like '*.exe*') { $exe_uninstall_exe_path_textbox2.Text = $uninststr; $exe_radiobuttonUninstallEXEPath.Checked = $true; $exe_parsUnInstall_textbox1.Text = $exe_parsInstall_textbox1.Text  }
					if ($uninststr -like '*{*')
					{
						$newuni = $uninststr.Split("{")[1]
						$newuni = $newuni.Split("}")[0]
						$exe_radiobutton3.Checked = $true
						$MSIXECUninstall = $exe_msiexecuninstall.Text
						$MSIXECUninstall = $MSIXECUninstall -replace("PlaceProductIDhere", $newuni)
						$exe_msiexecuninstall.Text = $MSIXECUninstall;
						 }
				}
			}
			
		}
	}
	
	
}

$tablelayoutpanel3_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_buttonOpenReleaseNotesOnIn_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/updates/intunepreptool-1-7-0-0/'
}


$exe_gotobuildingblocksButton_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'exe' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'exe' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $exe_packagenaam_textbox1.text
	$buildingblocks_version_textbox3.text = $exe_versie_textbox1.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$tools_choco_gotoBuildingBlocks_Button_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'choco' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'choco' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $tools_choco_displayname_textbox3.text
	$buildingblocks_version_textbox3.text = $tools_choco_appversion_textbox3.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$msix_GotoBuildingBlocks_Button_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'msix' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'msix' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $msix_packagename_textbox3.text
	$buildingblocks_version_textbox3.text = $msix_packageVersion_textbox3.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$winget_gotobuildingBlocks_buttonTestInstallPowershel_Click={
	#TODO: Place custom script here
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'winget' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'winget' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $winget_displayname_textbox1.text
	$buildingblocks_version_textbox3.text = $versie_textbox2.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$exe_addBuildingBlocksCSVButton_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $exe_packagenaam_textbox1.text
			$PacVersion = $exe_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$exe_buildingblockscsv_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
			$exe_buildingblockscsv_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$msix_addBuildingBlokcsCSV_buttonOptionalAddBuildingB_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $msix_packageVersion_textbox3.text
			$PacVersion = $msi_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$msix_buildingblocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
			$msix_buildingblocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$tools_choco_addBuildingBlocksCSVButton_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $tools_choco_displayname_textbox3.text
			$PacVersion = $tools_choco_appversion_textbox3.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$choco_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
			$choco_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$winget_addBuildingBlocksCSVbuttonOptionalAddBuildingB_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $winget_displayname_textbox1.text
			$PacVersion = $versie_textbox2.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$winget_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
			$winget_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$upload_LoadBuildingBlocksg_button1_Click={
	#TODO: Place custom script here
	$upload2_IntuneWinFile_textbox1.Text = $null;
	$upload2_DisplayName_textbox2.Text = $null;
	$upload2_Publisher_textbox1.Text = $null;
	$upload2_AppVersion_textbox1.Text = $null;
	$upload2_reglocation_textbox2.Text = $null;
	$upload2_regValue_textbox1.Text = $null;
	$upload2_installCMD_textbox1.Text = $null;
	$upload2_uninstallCMD_textbox1.Text = $null;
	$upload2_context_textbox1.Text = $null;
	
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		$upload_configLoaded_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		$upload_checkboxSetupAssignmentLikeP.Enabled = $false
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		$systemcsvLOC = $BuildingBlocksCSVContent.systemcontextconfig
		$usercsvLOC = $BuildingBlocksCSVContent.usercontextconfig
		if (($BuildingBlocksCSVContent.usercontext -like $true) -and ($BuildingBlocksCSVContent.systemcontext -like $true))
		{
			$upload_panel2.Enabled = $true
			$upload_panel2.Visible = $true
			$ConfigCSVImport = $null
			$ConfigCSVImport = Import-Csv $systemcsvLOC
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $systemcsvLOC.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload_context_textbox1.Text = $context
			$ConfigCSVImport = $null
			$ConfigCSVImport = Import-Csv $usercsvLOC
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $usercsvLOC.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload2_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload2_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload2_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload2_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload2_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload2_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload2_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload2_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload2_context_textbox1.Text = $context
	
			if (!(test-path "$filepath\Logo.png" -PathType Leaf))
			{
				[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
				$upload_logo_button2.Enabled = $true
				$upload_logo_button2.Visible = $true
				
			}
			
		}
		else
		{
			
			if ($systemcsvLOC -like $null)
			{
				$ConfigCSVImport = $null
				$ConfigCSVImport = Import-Csv $usercsvLOC
				$itwnf = $ConfigCSVImport.IntuneWinFile
				$filepath = $usercsvLOC.TrimEnd("config.csv")
				$itwnffilepath = $filepath + $itwnf
				$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
				
				$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
				$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
				$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
				$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
				$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
				$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
				$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
				if ($ConfigCSVImport.context)
				{
					$context = $ConfigCSVImport.context
				}
				else
				{
					$context = 'system'
				}
				$upload_context_textbox1.Text = $context
				
				if (!(test-path "$filepath\Logo.png" -PathType Leaf))
				{
					[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
					$upload_logo_button2.Enabled = $true
					$upload_logo_button2.Visible = $true
					
				}
			}
			else
			{
				$ConfigCSVImport = $null
				$ConfigCSVImport = Import-Csv $systemcsvLOC
				$itwnf = $ConfigCSVImport.IntuneWinFile
				$filepath = $systemcsvLOC.TrimEnd("config.csv")
				$itwnffilepath = $filepath + $itwnf
				$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
				
				$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
				$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
				$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
				$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
				$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
				$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
				$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
				if ($ConfigCSVImport.context)
				{
					$context = $ConfigCSVImport.context
				}
				else
				{
					$context = 'system'
				}
				$upload_context_textbox1.Text = $context
				
				if (!(test-path "$filepath\Logo.png" -PathType Leaf))
				{
					[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
					$upload_logo_button2.Enabled = $true
					$upload_logo_button2.Visible = $true
					
				}
			}
		
		}
		
		
	}
	
	
	
}

$config_howtoBasicSetup_buttonOpenHowToBasicSetupO_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/basic-setup/'
}

$BB_OpenHowTo_button_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/building-blocks/'
}

$tools_choco_label5_Click={
	#TODO: Place custom script here
	
}

$buttonRefreshTenants_Click={
	#TODO: Place custom script here
	refreshTenants
	refreshTenantsUpload
}


$msi_addDescription_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $msi_packagenaam_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $msi_packagenaam_textbox1.text  -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $msi_versie_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $msi_versie_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$exe_buttonAddCustomPackageDesc_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $exe_packagenaam_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $exe_packagenaam_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $exe_versie_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $exe_versie_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$winget_buttonAddCustomDescription_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $winget_displayname_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $winget_displayname_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $versie_textbox2.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $versie_textbox2.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$msix_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $msix_packagename_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $msix_packagename_textbox3.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $msix_packageVersion_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $msix_packageVersion_textbox3.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$powershell_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $powershell_packagename_textbox.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $powershell_packagename_textbox.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $powershell_packageversion_textbox.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $powershell_packageversion_textbox.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$scheduledtask_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $powershell_package_name_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $powershell_package_name_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $powershell_package_version_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $powershell_package_version_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$tools_choco_buttonOpenPackageDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $tools_choco_displayname_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $tools_choco_displayname_textbox3.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $tools_choco_appversion_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $tools_choco_appversion_textbox3.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$config_tenant_customprivacy_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_tenant_checkboxYes_CheckedChanged={
	#TODO: Place custom script here
	if ($config_tenant_checkboxYes.Checked -eq $true)
	{
		$config_tenant_customprivacy_textbox3.Enabled = $true
	}
	if ($config_tenant_checkboxYes.Checked -eq $false) {
		$config_tenant_customprivacy_textbox3.Text = $null
		$config_tenant_customprivacy_textbox3.Enabled = $false
	}
}

$config_tenant_info_secret_label_Click={
	#TODO: Place custom script here
	
}

$msi_howtoPackageMSI_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/package-msi-example-foxit-reader-language-mst/'
}

$msi_verbose_radiobutton1_CheckedChanged={
	$msiTempinstallPar = $msi_install_par_textbox3.Text
	$msiTempUninstallPar = $msi_uninstall_par_textbox1.text
	if ($msi_radiobuttonStatusMessages.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*v', '/l*i')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*v', '/l*i')
	}
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*i', '/l*v')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*i', '/l*v')
		
	}
	$msi_install_par_textbox3.Text = $msiTempinstallPar
	$msi_uninstall_par_textbox1.text = $msiTempUninstallPar
}

$msi_radiobuttonStatusMessages_CheckedChanged={
	$msiTempinstallPar = $msi_install_par_textbox3.Text
	$msiTempUninstallPar = $msi_uninstall_par_textbox1.text
	if ($msi_radiobuttonStatusMessages.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*v', '/l*i')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*v', '/l*i')
	}
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*i', '/l*v')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*i', '/l*v')
		
	}
	$msi_install_par_textbox3.Text = $msiTempinstallPar
	$msi_uninstall_par_textbox1.text = $msiTempUninstallPar
}

$UploadLogo_openfiledialog1_FileOk=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$config_install_libwebp_Click={
	#TODO: Place custom script here
	$installlibwebp = @'

$Url = 'https://storage.googleapis.com/downloads.webmproject.org/releases/webp/libwebp-1.6.0-windows-x64.zip'
[string]$DownloadDir = "c:\windows\temp"
[switch]$Extract = $true
[switch]$Overwrite = $true

# Ensure TLS 1.2
try { [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 } catch {}

# If writing under Program Files, require elevation
if ($DownloadDir -match '^[A-Za-z]:\\Program Files' -and
   -not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()
         ).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    throw "Writing to '$DownloadDir' requires elevated PowerShell. Run as Administrator or choose a user-writable folder."
}

# Create target dir
if (!(Test-Path -LiteralPath $DownloadDir)) {
  New-Item -ItemType Directory -Path $DownloadDir -Force | Out-Null
}

$uri = [Uri]$Url
$fileName = [IO.Path]::GetFileName($uri.AbsolutePath)
$outFile = Join-Path $DownloadDir $fileName

# FIX: wrap Test-Path before using -and
if ((Test-Path -LiteralPath $outFile -PathType Leaf) -and (-not $Overwrite)) {
  Write-Host "Already exists: $outFile  (use -Overwrite to redownload)"
} else {
  try {
    $iwrParams = @{ Uri = $Url; OutFile = $outFile; TimeoutSec = 600; ErrorAction = 'Stop' }
    if ($PSVersionTable.PSVersion.Major -lt 6) { $iwrParams['UseBasicParsing'] = $true }
    Invoke-WebRequest @iwrParams
    Write-Host "Downloaded to: $outFile"
  } catch {
    Write-Warning "Invoke-WebRequest failed: $($_.Exception.Message)"
    Write-Host "Falling back to BITS transfer…"
    Start-BitsTransfer -Source $Url -Destination $outFile -DisplayName 'libwebp zip' -ErrorAction Stop
    Write-Host "Downloaded to: $outFile (via BITS)"
  }

  # Sanity check
  $fi = Get-Item -LiteralPath $outFile -ErrorAction SilentlyContinue
  if (-not $fi -or $fi.Length -lt 1024) {
    throw "Download looks incorrect or incomplete: $outFile"
  }
}

if ($Extract) {
  $extractDir = Join-Path $DownloadDir ([IO.Path]::GetFileNameWithoutExtension($fileName))
  if (Test-Path -LiteralPath $extractDir) {
    if ($Overwrite) { Remove-Item -LiteralPath $extractDir -Recurse -Force }
    else { throw "Extract folder already exists: $extractDir (use -Overwrite)" }
  }
  # Make extraction fail fast if the ZIP isn't there/valid
  Expand-Archive -LiteralPath $outFile -DestinationPath $extractDir -Force -ErrorAction Stop
  Write-Host "Extracted to: $extractDir"
  copy-item "C:\Windows\Temp\libwebp-1.6.0-windows-x64\libwebp-1.6.0-windows-x64\bin\dwebp.exe" 'C:\Program Files\IntunePrepTool\dwebp.exe' -Force
  Write-Host "dwebp.exe copied to C:\Program Files\IntunePrepTool"
  remove-item "C:\Windows\Temp\libwebp-1.6.0-windows-x64.zip" -Confirm:$false
  remove-item 'C:\Windows\Temp\libwebp-1.6.0-windows-x64' -Recurse -Confirm:$false
  Write-Host "Removed Temp files; All Done now!"
}


'@
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\installlibwebp.ps1" -PathType Leaf))
	{
		$installlibwebp | Out-File "c:\program files\IntunePrepTool\installlibwebp.ps1"
	}
	else
	{
		Remove-Item -Path "c:\program files\IntunePrepTool\installlibwebp.ps1" -Confirm:$false -Force
		$installlibwebp | Out-File "c:\program files\IntunePrepTool\installlibwebp.ps1"
	}
	
	powershell_ise -file "c:\program files\IntunePrepTool\installlibwebp.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$menustrip1_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$MSIX_tabpage4_Click={
	#TODO: Place custom script here
	
}
]]></Code>
  <TV>0</TV>
  <Bookmarks />
  <BreakPoints>
    <Line Disabled="False">1689</Line>
    <Line Disabled="False">13261</Line>
  </BreakPoints>
  <TracePoints />
  <Mode>0</Mode>
  <Assemblies />
</File>