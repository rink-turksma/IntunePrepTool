<File version="3.2">
  <FileID>373d466f-0843-40eb-9006-241e20fcf1fd</FileID>
  <LastExport>133227411031353429</LastExport>
  <Preview>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
khJmAEiSlDADQJKkhBkAkiQlzACQJClhBoAkSQkzACRJSpgBIElSwgwASZISZgBIkpQwA0CSpIQZ
AJIkJcwAkCQpYQaAJEkJMwAkSUqYASBJUsIMAEmSEmYASJKUMANAkqSEGQCSJCXMAJAkKWEGgCRJ
CTMAJElKmAEgSVLCDABJkhJmAEiSlDADQJKkhBkAkiQlzACQJClhBoAkSQkzACRJSpgBIElSwgwA
SZISZgBIkpQwA0CSpIQZAJIkJcwAkCQpYQaAJEkJMwAkSUqYASBJUsIMAEmSEmYASJKUMANAkqSE
GQCSJCXMAJAkKWEGgCRJCTMAJElKmAEgSVLCDABJkhJmAEiSlDADQJKkhBkAkiQlzACQJClhBoAk
SQkzACRJSpgBIElSwgwASZISZgBIkpQwA0CSpIT9RQPgy99GjEzX49PbD2Nyea+8iCRJujoN1taj
u3PywwbA5auIens7Gq1ObB08KheEJEm6OhU3/5NHT2Lv8sX7DYBP+z7ru3gRsXPxMo6e/k+5HCRJ
0tWrvPlfvIzdR9+8ewD8+4cf3336MmL77Hm5GCRJ0tVt9+KbOLj46t0DAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAD4s/4XWxtDQv1+5i8AAAAASUVORK5CYII=</Preview>
  <Form>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
5jbtqjdLb8cNgoGb2MkcqF/M4Rx8NjDvMhPfBc7CkzzhEMYPWlk29Tb9gxp5dMGPrEW9y/j4e8Ka
oGo2/+AfHaKqToFiOvg1/RcL4oxTvv5P7Bea7VXi4XYsg2EpjU5vUu6BITRFY8DOuJh/0f9RWAsz
JQF+ULgdFrq9cj5fu20Vbz4nhUf9Z0Xpvl2u9H5cPZVHmpTQWrc0/zJZ1rvVmTRNPrw+SXTyo5XO
i7331/6ck9WHab9f7Eh9efrafulIGt35El8rtU6zWE49l+fS3e2q+uMqmX/Nsu3a3fstrY4zH6/v
D+XGfbVUrHUFrlJbSPmX+nLZ6LH1B2k6KNZLbV4W24zMtKb1m/V6NmKZlvqSHQnvzPDzx5Va+T2R
Gr0Hvv+ipKqT7sOU717nP76+Xid3cqE0lUf5m5vOde6LLqUqv+9Wtea6nut+FVbvibvPl8brQ2W1
fmmmbgpanf5xVeJe18WP9d3jutRksuXUaNx4n60K72Lq4fO92pi/pwrz0kudLlQn+ed6ZvQ0YJr3
q+eb2U0x2eso+Ub+5vH5tbQWX4qFH1eDR1ZavfKdB77dvW0/tlpdNcuUVmLmo9Bbi3yxx79w6/6c
rd1Lt8JMHZSZ3PJxMR22Pjt8/TFZWgrqe34iszclUftxtUyqUy63qE06Hx/1nJpI3ZTLUr3Gj4Xb
Ot+bqKvJA/uYn7727sbPfG6QfdSyvfLio77uT9R8QmHW1btxt9K8ebgrFH9c1WbFykBY14ocT2fY
zG2hc1vM9R9vB3T1dVIZPcvPj7nk5Jpv3F8L9CxXyGvZfva+zrAvnVpDyGXF21y6rdw+dRuNlx9X
0nUrM85la+Kox3y1pPL4jn15Xk4W6+7N5/qpwA4eGzcDrtdmEr9LjcfUU0kcDZ6vs5P8tP91XZa4
0ao2yDMszY2f9D1dt7uN9PTlYVni68rvdIavjScPjcHNvPI1fr9lVmzqqTuZNXNP9eZI1H+XLcv8
53P/iS8J3COfbowXxcboKT8Qlk3hx9U4n/nii5nU9LUirVvXa3Eo3N9XUtKHVqzMb+4m69XrqtFO
VhR2nf8Sbt+zn9XCkv1sFQovL53EY/EmXZhVJr21cnN39+OqPb+f1papWzb5lXuoKU/52st8cXed
YsSbp5uUzHfF7LgtCL3X5vPtvDsRFHE4z49V5boyec/PRrXSw2uuVFZm94UX5sdVQhalj8Izk/h8
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
px/aGbXpTu8VKt78Uf2//w/Ngu+hHJsIAA==</Form>
  <Code><![CDATA[


class config_customerinfo {
	[string]$customername
	[string]$customPrivacyURL
	[string]$logfoldertarget
	[string]$packagefolder
	[string]$tenanturl
	[string]$downloadpath
	[string]$buildingblockspath
}
function refreshTenants
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$config_treeview3.BeginUpdate()
		$config_treeview3.Refresh()
		$config_treeview3.Nodes.Clear()
		$Root = $config_treeview3.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			
			$node = $Root.Nodes.Add($tenantCSV.customername)
			#$upload_upload_listbox1.Items.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			$node.ContextMenuStrip = $config_tenants_contextmenustrip1
			
		}
		$Root.Expand()
		$config_treeview3.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function refreshTenantsUpload
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$upload_treeview2.BeginUpdate()
		$upload_treeview2.Refresh()
		$upload_treeview2.Nodes.Clear()
		$upload_treeview2.CheckBoxes = $true
		$Root = $upload_treeview2.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			#$upload_treeview2.Nodes.Add($tenantCSV.customername)
			$node = $Root.Nodes.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			
			
		}
		$Root.Expand()
		$upload_treeview2.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function PowershellISEOnTop
{
	Add-Type @"
using System;
using System.Runtime.InteropServices;
public class User32 {
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
    
    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
    
    public static IntPtr HWND_TOPMOST = new IntPtr(-1);
    public static IntPtr HWND_NOTOPMOST = new IntPtr(-2);
    public const UInt32 SWP_NOSIZE = 0x0001;
    public const UInt32 SWP_NOMOVE = 0x0002;
    public const UInt32 SWP_SHOWWINDOW = 0x0040;
}
"@
	$hwnd = [User32]::FindWindow($null, "Administrator: Windows PowerShell ISE")
	if ($hwnd -ne [IntPtr]::Zero)
	{
		[User32]::SetWindowPos($hwnd, [User32]::HWND_TOPMOST, 0, 0, 0, 0, [User32]::SWP_NOSIZE -bor [User32]::SWP_NOMOVE -bor [User32]::SWP_SHOWWINDOW)
	}
}



$IntunePrepTool_Load = {
	Set-ControlTheme $IntunePrepTool -Theme Dark
	#Set-ControlTheme $config_tabpage -Theme Dark
	$scaledHeight = ConvertTo-ScaledPixel -Form $IntunePrepTool -Height 720
	$scaledWidth = ConvertTo-ScaledPixel -Form $IntunePrepTool -Width 1725
	

	if (!(Test-Path -Path "c:\users\$env:username\.IntunePrepTool"))
	{
		
		New-Item -ItemType Directory -Path "c:\users\$env:username\.IntunePrepTool"
	}
	
	try
	{
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			Copy-Item -Path "C:\Program Files\IntunePrepTool\config_customerinfo.csv" -Destination "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
			Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
			Update-ListBox $update_exe_listbox1 $cis.customername -Append
		}
		
	}
	catch
	{
		
		[void][System.Windows.Forms.MessageBox]::Show('Add customers in the config tab', 'Please Add Customer first')
		
	}
	
	$rechten = [bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544")
	if ($rechten -eq $false)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Admin Rights needed!, Please run as Administrator', 'Please run as Administrator') # Casting the method to [void] suppresses the output. 
		
	}
	else
	{
		$restrictionpolicy = Get-ExecutionPolicy -ErrorAction SilentlyContinue;
		if ($restrictionpolicy -ne 'Unrestricted')
		{
			
			if ([System.Windows.Forms.MessageBox]::Show('Set-ExecutionPolicy Unrestricted?; Please reopen IntunePrepTool', 'Powershell Execution Policy needs to be unrestricted', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	Set-ExecutionPolicy Unrestricted

'@
				if (Test-Path "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1")
				{
					powershell.exe -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
				}
				else
				{
					$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1" -Confirm:$false -Force
					Start-Sleep 1
					powershell -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
				}
			}
		}
		else
		{
			if (Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf)
			{
				Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
			}
			$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
			if ($ResolveWingetPath)
			{
				$WingetPath = $ResolveWingetPath[-1].Path
			}
			$wingetexe = $ResolveWingetPath
			
			if (Test-path $wingetexe)
			{
				$wingetOption = 1
				$version = & $wingetexe --version
			}
			else
			{
				$wingetOption = 2
				$version = winget --version
			}
			if (($version -notlike 'v1.9*') -and ($version -notlike 'v1.10*') -and ($version -notlike 'v1.11*'))
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use button to Install / Update Winget', 'Winget missing or wrong version')
				
			}
			else
			{
			<#
			if ($wingetOption -like 1)
			{
				& $wingetexe search rink-turksma.IntunePrepTool --accept-source-agreements 2>$null
				$IntunePrepToolversion = & $wingetexe list --id rink-turksma.IntunePrepTool
			}
			else
			{
				winget search rink-turksma.IntunePrepTool --accept-source-agreements
				$IntunePrepToolversion = winget list --id rink-turksma.IntunePrepTool
			}
			Write-Host $IntunePrepToolversion
			if ($IntunePrepToolversion | Select-String '\bVersion\s+Available\b')
			{
				[void][System.Windows.Forms.MessageBox]::Show('Use button on config page to check for updates ', 'New version IntunePrepTool available')
			} #>
			}
			
			
			
			try
			{
				
				Get-ChildItem -Path "IntuneWinAppUtil.exe" -ErrorAction Stop
			}
			catch
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download Microsoft Win32 Content Prep Tool. Place EXE file in same directory as this script', 'IntuneWinAppUtil missing') # Casting the method to [void] suppresses the output. 
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			}
			if (Test-Path 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -PathType Leaf)
			{
				$reqPSModules = Get-Content 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt'
				if ($reqPSModules -like 'false')
				{
					Remove-Item 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Confirm:$false -Force
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
				}
				else
				{
					
				}
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
			}
			
			
			if (!(test-path -path 'C:\ProgramData\chocolatey'))
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use the Button: "Install Chocolatey"', 'Chocolatey missing') # Casting the method to [void] suppresses the output. 
				
			}
			
			
			refreshTenants
			refreshTenantsUpload
			
			$config_tabpage.Dock = 'Fill'
			$config_tabpage.Visible = $true
			$config_tabpage.Enabled = $true
			
			
			
			
			$BuildingBlocks_datagridview1.DataSource = $BuildingBlocksTable;
			$BuildingBlocks_datagridview2.DataSource = $BuildingBlocksTable2;
			$BuildingBlocks_datagridview3.DataSource = $BuildingBlocksTable3;
			
		}
	}
}





$darkToolStripMenuItem_Click = {
	#TODO: Place custom script here
	Set-ControlTheme -Control $IntunePrepTool -Theme Dark
}

$lightToolStripMenuItem_Click = {
	Set-ControlTheme -Control $IntunePrepTool -Theme Light
}

#region Control Theme Helper Function
<#
	.SYNOPSIS
		Applies a theme to the control and its children.
	
	.PARAMETER Control
		The control to theme. Usually the form itself.
	
	.PARAMETER Theme
		The color theme:
		Light
		Dark

	.PARAMETER CustomColor
		A hashtable that contains the color values.
		Keys:
		WindowColor
		ContainerColor
		BackColor
		ForeColor
		BorderColor
		SelectionForeColor
		SelectionBackColor
		MenuSelectionColor
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -Theme Dark
	
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -CustomColor @{ WindowColor = 'White'; ContainerBackColor = 'Gray'; BackColor... }
	.NOTES
		Created by SAPIEN Technologies, Inc.
#>
function Set-ControlTheme
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.ComponentModel.Component]$Control,
		[ValidateSet('Light', 'Dark')]
		[string]$Theme = 'Dark',
		[System.Collections.Hashtable]$CustomColor
	)
	
	$Font = [System.Drawing.Font]::New('Segoe UI', 9)
	
	#Initialize the colors
	if ($Theme -eq 'Dark')
	{
		$WindowColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ContainerColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
		$BackColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ForeColor = [System.Drawing.Color]::White
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::DimGray
	}
	else
	{
		$WindowColor = [System.Drawing.Color]::White
		$ContainerColor = [System.Drawing.Color]::WhiteSmoke
		$BackColor = [System.Drawing.Color]::Gainsboro
		$ForeColor = [System.Drawing.Color]::Black
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::LightSteelBlue
	}
	
	if ($CustomColor)
	{
		#Check and Validate the custom colors:
		$Color = $CustomColor.WindowColor -as [System.Drawing.Color]
		if ($Color) { $WindowColor = $Color }
		$Color = $CustomColor.ContainerColor -as [System.Drawing.Color]
		if ($Color) { $ContainerColor = $Color }
		$Color = $CustomColor.BackColor -as [System.Drawing.Color]
		if ($Color) { $BackColor = $Color }
		$Color = $CustomColor.ForeColor -as [System.Drawing.Color]
		if ($Color) { $ForeColor = $Color }
		$Color = $CustomColor.BorderColor -as [System.Drawing.Color]
		if ($Color) { $BorderColor = $Color }
		$Color = $CustomColor.SelectionBackColor -as [System.Drawing.Color]
		if ($Color) { $SelectionBackColor = $Color }
		$Color = $CustomColor.SelectionForeColor -as [System.Drawing.Color]
		if ($Color) { $SelectionForeColor = $Color }
		$Color = $CustomColor.MenuSelectionColor -as [System.Drawing.Color]
		if ($Color) { $MenuSelectionColor = $Color }
	}
	
	#Define the custom renderer for the menus
	#region Add-Type definition
	try
	{
		[SAPIENTypes.SAPIENColorTable] | Out-Null
	}
	catch
	{
		if ($PSVersionTable.PSVersion.Major -ge 7)
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing', 'System.Drawing.Primitives'
		}
		else
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing'
		}
		Add-Type -ReferencedAssemblies $Assemblies -TypeDefinition "
using System;
using System.Windows.Forms;
using System.Drawing;
namespace SAPIENTypes
{
    public class SAPIENColorTable : ProfessionalColorTable
    {
        Color ContainerBackColor;
        Color BackColor;
        Color BorderColor;
		Color SelectBackColor;

        public SAPIENColorTable(Color containerColor, Color backColor, Color borderColor, Color selectBackColor)
        {
            ContainerBackColor = containerColor;
            BackColor = backColor;
            BorderColor = borderColor;
			SelectBackColor = selectBackColor;
        } 
		public override Color MenuStripGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuStripGradientEnd { get { return ContainerBackColor; } }
        public override Color ToolStripBorder { get { return BorderColor; } }
        public override Color MenuItemBorder { get { return SelectBackColor; } }
        public override Color MenuItemSelected { get { return SelectBackColor; } }
        public override Color SeparatorDark { get { return BorderColor; } }
        public override Color ToolStripDropDownBackground { get { return BackColor; } }
        public override Color MenuBorder { get { return BorderColor; } }
        public override Color MenuItemSelectedGradientBegin { get { return SelectBackColor; } }
        public override Color MenuItemSelectedGradientEnd { get { return SelectBackColor; } }      
        public override Color MenuItemPressedGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientEnd { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientMiddle { get { return ContainerBackColor; } }
        public override Color ImageMarginGradientBegin { get { return BackColor; } }
        public override Color ImageMarginGradientEnd { get { return BackColor; } }
        public override Color ImageMarginGradientMiddle { get { return BackColor; } }
    }
}"
	}
	#endregion
	
	$colorTable = New-Object SAPIENTypes.SAPIENColorTable -ArgumentList $ContainerColor, $BackColor, $BorderColor, $MenuSelectionColor
	$render = New-Object System.Windows.Forms.ToolStripProfessionalRenderer -ArgumentList $colorTable
	[System.Windows.Forms.ToolStripManager]::Renderer = $render
	
	#Set up our processing queue
	$Queue = New-Object System.Collections.Generic.Queue[System.ComponentModel.Component]
	$Queue.Enqueue($Control)
	
	Add-Type -AssemblyName System.Core
	
	#Only process the controls once.
	$Processed = New-Object System.Collections.Generic.HashSet[System.ComponentModel.Component]
	
	#Apply the colors to the controls
	while ($Queue.Count -gt 0)
	{
		$target = $Queue.Dequeue()
		
		#Skip controls we already processed
		if ($Processed.Contains($target)) { continue }
		$Processed.Add($target)
		
		#Set the text color
		$target.ForeColor = $ForeColor
		
		#region Handle Controls
		if ($target -is [System.Windows.Forms.Form])
		{
			#Set Font
			$target.Font = $Font
			$target.BackColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.SplitContainer])
		{
			$target.BackColor = $BorderColor
		}
		elseif ($target -is [System.Windows.Forms.PropertyGrid])
		{
			$target.BackColor = $BorderColor
			$target.ViewBackColor = $BackColor
			$target.ViewForeColor = $ForeColor
			$target.ViewBorderColor = $BorderColor
			$target.CategoryForeColor = $ForeColor
			$target.CategorySplitterColor = $ContainerColor
			$target.HelpBackColor = $BackColor
			$target.HelpForeColor = $ForeColor
			$target.HelpBorderColor = $BorderColor
			$target.CommandsBackColor = $BackColor
			$target.CommandsBorderColor = $BorderColor
			$target.CommandsForeColor = $ForeColor
			$target.LineColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.ContainerControl] -or
			$target -is [System.Windows.Forms.Panel])
		{
			#Set the BackColor for the container
			$target.BackColor = $ContainerColor
			
		}
		elseif ($target -is [System.Windows.Forms.GroupBox])
		{
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.Button])
		{
			$target.FlatStyle = 'Flat'
			$target.FlatAppearance.BorderColor = $BorderColor
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.CheckBox] -or
			$target -is [System.Windows.Forms.RadioButton] -or
			$target -is [System.Windows.Forms.Label])
		{
			#$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.ComboBox])
		{
			$target.BackColor = $BackColor
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.TextBox])
		{
			$target.BorderStyle = 'FixedSingle'
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.DataGridView])
		{
			$target.GridColor = $BorderColor
			$target.BackgroundColor = $ContainerColor
			$target.DefaultCellStyle.BackColor = $WindowColor
			$target.DefaultCellStyle.SelectionBackColor = $SelectionBackColor
			$target.DefaultCellStyle.SelectionForeColor = $SelectionForeColor
			$target.ColumnHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.ColumnHeadersDefaultCellStyle.ForeColor = $ForeColor
			$target.EnableHeadersVisualStyles = $false
			$target.ColumnHeadersBorderStyle = 'Single'
			$target.RowHeadersBorderStyle = 'Single'
			$target.RowHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.RowHeadersDefaultCellStyle.ForeColor = $ForeColor
			
		}
		elseif ($PSVersionTable.PSVersion.Major -le 5 -and $target -is [System.Windows.Forms.DataGrid])
		{
			$target.CaptionBackColor = $WindowColor
			$target.CaptionForeColor = $ForeColor
			$target.BackgroundColor = $ContainerColor
			$target.BackColor = $WindowColor
			$target.ForeColor = $ForeColor
			$target.HeaderBackColor = $ContainerColor
			$target.HeaderForeColor = $ForeColor
			$target.FlatMode = $true
			$target.BorderStyle = 'FixedSingle'
			$target.GridLineColor = $BorderColor
			$target.AlternatingBackColor = $ContainerColor
			$target.SelectionBackColor = $SelectionBackColor
			$target.SelectionForeColor = $SelectionForeColor
		}
		elseif ($target -is [System.Windows.Forms.ToolStrip])
		{
			
			$target.BackColor = $BackColor
			$target.Renderer = $render
			
			foreach ($item in $target.Items)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ToolStripMenuItem] -or
			$target -is [System.Windows.Forms.ToolStripDropDown] -or
			$target -is [System.Windows.Forms.ToolStripDropDownItem])
		{
			$target.BackColor = $BackColor
			foreach ($item in $target.DropDownItems)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ListBox] -or
			$target -is [System.Windows.Forms.ListView] -or
			$target -is [System.Windows.Forms.TreeView])
		{
			$target.BackColor = $WindowColor
		}
		else
		{
			$target.BackColor = $BackColor
		}
		#endregion
		
		if ($target -is [System.Windows.Forms.Control])
		{
			#Queue all the child controls
			foreach ($child in $target.Controls)
			{
				$Queue.Enqueue($child)
			}
		}
	}
}
#endregion

$winget_maakPackage_button1_Click = {
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$fid = $config_packagefolder
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$wlo = $Winget_locale_textbox.text
		
	}
	else { $wlo = $null; }
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$wve = $winget_version_textbox1.text
	}
	else { $wve = $null; }
	
	$DisplayName = $winget_displayname_textbox1.text
	$WinGetID = $wid
	$regApp1 = $DisplayName
	$version = $vid
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$outputDirectory = $fid
	Set-Location $PSScriptRoot
	
	$winget_output_textbox3.Text = "`nNew intunewin package will now be created: `r`n"
	$winget_output_textbox3.AppendText("Please wait`r`n")
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$DisplayName\$version\source" -s "$outputDirectory\$DisplayName\$version\source\install.ps1" -o "$outputDirectory\$DisplayName\$version\output" -q
	
	Rename-Item -Path "$outputDirectory\$DisplayName\$version\output\install.intunewin" -NewName "$outputDirectory\$DisplayName\$version\output\$DisplayName.intunewin"
	
	
	$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\output\$DisplayName.intunewin")
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Version: $Version `r`n")
	$winget_output_textbox3.AppendText("Install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$winget_output_textbox3.AppendText("un-install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$winget_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$regApp1\"
	$regkeyApp
	$winget_output_textbox3.AppendText("$regkeyApp `r`n")
	$winget_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$winget_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: $Version `r`n")
	$winget_output_textbox3.AppendText("Please reopen tool to make another winget package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$DisplayName.intunewin"
			DisplayName   = $DisplayName
			Publisher	  = $config_customername_textbox.Text
			AppVersion    = $version;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$DisplayName\$version\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$DisplayName\$version\output\"
	$winget_output_textbox3.AppendText("Config.csv written to: `r`n")
	$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\output\config.csv")
	$winget_output_textbox3.AppendText("  `r`n")
	$winget_output_textbox3.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
	$winget_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	$winget_upload_logo_button1.Visible = $true
	$winget_upload_logo_button1.Enabled = $true;
	$buildingBlokcsCSV = $winget_buildingBlocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$DisplayName\$version\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$DisplayName\BuildingBlocks.csv" -force -NoTypeInformation
		$winget_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$winget_output_textbox3.AppendText("$config_buildingblockspath\$DisplayName\BuildingBlocks.csv `r`n")
		$winget_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
	
	
}



$winget_WingetID_textbox1_TextChanged = {
	#TODO: Place custom script here
	
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$versie_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$config_packagefolder_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_output_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_intunewin_tabpage2_Click = {
	#TODO: Place custom script here
	
}

$config_packagefolder_label_Click = {
	#TODO: Place custom script here
	
}

$winget_checkurl_button1_Click = {
	
	$wgid = $winget_WingetID_textbox1.text
	
	
	$showurl = winget show $wgid --accept-source-agreements
	foreach ($l in $showurl)
	{
		if ($l -like "*Installer Url*") { $url = "https:" + $l.Split(":")[2] }
	}
	
	
	
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show($URL, 'Download source URL') # Casting the method to [void] suppresses the output. 
	
}

$config_customername_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_logfoldertarger_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_save_button_Click = {
	#TODO: Place custom script here
	
	[string]$c_customername = $config_customername_textbox.text
	[string]$c_logfoldertarget = $config_logfoldertarger_textbox.text
	[string]$c_packagefolder = $config_packagefolder_textbox.text
	[string]$c_buildingblocksfolder  = $config_buildingblocks_textbox3.text
	[string]$c_downloadfolder = $config_download_folder_textbox3.Text
	
	[string]$c_customername = $c_customername.Replace(" ","")
	[string]$c_logfoldertarget = $c_logfoldertarget.Replace(" ", "")
	[string]$c_packagefolder = $c_packagefolder.Replace(" ", "")
	[string]$c_buildingblocksfolder = $c_buildingblocksfolder.Replace(" ", "")
	[string]$c_downloadfolder = $c_downloadfolder.Replace(" ", "")

	$config_customerinfo += @([config_customerinfo]@{
			customername    = $c_customername
			logfoldertarget = $c_logfoldertarget
			packagefolder   = $c_packagefolder
			downloadpath    = $c_downloadfolder;
			buildingblockspath = $c_buildingblocksfolder;
		})
	
	
	$existing_customerinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$filtered_customerinfo = $existing_customerinfo | Where-Object { $_.customername -ne $config_customerinfo.customername }
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Force
	$filtered_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Append
	$config_listbox.ResetText()
	try
	{
		$config_import_csv = $null;
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		$config_listbox.ClearSelected()
		$config_listbox.Items.Clear()
		$config_listbox.Refresh()
		foreach ($cis in $config_import_csv)
		{
		
				Update-ListBox $config_listbox $cis.customername -Append
				Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
				Update-ListBox $update_exe_listbox1 $cis.customername -Append
			
			
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$tools_winget_searchtabcontrol1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$exe_openexe_button1_Click = {
	#TODO: Place custom script here
	$exe_openfiledialog1.ShowDialog()
	$exe_label1.Text = $exe_openfiledialog1.SafeFileName
	$exe_label1.Visible = $true;
	$exe_maakPackageDir_button1.Enabled = $true
	$exe_open_Azure_OpenAI_Example_button1.Enabled = $true
	$exe_open_withqquestion_button1.Enabled = $true
}

$exe_label1_Click = {
	#TODO: Place custom script here
	
}

$exe_maakPackageDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$exepnaam = $exepnaam -replace (" ", "")
	$exe_packagenaam_textbox1.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$exe_output_textbox1.Text = "`nNew package directory created: `r`n"
			$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("`nEXE file will be copied now `r`n")
			
			[string]$exe_org_path = $exe_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $exe_org_path -Confirm:$false
				Copy-Item -Path $exe_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\source" -ErrorAction Stop
				$exe_output_textbox1.AppendText("`nEXE file copy done!`r`n")
				$exe_output_textbox1.AppendText("`nIf you need any additional files please place in just created source directory `r`n")
				$exe_panel1.Enabled = $true
				$exe_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nEXE file copy failed. Please select EXE file first `r`n")
			}
			$exe_open_sourcedir_button1.Enabled = $true
			$exe_open_sourcedir_button1.Visible = $true
			$exe_maakScripting_button1.Enabled = $true
			$exe_buttonAddCustomPackageDesc.Enabled = $true
			$exe_buttonAddCustomPackageDesc.Visible = $true
			
		}
	}
	
	
}

$exe_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$exe_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_intunewin_tabpage5_Click = {
	#TODO: Place custom script here
	
}

$exe_parsInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	$argList = $exe_parsInstall_textbox1.Text
	$exebestand = $exe_openfiledialog1.SafeFileName
	$exe_output_installparameters.text = "Start-Process -FilePath $EXEbestand -ArgumentList $argList"
}

$exe_output_installparameters_Click = {
	#TODO: Place custom script here
	
}

$exe_install_test_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show("After successful test in PowerShell ISE. Please click the 'Test Done' button.", 'Test install.ps1?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		$backupFolder = "$env:LOCALAPPDATA\temp"
		$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
		$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
		$preBackupPath = Join-Path $backupFolder "PreChanges64_$timeStamp.reg"
		try
		{
			New-Variable -Name 'exe_preBackupPath64' -Value $preBackupPath -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'exe_preBackupPath64' -Value $preBackupPath -Scope Script
		}
		
		reg export "$regExportPath" "$preBackupPath" /y | Out-Null
		$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
		$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
		$preBackupPath = Join-Path $backupFolder "PreChanges32_$timeStamp.reg"
		try
		{
			New-Variable -Name 'exe_preBackupPath32' -Value $preBackupPath -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'exe_preBackupPath32' -Value $preBackupPath -Scope Script
		}
		reg export "$regExportPath" "$preBackupPath" /y | Out-Null
		$exe_test_done_button1CreateInstallScript.Enabled = $true
		$exe_gotobuildingblocksButton.Enabled = $true
		
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$exe_radiobuttonUninstallEXEPath_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_parsUnInstall_textbox1.Enabled = $true
	$exe_parsUnInstall_textbox1.Visible = $true
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
}

$exe_radiobuttonGebruikZelfdeEXEAlsB_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_parsUnInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exebestandUninstall = $exe_uninstall_exe_path_textbox2.text
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exebestandUninstall = $exe_openfiledialog1.SafeFileName
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $true
	$exe_labelVoorbeeldUninstall.Enabled = $true
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
	
	$argList2 = $exe_parsUnInstall_textbox1.text
	if ($exe_openfiledialog1.SafeFileName -like "*.exe")
	{
		
		$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
	}
}

$exe_labelVoorbeeldUninstall_Click = {
	#TODO: Place custom script here
	
}

$exe_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation.. You can Edit in Powershell ISE. And save that file if needed.', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$exe_addBuildingBlocksCSVButton.Enabled = $true
	}
	
	
	
}

$exe_maakScripting_button1_Click = {
	#TODO: Place custom script here
	
	$exe_UnlInstallParameters.Visible = $true
	$exe_UnlInstallParameters.Enabled = $true
	$exe_radiobuttonUninstallEXEPath.Visible = $true
	$exe_radiobuttonUninstallEXEPath.Enabled = $true
	$exe_install_test_button1.Enabled = $true
	$exe_install_test_button1.Visible = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Enabled = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Visible = $true
	$exe_radiobutton3.Enabled = $true
	$exe_radiobutton3.Visible = $true
	
	
	$exe_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 18:02
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$exeFile = "!!ExeFile!!"
$exeParameters = "!!ExeParams!!" ## Check EXE Params.. 
# Customer variables
$logDir = "!!LogDir!!"
$registerDetectionRoot = "!!RegisterDetectionRoot!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $exeFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Installation completed of $exeFile" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error executing $exeFile" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:









Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_installFile = $exe_installFile.Replace('"!!AppName!!"', $appnaam)
	$exe_installFile = $exe_installFile.Replace('!!LogDir!!', $logdir)
	$exe_installFile = $exe_installFile.Replace('!!RegisterDetectionRoot!!', $RegisterDetectionroot)
	$exe_installFile = $exe_installFile.Replace('!!Version!!', $versie)
	$exe_installFile = $exe_installFile.Replace('"!!ExeFile!!"', $EXEbestand)
	$exe_installFile = $exe_installFile.Replace('"!!ExeParams!!"', $EXEPARSInput)
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	try
	{
		$exe_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$exe_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	
	
}

$exe_uninstall_exe_path_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$exe_maak_intuneWIN_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$mkiapn = $exe_packagenaam_textbox1.text
	$versie = $exe_versie_textbox1.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$exepnaam\$exeversie\source\" -s "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -o "$outputDirectory\$exepnaam\$exeversie\output\" -q
	Rename-Item -Path "$outputDirectory\$exepnaam\$exeversie\output\install.intunewin" -NewName "$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin"
	$exe_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin")
	$exe_output_textbox1.AppendText("`r`n")
	
	$exe_output_textbox1.AppendText("Install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$exe_output_textbox1.AppendText("un-install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$exe_output_textbox1.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$mkiapn\"
	$regkeyApp
	$exe_output_textbox1.AppendText("$regkeyApp `r`n")
	$exe_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$exe_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: $Versie `r`n")
	$exe_output_textbox1.AppendText("Please reopen tool to make another EXE package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$exepnaam.intunewin"
			DisplayName   = $exepnaam
			Publisher	  = $config_customername
			AppVersion    = $exeversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$exepnaam\$exeversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$exepnaam\$exeversie\output\"
	$exe_output_textbox1.AppendText("Config.csv written to naar: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\config.csv")
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	$exe_output_textbox1.AppendText("  `r`n")

	$buildingBlokcsCSV = $exe_buildingblockscsv_textbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$exepnaam\$exeversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$exepnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$exe_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$exe_output_textbox1.AppendText("$config_buildingblockspath\$exepnaam\BuildingBlocks.csv `r`n")
		$exe_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$exe_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$exe_output_textbox1.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$exe_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
	
	
}

$msi_buttonOpenMSIFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog1.ShowDialog()
	$msi_openmsi_label1.Text = $msi_openfiledialog1.SafeFileName
	$msi_openmsi_label1.Visible = $true;
	$msi_openfiledialog2.Reset()
	$msi_openfiledialog3.Reset()
	$msi_openmsp_label1.Text = ''
	$msi_openmsp_label1.Visible = $false
	$msi_openmsp_label1.Enabled = $false
	$msi_buttonOpenMSPFile.Enabled = $true
	$msi_buttonOpenMSPFile.Visible = $true
	$msi_openmst_label1.Text = ''
	$msi_buttonOpenMSTFile.Visible = $true
	$msi_buttonOpenMSTFile.Enabled = $true
	#$msi_reg_hklm_label5.Visible = $false
	#$msi_reg_hklm_label5.Enabled = $false
	
	
}

$msi_buttonOpenMSPFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog2.ShowDialog()
	$msi_openmsp_label1.Text = $msi_openfiledialog2.SafeFileName
	$msi_openmsp_label1.Visible = $true
	$msi_openmsp_label1.Enabled = $true
}


$msi_buttonOpenMSTFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog3.ShowDialog()
	$msi_openmst_label1.Text = $msi_openfiledialog3.SafeFileName
	$msi_openmst_label1.Visible = $true
	$msi_openmst_label1.Enabled = $true
}



$msi_openmsi_label1_Click = {
	#TODO: Place custom script here
	
}

$msi_buttonCreatePackageDirecto_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msipnaam = $msi_packagenaam_textbox1.text
	$msipnaam = $msipnaam -replace (" ", "")
	$msi_packagenaam_textbox1.text = $msipnaam
	$msiversie = $msi_versie_textbox1.text
	
	if ($msipnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msiversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\output"
			}
			$msi_output_textbox1.Text = "`nNew package direcotory created: `r`n"
			$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\source")
			$msi_output_textbox1.AppendText("`r`n")
			$msi_output_textbox1.AppendText("`nMSI file will now be copied`r`n")
			[string]$msi_org_path = $msi_openfiledialog1.FileNames
			
			
			
			try
			{
				Unblock-File -Path $msi_org_path -Confirm:$false
				function Get-MSIProductCode
				{
					### GPT o1-preview
					param (
						[Parameter(Mandatory = $true)]
						[string]$MSIPath
					)
					$installer = New-Object -ComObject WindowsInstaller.Installer
					$database = $installer.OpenDatabase($MSIPath, 0)
					$view = $database.OpenView("SELECT Value FROM Property WHERE Property='ProductCode'")
					$view.Execute()
					$record = $view.Fetch()
					if ($record -ne $null)
					{
						$productCode = $record.StringData(1)
						return $productCode
					}
					else
					{
						Write-Error "ProductCode niet gevonden in het MSI-bestand."
						return $null
					}
					$view.Close()
				}
				$productCode = Get-MSIProductCode -MSIPath $msi_org_path
				
				
				$MSINewname = $msi_openfiledialog1.FileName
				
				$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
				$MSINewname = $MSINewname.Replace(" ", "")
				$MSIbestand = "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname"
				
				
				
				#Write-Host $MSIbestand
				Copy-Item -Path $msi_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname" -ErrorAction Stop
				$msi_output_textbox1.AppendText("`nMSI file copy done `r`n")
				$msp = $msi_openmsp_label1.Text
				
				if ($msp -ne '')
				{
					[string]$msp_org_path = $msi_openfiledialog2.FileNames
					Unblock-File -Path $msp_org_path -Confirm:$false
					$MSPNewname = $msi_openfiledialog2.FileName
					$MSPNewname = $MSPNewname.Split("\")[$MSPNewname.Split("\").Count - 1]
					$MSPNewname = $MSPNewname.Replace(" ", "")
					Copy-Item -Path $msp_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSPNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMSP file copy done `r`n")
				}
				$mst = $msi_openmst_label1.Text
				if ($mst -ne '')
				{
					[string]$mst_org_path = $msi_openfiledialog3.FileNames
					Unblock-File -Path $mst_org_path -Confirm:$false
					$MSTNewname = $msi_openfiledialog3.FileName
					$MSTNewname = $MSTNewname.Split("\")[$MSTNewname.Split("\").Count - 1]
					$MSTNewname = $MSTNewname.Replace(" ", "")
					Copy-Item -Path $mst_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSTNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMST file copy done `r`n")
				}
				
				$msi_output_textbox1.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				$msi_panel1.Enabled = $true
				$msi_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			$appNaam = $msipnaam
			$versie = $msiversie
			#$msi_openfiledialog1.SafeFileName
			#klant variabelen
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			#Dyn vars
			$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
			$filenaamMSILog = $appNaam + $versie + "MSI"
			$filenaamMSIUninstallLog = $appNaam + $versie + "MSI" + "_uninstall"
			$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
			$logfileMSIUninstall = "$(Join-Path $logdir  "$filenaamMSIUninstallLog.txt")"
			
			if ($msp -ne '')
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname PATCH=$MSPNewname"
			}
			else
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname"
			}
			if ($mst -ne '')
			{
				$oldMSIInstallstring = $msi_install_par_textbox3.Text
				$msi_install_par_textbox3.Text = $oldMSIInstallstring + " TRANSFORMS=$MSTNewname"
				
			}
			
			
			$msi_uninstall_par_textbox1.Text = "msiexec /qn, /l*v $logfileMSIUninstall /x$productCode"
			$msi_OpenSourceDir_button1.Enabled = $true
			$msi_OpenSourceDir_button1.Visible = $true
			$msi_open_Orca_button1.Enabled = $true
			$msi_addDescription.Enabled = $true
			$msi_addDescription.Visible = $true
		}
	}
	
	
}

$labelInstallParametersadj_Click = {
	#TODO: Place custom script here
	
}

$msi_uninstall_par_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$msi_button1CreateInstallScript_Click = {
	#TODO: Place custom script here
	#'"' + $exe_openfiledialog1.SafeFileName + '"'
	
	$msi_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	28-8-2025 17:00
	 Created by:   	Rink Turksma	
	 Organization: 	https://intunepreptool.com
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Install file generated by the IntunePrepTool
#>


#AppsVars
$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"

#Customer vars
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$loglevel = "!!loglevel!!"

#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;



##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot

if ($loglevel -eq 'verbose')
{
	
	try
	{
		$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
		
		$msilog = get-content $logfileMSI
		if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
		Else
		{
			foreach ($ml in $msilog)
			{
				if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
				{
					$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
				}
			}
			write-host "Script started i.cmd" -ForegroundColor Green
			Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
			write-host $logfileMSI -ForegroundColor Green
			$MSILOGS = get-content $logfileMSI
			
			
			
		}
		
		if ($msiuninstallcode -eq $null) { $excode = 1; write-error "Can't find uninstall code in MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
		Else
		{
			
			$MSILogs = Get-Content -Path $logfileMSI
			
			
			$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
			
			$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
			
			$Status = $null
			
			
			$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
			if ($lastStatusLine)
			{
				if ($lastStatusLine.Line -match $patternStatus)
				{
					$Status = [int]$Matches['code']
				}
			}
			
			
			if (-not $Status)
			{
				$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
				if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
				{
					$Status = [int]$Matches['code']
				}
			}
			
			$MsiErrors = @{
				0 = 'ERROR_SUCCESS - The action completed successfully.'
				13 = 'ERROR_INVALID_DATA - The data is invalid.'
				87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
				120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
				1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
				1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
				1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
				1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
				1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
				1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
				1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
				1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
				1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
				1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
				1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
				3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
			}
			[int]$code = $Status
			if ($MsiErrors.ContainsKey($code))
			{
				$msg = $MsiErrors[$code]
			}
			else
			{
				$msg = "Unknown MSI error code: $code"
			}
			if ($code -eq 0 -or $code -eq 3010)
			{
				Write-Host "MSI Result: $msg" -ForegroundColor Green
				$excode = 0
			}
			else
			{
				Write-Error "MSI Result: $msg"
				$excode = 1
			}
			$excode = 0
		}
	}
	catch
	{
		Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
		Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
		$MSILogs = Get-Content -Path $logfileMSI
		
		
		$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
		
		$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
		
		$Status = $null
		
		
		$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
		if ($lastStatusLine)
		{
			if ($lastStatusLine.Line -match $patternStatus)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		if (-not $Status)
		{
			$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
			if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		
		# Output
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
		
		
		$excode = 1
	}
}
else
{
	try
	{
		$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
		write-host $startPMSI
		$msilog = get-content $logfileMSI
		if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
		Else
		{
			foreach ($ml in $msilog)
			{
				if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
				{
					$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
				}
			}
			write-host "Script started i.cmd" -ForegroundColor Green
			write-host ""
			Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
			write-host $logfileMSI -ForegroundColor Green
			$MSILOGS = $null; $MSILOGS = get-content $logfileMSI
			$MSILOGS
			$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
			if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
			{
				$Status = $matches[1]
			}
			
			
			$MsiErrors = @{
				0 = 'ERROR_SUCCESS - The action completed successfully.'
				13 = 'ERROR_INVALID_DATA - The data is invalid.'
				87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
				120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
				1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
				1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
				1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
				1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
				1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
				1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
				1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
				1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
				1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
				1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
				1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
				3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
			}
			[int]$code = $Status
			if ($MsiErrors.ContainsKey($code))
			{
				$msg = $MsiErrors[$code]
			}
			else
			{
				$msg = "Unknown MSI error code: $code"
			}
			if ($code -eq 0 -or $code -eq 3010)
			{
				Write-Host "MSI Result: $msg" -ForegroundColor Green
				$excode = 0
			}
			else
			{
				Write-Error "MSI Result: $msg"
				$excode = 1
			}
		}
	}
	catch
	{
		Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
		Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
		
		$MSILOGS = $null; $MSILOGS = get-content $logfileMSI
		$MSILOGS
		$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
		if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
		{
			$Status = $matches[1]
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		
		# Output
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
		
	}
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'hklm.reg')
{
	Write-Host "hklm.reg detected.. Now importing" -ForegroundColor Green
	
	# Run reg import, capturing stdout/stderr in $output
	$output = reg import "hklm.reg" /reg:64 2>&1
	
	# reg.exe sets a process exit code. 0 = success
	if ($LASTEXITCODE -eq 0)
	{
		Write-Host "Import succeeded!" -ForegroundColor Green
	}
	else
	{
		Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
		Write-Host "Output was: $output"
	}
}
if (Test-Path 'BuildingBlocks\System')
{
	$originalLocation = Get-Location
	Write-Host "BuildBlocks folder detected"
	
	$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
	foreach ($bb in $allBuildingBlocks)
	{
		$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
		
		if (Test-Path $bbScriptLocation -PathType Leaf)
		{
			Write-Host "Now running Building Blocks Script $bbScriptLocation"
			& $bbScriptLocation
			Set-Location $originalLocation
		}
	}
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	fDetectionInRegistry -succes $true
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_install_par_textbox3.Text + '"'
	
	$msi_installFile = $msi_installFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_installFile = $msi_installFile.Replace('!!logdir!!', $logdir)
	$msi_installFile = $msi_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_installFile = $msi_installFile.Replace('!!versie!!', $versie)
	$msi_installFile = $msi_installFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$loglevel = '"' + 'verbose' + '"'
	}
	else
	{
		$loglevel = '"' + 'info' + '"'
	}
	$msi_installFile = $msi_installFile.Replace('"!!loglevel!!"', $loglevel)

	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_install_par_textbox3.Text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\i.cmd" -encoding ascii -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$msi_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`ni.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$msi_output_textbox1.AppendText("`nAfter succesvol installation you can see the uninstall string in Powershell_ISE `r`n")
		$msi_output_textbox1.AppendText("`nIf this is not working. Check Tab Tools for uninstall strings `r`n")
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	$msi_test_install_button1.Enabled = $true
	$msi_test_install_button1.Visible = $true
	
	
}

$msi_install_par_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$msi_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show("When you want to add Building Blocks to this package, test installation first, then use the '(Optional) Go to Building Blocks' button", 'Test install.ps1?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msi_buttonOptionalGoToBuilding.Enabled = $true
	}
}

$Tools_Uninstall_String_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_Output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_Syswow_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$buttonUninstallstringWowAA32Node_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Hier volgen alle uninstallString sort by datum WowAA32Node `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WowAA32Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$msi_button5CreateIntunewinFile_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msi_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$msi_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$msi_output_textbox1.AppendText("`r`n")
	
	$msi_output_textbox1.AppendText("Install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msi_output_textbox1.AppendText("un-install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msi_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$msi_output_textbox1.AppendText("$regkeyApp `r`n")
	$msi_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$msi_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$msi_output_textbox1.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$msi_output_textbox1.AppendText("Config.csv written to: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$msi_output_textbox1.AppendText("  `r`n")
	$msi_buttonUploadLogoPNG.Enabled = $true
	$msi_buttonUploadLogoPNG.Visible = $true

	$buildingBlokcsCSV = $MSI_buildigblocks_Package_InProgresstextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$msipnaam\$msiversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$msipnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$msi_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$msi_output_textbox1.AppendText("$config_buildingblockspath\$msipnaam\BuildingBlocks.csv `r`n")
		$msi_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$msi_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$msi_output_textbox1.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$msi_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
}

$msi_OpenSourceDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$msipnaam\$msiversie\source\"
}

$msi_button3CreateUninstallScri_Click = {
	#TODO: Place custom script here
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	29-8-2025 18:17
	 Created by:   	Rink Turksma
	 Organization: 	https://intunepreptool.com
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$loglevel = "!!loglevel!!"

#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI_uninstall"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
if ($loglevel -eq 'verbose')
{
	try
	{
		$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
		write-host $startPMSI
		write-host "Uninstall done!" -ForegroundColor Green
		write-host "Script used u.cmd" -ForegroundColor Green
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		
		$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
		
		$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
		
		$Status = $null
		
		
		$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
		if ($lastStatusLine)
		{
			if ($lastStatusLine.Line -match $patternStatus)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		if (-not $Status)
		{
			$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
			if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
		$excode = 0
	}
	catch
	{
		
		Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
		write-host "Script used u.cmd" -ForegroundColor Red
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		
		$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
		
		$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
		
		$Status = $null
		
		
		$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
		if ($lastStatusLine)
		{
			if ($lastStatusLine.Line -match $patternStatus)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		if (-not $Status)
		{
			$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
			if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
			$startPMSI
		}
		$startPMSI
		$excode = 1
	}
}
else
{
	try
	{
		$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
		write-host $startPMSI
		write-host "Uninstall done!" -ForegroundColor Green
		write-host "Script used u.cmd" -ForegroundColor Green
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
		if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
		{
			$Status = $matches[1]
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
	}
	catch
	{
		
		Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		write-host "Script used u.cmd" -ForegroundColor Red
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
		if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
		{
			$Status = $matches[1]
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
	}


if (Test-Path 'BuildingBlocks\System')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
}

#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	remove-item $regkeyApp
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_uninstall_par_textbox1.Text + '"'
	
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$loglevel = '"' + 'verbose' + '"'
	}
	else
	{
		$loglevel = '"' + 'info' + '"'
	}
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!loglevel!!"', $loglevel)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_uninstall_par_textbox1.text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
		$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`nu.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
		
		
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
	}
	$msi_button4TestUninstallPowers.Enabled = $true
	$msi_button4TestUninstallPowers.Visible = $true
	$msi_button5CreateIntunewinFile.Enabled = $true
	$msi_button5CreateIntunewinFile.Visible = $true
	
	
}

$msi_button4TestUninstallPowers_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msi_addBuildingBlocksSystemContextbutton5CreateIntunewinFile.Enabled = $true;
	}
}

$Reset_button1_Click = {
	#TODO: Place custom script here
	Clear-Host
}

$config_tabpage1_Click = {
	#TODO: Place custom script here
	
}

$winget_upload_button1_Click = {
	#TODO: Place custom script here
	<#
	$token = Connect-MSIntuneGraph -TenantID "339ad6f1-ba98-4db6-bf71-0c140c9271bc" -Interactive
	$RegisterDetectionroot = "Intune_Customer"
	$appNaam = "Greenshot"
	$versie = 1
	$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
	$regkeyApp = "$regkeyRoot\$appNaam"
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	Add-IntuneWin32App -FilePath $IntuneWinFile `
					   -DisplayName $DisplayName `
					   -Description $DisplayName `
					   -Publisher $Publisher `
					   -AppVersion $AppVersion `
					   -Icon $IconCMD `
					   -InstallExperience "system" `
					   -RestartBehavior "suppress" `
					   -DetectionRule $DetectionRule `
					   -InstallCommandLine 'powershell -executionpolicy bypass -file install.ps1' `
					   -UninstallCommandLine 'powershell -executionpolicy bypass -file uninstall.ps1' -Verbose
	#>
}

$upload_LoadConfig_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	}
	else
	{
		
		
		$config_csv_openfiledialog1.ShowDialog() | Out-Null
		if ($config_csv_openfiledialog1.FileNames -notcontains 'config_csv_openfiledialog1')
		{
			$upload2_IntuneWinFile_textbox1.Text = $null;
			$upload2_DisplayName_textbox2.Text = $null;
			$upload2_Publisher_textbox1.Text = $null;
			$upload2_AppVersion_textbox1.Text = $null;
			$upload2_reglocation_textbox2.Text = $null;
			$upload2_regValue_textbox1.Text = $null;
			$upload2_installCMD_textbox1.Text = $null;
			$upload2_uninstallCMD_textbox1.Text = $null;
			$upload2_context_textbox1.Text = $null;
			
			$upload_panel2.Enabled = $false
			[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
			$upload_configLoaded_textbox3.Text = $config_csv_openfiledialog1.FileNames
			$ConfigCSVImport = Import-Csv $config_csv_path
			#Write-Host $ConfigCSVImport
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload_context_textbox1.Text = $context
			
			
			if (!(test-path "$filepath\Logo.png" -PathType Leaf))
			{
				[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG, JPG, JPEG or WEBP file for the company portal', 'No Logo for Company portal found')
				$upload_logo_button2.Enabled = $true
				$upload_logo_button2.Visible = $true
				
			}
		}
	}
}

$upload_IntuneWinFile_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_DisplayName_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_Publisher_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_AppVersion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_reglocation_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_regValue_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_installCMD_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_upload_button1_Click = {
	#TODO: Place custom script here
	$uploadIntuneFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	18-9-2025 15:30
	 Created by:   	Rink Turksma
	 Organization: 	https://intunepreptool.com
	 Filename:     	UploadIntune.ps1
	========================================
#>

#Requires -RunAsAdministrator
$RequiredPSModules = get-content "C:\Program Files\IntunePrepTool\InstallReqPSModules.txt"
if ($RequiredPSModules -like 'false')
{
	write-error 'Missing required Powershell Modules'
	start-sleep 60
	exit
}

[string]$config_csv_path = '!!CONFIGCSV!!'
[string]$buildingblocks_csv_path = '!!BUILDINGBLOCKSCSV!!'
$dep = "!!DEPENDENCY!!"
$AvailableAllUsers = "!!AvailableAllUsers!!"
$RequiredAllDevices = "!!RequiredAllDevices!!"
$SetupLikeOldVersion = "!!SetupLikeOldVersion!!"
$TenantName = "!!TenantName!!"
Write-host "First we logon to the Microsoft Tenant"
Write-host "`r`n"
Write-host "`r`n"

try
{
	$load_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv" -ErrorAction Stop
}
catch
{
	Write-Error "Error loading csv file c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv"
}


foreach ($load in $load_import_csv)
{
	if ($load.customername -eq $tenantName)
	{
		
		if ($load.target -ne 'plain')
		{
			$checkCredLoad = Get-StoredCredential -Target $load.target -AsCredentialObject
			$tenantID = $checkCredLoad.TargetName
			$tenantID = $tenantID.Split("_")[1]
			$AppId = $checkCredLoad.UserName
			$Secret = $checkCredLoad.Password
		}
		else
		{
			$cust = import-csv "c:\users\$env:username\.IntunePrepTool\$tenantname.csv"
			$tenantID = $cust.tenantID
			$AppId = $cust.appId
			$Secret = $cust.clientsecret
			$customPrivacyURL = $cust.customPrivacyURL
			
		}
	}
}

try
{
	Connect-MSIntuneGraph -TenantID $tenantID -ClientID $appID -ClientSecret $secret -ErrorAction Stop
}
catch
{
	Write-Error "No Connection to tenant. Please check app registration!!"
	start-sleep 60
	exit
}
$ConfigCSVImport = Import-Csv $config_csv_path
$itwnf = $ConfigCSVImport.IntuneWinFile
$filepath = $config_csv_path.TrimEnd("config.csv")
$itwnffilepath = $filepath + $itwnf
$descriptionpath = $filepath + 'Description.txt'
if (Test-Path $descriptionpath)
{
	[string]$description = Get-Content $descriptionpath
}
else
{
	$description = "The package has been uploaded using the IntunePrepTool."
}
$regKeyApp = $ConfigCSVImport.regLocation
$versie = $ConfigCSVImport.AppVersion
$regvalue = $ConfigCSVImport.RegValue
$dnam = $ConfigCSVImport.DisplayName
$publ = $ConfigCSVImport.Publisher
$icmd = $ConfigCSVImport.installCMD
$ucmd = $ConfigCSVImport.uninstallCMD
if ($ConfigCSVImport.context)
{
	$context = $ConfigCSVImport.context
}
else
{
	$context = 'system'
}
$logoaanwezig = $null;
try
{
	$logoaanwezig = get-childitem "$filepath\logo.png" -ErrorAction Stop
	$icon = New-IntuneWin32AppIcon -FilePath "$filepath\logo.png"
}
catch
{
	Write-Host "No Logo.PNG found in Output Directory" - ForegroundColor Green; Write-host "`r`n"; $logoaanwezig = $null;
}
$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName $regvalue -StringComparisonOperator equal -StringComparisonValue $versie
$RequirementRule = New-IntuneWin32AppRequirementRule -Architecture "All" -MinimumSupportedWindowsRelease "W10_20H2"
write-host "We will first check if there are any apps already available in Intune with the same DisplayName" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
$Win32AppEvtVorigeVersies = Get-IntuneWin32App -DisplayName $dnam
if ($Win32AppEvtVorigeVersies -ne $null)
{
	write-host "Already version(s) found " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$evtvversie = $Win32AppEvtVorigeVersies.DisplayVersion
	write-host $evtvversie
	$alversieAppAanwezig = $true;
	write-host "After uploading new version you can choose Superseedence in this script" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
}

else
{
	$alversieAppAanwezig = $false;
}

write-host "We will upload to Intune now" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
if ($logoaanwezig -eq $null)
{
	if (($customPrivacyURL -ne $null) -and ($customPrivacyURL -notlike ''))
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -PrivacyURL $customPrivacyURL
	}
	else
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule
	}
	
}
else
{
	if (($customPrivacyURL -ne $null) -and ($customPrivacyURL -notlike ''))
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -PrivacyURL $customPrivacyURL
	}
	else
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule
	}
}
Write-host "If all is good the app will now be available in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";

if ($SetupLikeOldVersion -eq $true)
{
	if ($alversieAppAanwezig -eq $false) { write-host "Because there where no older versions of this software in Intune you have to do the assingments in the Intune portal" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	else
	{
		
		foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
		{
			write-host "We will now try to setup assignments " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
			$assinmentVorigeVersie = get-IntuneWin32AppAssignment -id $vorigeversie.id
			$evtvversie = $vorigeversie.DisplayVersion
			
			if ($assinmentVorigeVersie -eq $null) { write-host "Older version: $evtvversie has no assignments" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
			else
			{
				write-host ""; Write-host "`r`n"; Write-host "`r`n"
				$response = read-host "Press q to do nothing, Any other key to setup assignments like: $evtvversie"
				$niksdoen = $response -eq "q"
				if ($niksdoen -eq $true) { write-host "Ok.. Then you have to setup the assignments in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host "Ok .. We will fix the assignments for you!" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
					Remove-IntuneWin32AppAssignment -ID $vorigeversie.ID -Confirm:$false
					try
					{
						Add-IntuneWin32AppAssignmentGroup -Intent $assinmentVorigeVersie.intent -Include -ID $Win32App.id -GroupID $assinmentVorigeVersie.Target.groupId -ErrorAction Stop
					}
					catch
					{
						Write-Host "Something went wrong. You will have to do this in Intune" -ForegroundColor Green
					}
				}
			}
		}
		
		foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
		{
			$response = read-host "Press q to do nothing, Any other key to setup Supersedence  "
			$niksdoen = $response -eq "q"
			if ($niksdoen -eq $true) { write-host "Ok.. We are doing nothing here" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
			else
			{
				write-host "Ok .. We will try to fix superseedence" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
				Write-host "We will fix superseedence for:" -ForegroundColor Green
				$vorigeversie.displayVersion
				
				$superseede = New-IntuneWin32AppSupersedence -ID $vorigeversie.id -SupersedenceType Replace
				$bestaandeSuperSedence = $null; $bestaandeSuperSedence = Get-IntuneWin32AppSupersedence -ID $vorigeversie.id
				if ($bestaandeSuperSedence -ne $null) { Remove-IntuneWin32AppSupersedence -ID $bestaandeSuperSedence -Confirm:$False }
				Add-IntuneWin32AppSupersedence -ID $Win32App.id -Supersedence $superseede -Confirm:$false
			}
		}
	}
}
if ($AvailableAllUsers -eq $true)
{
	write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	Add-IntuneWin32AppAssignmentAllUsers -ID $Win32App.Id -Intent available -Notification showAll
}


if ($RequiredAllDevices -eq $true)
{
	write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	Add-IntuneWin32AppAssignmentAllDevices -ID $Win32App.Id -Intent required -Notification hideAll
}
write-host 'Upload Finished!' -ForegroundColor Green
start-sleep 15

'@
	function Get-CheckedNodes
	{
		param (
			[ValidateNotNull()]
			[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
			[ValidateNotNull()]
			[System.Collections.ArrayList]$CheckedNodes)
		
		foreach ($Node in $NodeCollection)
		{
			if ($Node.Checked)
			{
				[void]$CheckedNodes.Add($Node)
			}
			Get-CheckedNodes $Node.Nodes $CheckedNodes
		}
	}
	$CheckedNodes = New-Object System.Collections.ArrayList
	Get-CheckedNodes $upload_treeview2.Nodes $CheckedNodes
	[string]$config_csv_path = $upload_configLoaded_textbox3.Text
	foreach ($node in $CheckedNodes)
	{
		
		if ($config_csv_path -notlike '*BuildingBlocks.csv*')
		{
			$depWin = $upload_dep_textbox1.Text
			$tenantName = $node.Name
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!CONFIGCSV!!', $config_csv_path)
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!TenantName!!', $TenantName)
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!DEPENDENCY!!', $depWin)
			if ($Upload_beschikbaar_all_users_checkbox1.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $false)
			}
			if ($upload_checkboxRequiredForAllDevice.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $false)
			}
			if ($upload_checkboxSetupAssignmentLikeP.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $false)
			}
			
			
			
			
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$tenant = $node.Name
			$uploadFile = $filepath + "\uploadIntune" + $tenant + ".ps1"
			$uploadIntuneFile | Out-File $uploadFile -Force
			
			if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				Start-Process -FilePath "powershell.exe" -ArgumentList "-NoProfile -File $uploadFile"
				#powershell -file $filepath\uploadIntune.ps1
				#Start-Sleep 1
				#PowershellISEOnTop
			}
		}
		else
		{
			if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				$tenantName = $node.Name
				$scriptPath = "C:\Program Files\IntunePrepTool\UploadToIntuneBuildingBlocksCSV.ps1"
				$args = "-NoProfile -File `"$scriptPath`" -buildingblocks_csv_path `"$config_csv_path`" -tenantname `"$tenantName`""
				
				if ($Upload_beschikbaar_all_users_checkbox1.Checked)
				{
					$args += " -AvailableAllUsers `"True`""
				}
				
				if ($upload_checkboxRequiredForAllDevice.Checked)
				{
					$args += " -RequiredAllDevices `"True`""
				}
				Write-Host $args
				Start-Process -FilePath "powershell.exe" -ArgumentList $args
				
			}
			
		}
		
		
	}
	
	
}

$upload_tenantURL_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_upload_logo_button1_Click = {
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$DisplayName = $winget_displayname_textbox1.text
	$msipnaam = $DisplayName -replace (" ", "")
	$msiversie = $versie_textbox2.Text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
}

$msi_buttonUploadLogoPNG_Click = {
	#TODO: Place custom script here
	
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\","\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
}

$exe_uploadlogo_button1_Click = {
	#TODO: Place custom script here
	$msipnaam = $exe_packagenaam_textbox1.text
	$msiversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
}



$upload_dep_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}





$config_panel_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_tenanturl_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

#region Control Helper Functions
function Show-NotifyIcon
{
<#
	.SYNOPSIS
		Displays a NotifyIcon's balloon tip message in the taskbar's notification area.
	
	.DESCRIPTION
		Displays a NotifyIcon's a balloon tip message in the taskbar's notification area.
		
	.PARAMETER NotifyIcon
     	The NotifyIcon control that will be displayed.
	
	.PARAMETER BalloonTipText
     	Sets the text to display in the balloon tip.
	
	.PARAMETER BalloonTipTitle
		Sets the Title to display in the balloon tip.
	
	.PARAMETER BalloonTipIcon	
		The icon to display in the ballon tip.
	
	.PARAMETER Timeout	
		The time the ToolTip Balloon will remain visible in milliseconds. 
		Default: 0 - Uses windows default.
#>
	 param(
	  [Parameter(Mandatory = $true, Position = 0)]
	  [ValidateNotNull()]
	  [System.Windows.Forms.NotifyIcon]$NotifyIcon,
	  [Parameter(Mandatory = $true, Position = 1)]
	  [ValidateNotNullOrEmpty()]
	  [String]$BalloonTipText,
	  [Parameter(Position = 2)]
	  [String]$BalloonTipTitle = '',
	  [Parameter(Position = 3)]
	  [System.Windows.Forms.ToolTipIcon]$BalloonTipIcon = 'None',
	  [Parameter(Position = 4)]
	  [int]$Timeout = 0
 	)
	
	if($null -eq $NotifyIcon.Icon)
	{
		#Set a Default Icon otherwise the balloon will not show
		$NotifyIcon.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon([System.Windows.Forms.Application]::ExecutablePath)
	}
	
	$NotifyIcon.ShowBalloonTip($Timeout, $BalloonTipTitle, $BalloonTipText, $BalloonTipIcon)
}




<#
	.SYNOPSIS
		Sets the emulation of the WebBrowser control for the application.
	
	.DESCRIPTION
		Sets the emulation of the WebBrowser control for the application using the installed version of IE.
		This improves the WebBrowser control compatibility with newer html features.
	
	.PARAMETER ExecutableName
		The name of the executable E.g. PowerShellStudio.exe.
		Default Value: The running executable name.
	
	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation

	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation PowerShell.exe
#>
function Set-WebBrowserEmulation
{
	param
	(
		[ValidateNotNullOrEmpty()]
		[string]$ExecutableName = [System.IO.Path]::GetFileName([System.Diagnostics.Process]::GetCurrentProcess().MainModule.FileName)
	)
	
	#region Get IE Version
	$valueNames = 'svcVersion', 'svcUpdateVersion', 'Version', 'W2kVersion'
	
	$version = 0;
	for ($i = 0; $i -lt $valueNames.Length; $i++)
	{
		$objVal = [Microsoft.Win32.Registry]::GetValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer', $valueNames[$i], '0')
		$strVal = [System.Convert]::ToString($objVal)
		if ($strVal)
		{
			$iPos = $strVal.IndexOf('.')
			if ($iPos -gt 0)
			{
				$strVal = $strVal.Substring(0, $iPos)
			}
			
			$res = 0;
			if ([int]::TryParse($strVal, [ref]$res))
			{
				$version = [Math]::Max($version, $res)
			}
		}
	}
	
	if ($version -lt 7)
	{
		$version = 7000
	}
	else
	{
		$version = $version * 1000
	}
	#endregion
	
	[Microsoft.Win32.Registry]::SetValue('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION', $ExecutableName, $version)
}



function Update-ComboBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.
	
	.PARAMETER ComboBox
		The ComboBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ComboBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red" -Append
		Update-ComboBox $combobox1 "White" -Append
		Update-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Update-ComboBox $combobox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ComboBox]$ComboBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ComboBox.Items.Clear()
	}
	
	if ($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ComboBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ComboBox.Items.Add($obj)
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	if ($ValueMember)
	{
		$ComboBox.ValueMember = $ValueMember
	}
}



function Get-CheckedNode
{
<#
	.SYNOPSIS
		This function collects a list of checked nodes in a TreeView

	.DESCRIPTION
		This function collects a list of checked nodes in a TreeView

	.PARAMETER  $NodeCollection
		The collection of nodes to search

	.PARAMETER  $CheckedNodes
		The ArrayList that will contain the all the checked items
	
	.EXAMPLE
		$CheckedNodes = New-Object System.Collections.ArrayList
		Get-CheckedNode $treeview1.Nodes $CheckedNodes
		foreach($node in $CheckedNodes)
		{	
			Write-Host $node.Text
		}
#>
	param (
		[ValidateNotNull()]
		[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
		[ValidateNotNull()]
		[System.Collections.ArrayList]$CheckedNodes
	)
	
	foreach ($Node in $NodeCollection)
	{
		if ($Node.Checked)
		{
			[void]$CheckedNodes.Add($Node)
		}
		Get-CheckedNode $Node.Nodes $CheckedNodes
	}
}



function Update-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The DataGridView control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the DataGridView's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	.PARAMETER AutoSizeColumns
	    Resizes DataGridView control's columns after loading the items.
	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		$Item,
		[Parameter(Mandatory = $false)]
		[string]$DataMember,
		[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($null -eq $Item)
	{
		$DataGridView.DataSource = $null
	}
	elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
	{
		$DataGridView.DataSource = $Item.Tables[0]
	}
	elseif ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView])
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{
			$array.Add($Item)
		}
		$DataGridView.DataSource = $array
	}
	
	if ($AutoSizeColumns -ne 'None')
	{
		$DataGridView.AutoResizeColumns($AutoSizeColumns)
	}
	
	$DataGridView.ResumeLayout()
}



function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterCIMProperties
			This switch removes CIM properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param (
		$InputObject,
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterCIMProperties)
	
	if ($null -eq $Table)
	{
		$Table = New-Object System.Data.DataTable
	}
	
	if ($null -eq $InputObject)
	{
		$Table.Clear()
		return @( ,$Table)
	}
	
	if ($InputObject -is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
	{
		$Table = $InputObject.Tables[0]
	}
	else
	{
		if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()
			
			if ($null -eq $InputObject) { return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach ($item in $InputObject)
			{
				if ($null -ne $item)
				{
					$object = $item
					break
				}
			}
			
			if ($null -eq $object) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if (-not $FilterCIMProperties -or -not $prop.Name.StartsWith('__')) #filter out CIM properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if ($null -ne $prop.Value)
					{
						try { $type = $prop.Value.GetType() }
						catch { Out-Null }
					}
					
					if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
						[void]$table.Columns.Add($prop.Name, $type)
					}
					else #Type info not found
					{
						[void]$table.Columns.Add($prop.Name)
					}
				}
			}
			
			if ($object -is [System.Data.DataRow])
			{
				foreach ($item in $InputObject)
				{
					$Table.Rows.Add($item)
				}
				return @( ,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()
		}
		
		foreach ($item in $InputObject)
		{
			$row = $table.NewRow()
			
			if ($item)
			{
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if ($table.Columns.Contains($prop.Name))
					{
						$row.Item($prop.Name) = $prop.Value
					}
				}
			}
			[void]$table.Rows.Add($row)
		}
	}
	
	return @( ,$Table)
}



function Update-ListBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ListBox or CheckedListBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ListBox control.
	
	.PARAMETER ListBox
		The ListBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ListBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ListBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ListBox $ListBox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ListBox $listBox1 "Red" -Append
		Update-ListBox $listBox1 "White" -Append
		Update-ListBox $listBox1 "Blue" -Append
	
	.EXAMPLE
		Update-ListBox $listBox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ListBox]$ListBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ListBox.Items.Clear()
	}
	
	if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
	{
		$ListBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ListBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ListBox.Items.Add($obj)
		}
		$ListBox.EndUpdate()
	}
	else
	{
		$ListBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ListBox.DisplayMember = $DisplayMember
	}
	if ($ValueMember)
	{
		$ListBox.ValueMember = $ValueMember
	}
}


#endregion

$config_listbox_SelectedIndexChanged = {
	#TODO: Place custom script here
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
	}
	catch
	{
		#Error handling here
	}
	
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -eq $config_listbox.SelectedItem)
		{
			$config_customername_textbox.text = $cis.customername
			$config_logfoldertarger_textbox.text = $cis.logfoldertarget;
			$config_packagefolder_textbox.text = $cis.packagefolder;
			$config_download_folder_textbox3.Text = $cis.downloadpath
			$config_buildingblocks_textbox3.Text = $cis.buildingblockspath
			if ($cis.downloadpath -like 'Enter UNC or local path for the download Package folder. (Evergreen / Winget)')
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download folder was added to config. Please use this tool or edit "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" ', 'Please add Download folder') # Casting the method to [void] suppresses the output. 
			}
			
			try
			{
				New-Variable -Name 'config_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_customername' -Value $cis.customername -Scope Script
			}
			try
			{
				New-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
			}
			try
			{
				New-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script
			}
			try
			{
				New-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script
			}
			try
			{
				New-Variable -Name 'config_buildingblockspath' -Value $cis.buildingblockspath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_buildingblockspath' -Value $cis.buildingblockspath -Scope Script
			}
		
			$toolstripstatuslabel1.Text = "Selected Customer: $config_customername"
		}
	}
	
}



$config_new_button_Click = {
	#TODO: Place custom script here
	$config_customername_textbox.text = "Enter Customer name here"
	$config_logfoldertarger_textbox.text = "Enter log directory used by scripting on target; Example c:\ProgramData\customername\logs"
	$config_packagefolder_textbox.text = "Enter local path where packages & scripts will be stored; Example c:\sources\"
	$config_download_folder_textbox3.Text = "Enter UNC or local path for the download Package folder. (Evergreen / Winget)"
	$config_buildingblocks_textbox3.Text = "Enter local path where Building Blocks will be stored; Example c:\BuildingBlocks\"
}

$tools_winget_search_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $true
	$tools_datagridview1.Visible = $true
	$tools_Output_textbox1.Enabled = $false
	$tools_Output_textbox1.Visible = $false
	
	
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$tools_wsearchstring = $tools_search_winget_textbox.text
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			
			$tools_datagridview1.DataSource = $table;
		}
		
	}
	
}

$tools_show_winget_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	<#
	$winget_exe = Resolve-Path "\Microsoft.DesktopAppInstaller_1.19.10173.0_x64__8wekyb3d8bbwe\winget.exe"
	if ($winget_exe.count -gt 1)
	{
		$winget_exe = $winget_exe[-1].Path
	}
	
	if (!$winget_exe)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Install winget", 'No Winget found') # Casting the method to [void] suppresses the output. 
	}
	
	#>
	$tools_winget_show_string = $tools_show_winget.text
	$tools_winget_id = winget show $tools_winget_show_string --accept-source-agreements
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
}

$tools_show_winget_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_locale_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$winget_locale_label.Enabled = $true
		$winget_locale_label.Visible = $true
		$Winget_locale_textbox.Enabled = $true
		$Winget_locale_textbox.Visible = $true
	}
	else
	{
		$winget_locale_label.Enabled = $false
		$winget_locale_label.Visible = $false
		$Winget_locale_textbox.Enabled = $false
		$Winget_locale_textbox.Visible = $false
	}
}

$Winget_locale_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_version_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$winget_version_label1.Enabled = $true
		$winget_version_label1.Visible = $true
		$winget_version_textbox1.Enabled = $true
		$winget_version_textbox1.Visible = $true
	}
	else
	{
		$winget_version_label1.Enabled = $false
		$winget_version_label1.Visible = $false
		$winget_version_textbox1.Enabled = $false
		$winget_version_textbox1.Visible = $false
	}
}

$tools_versions_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_winget_show_versions_button_Click = {
	
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_winget_show_string = $tools_versions_winget_textbox.text
	$tools_winget_id = winget show $tools_winget_show_string --versions --accept-source-agreements
	
	
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
	
}

$exe_open_sourcedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$exepnaam\$exeversie\source"
}

$msi_labelPackageName_Click = {
	#TODO: Place custom script here
	
}


$tools_search_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_search_output_button1_Click = {
	#TODO: Place custom script here
	
}

$deP_label3_Click = {
	#TODO: Place custom script here
	
}

$tools_tabpage7_Click = {
	#TODO: Place custom script here
	
}

$upload_checkboxSetupAssignmentLikeP_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllDevice_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllUsers_CheckedChanged = {
	#TODO: Place custom script here
	
}

$Upload_beschikbaar_all_users_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$weblink_ico_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$shortcut_openfiledialog1.ShowDialog()
	[string]$ICO_org_path = $shortcut_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	Copy-Item -Path $ICO_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\$weblinkName.ico" -ErrorAction Stop
	
	$weblink_output_textbox1.AppendText("*.ICO now available in source directory `r`n")
	$weblink_ico_label1.text = $shortcut_openfiledialog1.SafeFileName
	$weblink_ico_label1.Visible = $true;
	$weblink_ico_label1.Enabled = $true;
	$weblink_logo_png_button1.Visible = $true
	$weblink_logo_png_button1.Enabled = $true
	$weblink_output_textbox1.AppendText("Now upload *.png file `r`n")
	
	
	
	
}

$weblink_create_intunewin_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\" -s "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -o "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\" -q
	Rename-Item -Path "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\install.intunewin" -NewName "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkPackageName.intunewin"
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\"
	$weblink_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkName.intunewin")
	$weblink_output_textbox1.AppendText("`r`n")
	
	$weblink_output_textbox1.AppendText("Install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$weblink_output_textbox1.AppendText("un-install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$weblink_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$weblinkPackageName\"
	$regkeyApp
	$weblink_output_textbox1.AppendText("$regkeyApp `r`n")
	$weblink_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$weblink_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: $weblinkVersion `r`n")
	$weblink_output_textbox1.AppendText("Please reopen tool to make another Weblink package `r`n")
	
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$weblinkPackageName.intunewin"
			DisplayName   = $weblinkPackageName
			Publisher	  = $config_customername
			AppVersion    = $weblinkVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\config.csv" -NoTypeInformation
	$weblink_output_textbox1.AppendText("Config.csv written to: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\\config.csv")
	$weblink_output_textbox1.AppendText("  `r`n")
	$weblink_output_textbox1.AppendText("Use config file to upload package to Intune. `r`n")
	
}

$config_delete_button1_Click = {
	#TODO: Place custom script here
	
	$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$config_customerinfo = $null;
	Remove-Item "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -Confirm:$false
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -ne $config_listbox.SelectedItem)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername    = $cis.customername
					logfoldertarget = $cis.logfoldertarget
					packagefolder   = $cis.packagefolder
					downloadpath    = $cis.downloadpath
					buildingblockspath = $cis.buildingblockspath
				})
		}
		
		
	}
	
	
	
	
	
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation
	$config_listbox.Items.Clear()
	
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$weblink_logo_png_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblink_logo_openfiledialog1.ShowDialog()
	[string]$weblinkLogo_org_path = $weblink_logo_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	Copy-Item -Path $weblinkLogo_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\output\logo.png" -ErrorAction Stop
	$weblink_output_textbox1.AppendText("Logo.PNG now available in Output directory `r`n")
	$weblink_png_label1.text = $weblink_logo_openfiledialog1.SafeFileName
	$weblink_png_label1.Enabled = $true
	$weblink_png_label1.Visible = $true
	$weblink_create_scripts_button1.Enabled = $true
	$weblink_create_scripts_button1.Visible = $true
	$weblink_output_textbox1.AppendText("Click Create scripts to create install.ps1 and uninstall.ps1 `r`n")
}

$weblink_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$weblink_create_scripts_button1_Click = {
	#TODO: Place custom script here
	$weblink_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}


#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will now copy ICO file"
	Copy-Item "$Name.ico" "$logdir\ico\$Name.ico" -confirm:$false
	Write-Host "Script will now create extra folder in startmenu (when needed)"
  if (!(Test-Path -Path $location))
{
	
	New-Item -ItemType Directory -Path $location
}

	Write-Host "Script will now create shortcut"
	fCreateShortcut -TargetFile $browser -shortcutName $Name -ShortcutArguments $URL -icon "$logdir\ico\$Name.ico" -programmenu $location
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	$weblink_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Gebruik: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType Dword
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType Dword
	}
}
function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}




#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will remove ICO file and Lnk file"
	Remove-Item $logdir\ico\$Name.ico -confirm:$false
	Remove-Item $location\$Name.lnk -confirm:$false
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkICOFile = "$weblinkName.ico"
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_installFile = $weblink_installFile.Replace("!!packagename!!", $weblinkPackageName)
	$weblink_installFile = $weblink_installFile.Replace("!!Name!!", $weblinkName)
	$weblink_installFile = $weblink_installFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_installFile = $weblink_installFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_installFile = $weblink_installFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_installFile = $weblink_installFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_installFile = $weblink_installFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_installFile = $weblink_installFile.Replace("!!logdir!!", $logdir)
	$weblink_installFile = $weblink_installFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!packagename", $weblinkPackageName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Name!!", $weblinkName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!logdir!!", $logdir)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_installFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$weblink_uninstallFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1" -force
	$weblink_output_textbox1.AppendText("Install.ps1 and uninstall.ps1 created `r`n")
	$weblink_output_textbox1.AppendText("You can now test install and uninstall `r`n")
	$weblink_output_textbox1.AppendText("You can save changes in script if needed `r`n")
	$weblink_output_textbox1.AppendText("Then create Intunewin file`r`n")
	$weblink_test_install_button1.Visible = $true
	$weblink_test_install_button1.Enabled = $true
	$weblink_test_uninstall_button1.Visible = $true
	$weblink_test_uninstall_button1.Enabled = $true
	$weblink_create_intunewin_button1.Visible = $true
	$weblink_create_intunewin_button1.Enabled = $true
	
}



$weblink_create_packagedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$weblinkName = $weblink_packagename.Text
	$weblinkName = $weblinkName -replace (" ", "")
	$weblink_packagename.Text = $weblinkName
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"
	}
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"
	}
	$weblink_output_textbox1.Text = "`nNew package direcotory created: `r`n"
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkName\$weblinkVersion\")
	$weblink_output_textbox1.AppendText(" `r`n")
	$weblink_output_textbox1.AppendText("Now Upload *.ICO file `r`n")
	$weblink_ico_button1.Enabled = $true
	$weblink_ico_button1.Visible = $true
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_browser_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_location_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_url_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_Name_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$weblink_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$helpbutton1_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://github.com/rink-turksma/IntunePrepTool'
}

$winget_displayname_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_create_scripts_button1_Click = {
	#TODO: Place custom script here
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$version = $versie_textbox2.Text
		if ($version -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			$wid = $winget_WingetID_textbox1.text
			$DisplayName = $winget_displayname_textbox1.text
			$fid = $config_packagefolder
			if ($winget_locale_checkbox1.Checked -eq $true)
			{
				$wlo = $Winget_locale_textbox.text
				
			}
			else { $wlo = $null; }
			if ($winget_version_checkbox.Checked -eq $true)
			{
				$wve = $winget_version_textbox1.text
			}
			else { $wve = $null; }
			$WinGetID = $wid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			$outputDirectory = $fid
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	13-9-2025 11:16
	 Created by:   	Rink Turksma
	 Organization: 	https://intunepreptool.com
	 Filename:     	Winget_install_uninstall.ps1
	===========================================================================
#>
# Variables will be provided from IntunePrepTool
$WinGetID = "!!WinGetID!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$version = "!!version!!"
$locale = "!!locale!!"
$localeSelected = "!!localeSelected!!"
$versionWinget = "!!versionWinget!!"
$versionWingetSelected = "!!versionSelected!!"
$includeWingetRequirment = "!!includeWingetRequirment!!"
#Dyn vars
$regApp1 = $DisplayName
$logfile = $(Join-Path $logdir  "$DisplayName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null;
#Creates logdirectory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Create registry application key.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Start Powershell functions
function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution.
	### Ultimately, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $True
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functies
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}



#Start Transcript.  Will be saved under  $logdir.
Start-Transcript -Path $logfile
$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($ResolveWingetPath)
{
	$WingetPath = $ResolveWingetPath[-1].Path
	$wingetexe = $WingetPath
}


if (Test-path $WingetPath -ErrorAction SilentlyContinue)
{
	
	Write-Host "We are now checking the version of Winget"
	$wingetOption = 1
	$versionW = & $wingetexe --version
	Write-Host $versionW
}
else
{
	Write-Host "We are now checking the version of Winget"
	$wingetOption = 2
	$versionW = winget --version
	write-host $versionW
}


if ($versionW -notlike 'v*')
{
	Write-Host "Winget Version does not match.. installing now"
	[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
	$msixUrl = "https://github.com/microsoft/winget-cli/releases/download/v1.11.430/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
	$msixPath = "$($env:TEMP)\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
	(New-Object System.Net.WebClient).DownloadFile($msixUrl, $msixPath)
	
	try
	{
		Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
		Write-Host "Winget installation completed successfully."
	}
	catch
	{
		if ($_.Exception.Message -match "Microsoft.VCLibs.140.00.UWPDesktop")
		{
			Write-Host "Now downloading: Missing dependency 'Microsoft.VCLibs.140.00.UWPDesktop'."
			[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
			$dependencyURL = 'https://github.com/microsoft/winget-cli/releases/download/v1.11.430/DesktopAppInstaller_Dependencies.zip'
			$dependencyPath = "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
			(New-Object System.Net.WebClient).DownloadFile($dependencyURL, $dependencyPath)
			unblock-file "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
			Expand-Archive -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip" -DestinationPath "$($env:TEMP)\DesktopAppInstaller_Dependencies"
			write-host "Now installing dependency"
			try
			{
				Add-AppxPackage -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies\x64\Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64.appx" -ErrorAction Stop
				write-host "Installing depedency done"
			}
			catch
			{
				Write-host "Installing depedency failed"
				Write-Host "An unexpected error occurred: $($_.Exception.Message)"
			}
			try
			{
				write-host "Now trying to install Winget again"
				Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
				write-host "Install winget done"
			}
			catch
			{
				Write-Host "An unexpected error occurred: $($_.Exception.Message)"
			}
		}
		else
		{
			Write-Host "An unexpected error occurred: $($_.Exception.Message)"
		}
	}
	$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
	if ($ResolveWingetPath)
	{
		$WingetPath = $ResolveWingetPath[-1].Path
	}
	$wingetexe = $WingetPath
	
	if (Test-path $wingetexe)
	{
		
		Write-Host "We are now checking the version of Winget"
		$wingetOption = 1
		$versionW = & $wingetexe --version
		Write-Host $versionW
	}
	else
	{
		Write-Host "We are now checking the version of Winget"
		$wingetOption = 2
		$versionW = winget --version
		write-host $versionW
	}
}
else
{
	write-host "Winget already active"
}
$loglocation = 'C:\Windows\Temp\intunepreptoolwinget.txt'
if (Test-Path $loglocation) { Remove-Item $loglocation -Confirm:$false }
$TreatAsSuccessCodes = @(
	-1978335189, # 0x8A15002B UPDATE_NOT_APPLICABLE
	-1978335153, # 0x8A15004F UPGRADE_VERSION_NOT_NEWER
	-1978335135 # 0x8A150061 PACKAGE_ALREADY_INSTALLED
)


$BenignVerbatim = @(
	'No applicable upgrade found',
	'Found an existing package already installed'
)


$PatternRules = New-Object System.Collections.ArrayList

function ConvertTo-RegexFromPhrase
{
	param ([Parameter(Mandatory)]
		[string]$Text)
	if ([string]::IsNullOrWhiteSpace($Text)) { return $null }
	$escaped = [regex]::Escape($Text)
	$escaped = $escaped -replace '\\\s+', '\s+' -replace '\s+', '\s+'
	return "(?i)$escaped"
}

function Add-Rule
{
	param (
		[Parameter(Mandatory)]
		[System.Collections.IList]$Rules,
		[Parameter(Mandatory)]
		[string]$Regex,
		[Parameter(Mandatory)]
		[string]$Description,
		[Parameter(Mandatory)]
		[bool]$TreatAsSuccess
	)
	if ($null -eq $Rules) { throw "Rules list is null." }
	if ([string]::IsNullOrWhiteSpace($Regex)) { return }
	[void]$Rules.Add([pscustomobject]@{
			Regex		   = $Regex
			Description    = $Description
			TreatAsSuccess = $TreatAsSuccess
		})
}
function Convert-ToHex32
{
	param ([Parameter(Mandatory)]
		[object]$Value)
	
	$v = [int64]$Value
	$mask = 0x00000000FFFFFFFF # this is a positive Int64 (4294967295)
	$n = $v -band $mask # low 32 bits as a non-negative Int64
	
	return ('0x{0:X8}' -f $n)
}
function Write-Log
{
	param ([string]$Path,
		[string]$Message)
	Add-Content -Path $Path -Value $Message -Encoding UTF8
}


$WingetErrorCatalog = [ordered]@{
	-1978335231 = @{ Hex = '0x8A150001'; Symbol = 'APPINSTALLER_CLI_ERROR_INTERNAL_ERROR'; Description = 'Internal Error' }
	-1978335230 = @{ Hex = '0x8A150002'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_CL_ARGUMENTS'; Description = 'Invalid command line arguments' }
	-1978335229 = @{ Hex = '0x8A150003'; Symbol = 'APPINSTALLER_CLI_ERROR_COMMAND_FAILED'; Description = 'Executing command failed' }
	-1978335228 = @{ Hex = '0x8A150004'; Symbol = 'APPINSTALLER_CLI_ERROR_MANIFEST_FAILED'; Description = 'Opening manifest failed' }
	-1978335227 = @{ Hex = '0x8A150005'; Symbol = 'APPINSTALLER_CLI_ERROR_CTRL_SIGNAL_RECEIVED'; Description = 'Cancellation signal received' }
	-1978335226 = @{ Hex = '0x8A150006'; Symbol = 'APPINSTALLER_CLI_ERROR_SHELLEXEC_INSTALL_FAILED'; Description = 'Running ShellExecute failed' }
	-1978335225 = @{ Hex = '0x8A150007'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_MANIFESTVERSION'; Description = 'Cannot process manifest. The manifest version is higher than supported. Please update the client.' }
	-1978335224 = @{ Hex = '0x8A150008'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_FAILED'; Description = 'Downloading installer failed' }
	-1978335223 = @{ Hex = '0x8A150009'; Symbol = 'APPINSTALLER_CLI_ERROR_CANNOT_WRITE_TO_UPLEVEL_INDEX'; Description = 'Cannot write to index; it is a higher schema version' }
	-1978335222 = @{ Hex = '0x8A15000A'; Symbol = 'APPINSTALLER_CLI_ERROR_INDEX_INTEGRITY_COMPROMISED'; Description = 'The index is corrupt' }
	-1978335221 = @{ Hex = '0x8A15000B'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCES_INVALID'; Description = 'The configured source information is corrupt' }
	-1978335220 = @{ Hex = '0x8A15000C'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NAME_ALREADY_EXISTS'; Description = 'The source name is already configured' }
	-1978335219 = @{ Hex = '0x8A15000D'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_SOURCE_TYPE'; Description = 'The source type is invalid' }
	-1978335218 = @{ Hex = '0x8A15000E'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_IS_BUNDLE'; Description = 'The MSIX file is a bundle, not a package' }
	-1978335217 = @{ Hex = '0x8A15000F'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_DATA_MISSING'; Description = 'Data required by the source is missing' }
	-1978335216 = @{ Hex = '0x8A150010'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICABLE_INSTALLER'; Description = 'None of the installers are applicable for the current system' }
	-1978335215 = @{ Hex = '0x8A150011'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_HASH_MISMATCH'; Description = "The installer file's hash does not match the manifest" }
	-1978335214 = @{ Hex = '0x8A150012'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NAME_DOES_NOT_EXIST'; Description = 'The source name does not exist' }
	-1978335213 = @{ Hex = '0x8A150013'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_ARG_ALREADY_EXISTS'; Description = 'The source location is already configured under another name' }
	-1978335212 = @{ Hex = '0x8A150014'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICATIONS_FOUND'; Description = 'No packages found' }
	-1978335211 = @{ Hex = '0x8A150015'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_SOURCES_DEFINED'; Description = 'No sources are configured' }
	-1978335210 = @{ Hex = '0x8A150016'; Symbol = 'APPINSTALLER_CLI_ERROR_MULTIPLE_APPLICATIONS_FOUND'; Description = 'Multiple packages found matching the criteria' }
	-1978335209 = @{ Hex = '0x8A150017'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_MANIFEST_FOUND'; Description = 'No manifest found matching the criteria' }
	-1978335208 = @{ Hex = '0x8A150018'; Symbol = 'APPINSTALLER_CLI_ERROR_EXTENSION_PUBLIC_FAILED'; Description = 'Failed to get Public folder from source package' }
	-1978335207 = @{ Hex = '0x8A150019'; Symbol = 'APPINSTALLER_CLI_ERROR_COMMAND_REQUIRES_ADMIN'; Description = 'Command requires administrator privileges to run' }
	-1978335206 = @{ Hex = '0x8A15001A'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NOT_SECURE'; Description = 'The source location is not secure' }
	-1978335205 = @{ Hex = '0x8A15001B'; Symbol = 'APPINSTALLER_CLI_ERROR_MSSTORE_BLOCKED_BY_POLICY'; Description = 'The Microsoft Store client is blocked by policy' }
	-1978335204 = @{ Hex = '0x8A15001C'; Symbol = 'APPINSTALLER_CLI_ERROR_MSSTORE_APP_BLOCKED_BY_POLICY'; Description = 'The Microsoft Store app is blocked by policy' }
	-1978335203 = @{ Hex = '0x8A15001D'; Symbol = 'APPINSTALLER_CLI_ERROR_EXPERIMENTAL_FEATURE_DISABLED'; Description = 'The feature is currently under development. It can be enabled using winget settings.' }
	-1978335202 = @{ Hex = '0x8A15001E'; Symbol = 'APPINSTALLER_CLI_ERROR_MSSTORE_INSTALL_FAILED'; Description = 'Failed to install the Microsoft Store app' }
	-1978335201 = @{ Hex = '0x8A15001F'; Symbol = 'APPINSTALLER_CLI_ERROR_COMPLETE_INPUT_BAD'; Description = 'Failed to perform auto complete' }
	-1978335200 = @{ Hex = '0x8A150020'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INIT_FAILED'; Description = 'Failed to initialize YAML parser' }
	-1978335199 = @{ Hex = '0x8A150021'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_MAPPING_KEY'; Description = 'Encountered an invalid YAML key' }
	-1978335198 = @{ Hex = '0x8A150022'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_DUPLICATE_MAPPING_KEY'; Description = 'Encountered a duplicate YAML key' }
	-1978335197 = @{ Hex = '0x8A150023'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_OPERATION'; Description = 'Invalid YAML operation' }
	-1978335196 = @{ Hex = '0x8A150024'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_DOC_BUILD_FAILED'; Description = 'Failed to build YAML doc' }
	-1978335195 = @{ Hex = '0x8A150025'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_EMITTER_STATE'; Description = 'Invalid YAML emitter state' }
	-1978335194 = @{ Hex = '0x8A150026'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_DATA'; Description = 'Invalid YAML data' }
	-1978335193 = @{ Hex = '0x8A150027'; Symbol = 'APPINSTALLER_CLI_ERROR_LIBYAML_ERROR'; Description = 'LibYAML error' }
	-1978335192 = @{ Hex = '0x8A150028'; Symbol = 'APPINSTALLER_CLI_ERROR_MANIFEST_VALIDATION_WARNING'; Description = 'Manifest validation succeeded with warning' }
	-1978335191 = @{ Hex = '0x8A150029'; Symbol = 'APPINSTALLER_CLI_ERROR_MANIFEST_VALIDATION_FAILURE'; Description = 'Manifest validation failed' }
	-1978335190 = @{ Hex = '0x8A15002A'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_MANIFEST'; Description = 'Manifest is invalid' }
	-1978335189 = @{ Hex = '0x8A15002B'; Symbol = 'APPINSTALLER_CLI_ERROR_UPDATE_NOT_APPLICABLE'; Description = 'No applicable update found' }
	-1978335188 = @{ Hex = '0x8A15002C'; Symbol = 'APPINSTALLER_CLI_ERROR_UPDATE_ALL_HAS_FAILURE'; Description = 'winget upgrade --all completed with failures' }
	-1978335187 = @{ Hex = '0x8A15002D'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_SECURITY_CHECK_FAILED'; Description = 'Installer failed security check' }
	-1978335186 = @{ Hex = '0x8A15002E'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_SIZE_MISMATCH'; Description = 'Download size does not match expected content length' }
	-1978335185 = @{ Hex = '0x8A15002F'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_UNINSTALL_INFO_FOUND'; Description = 'Uninstall command not found' }
	-1978335184 = @{ Hex = '0x8A150030'; Symbol = 'APPINSTALLER_CLI_ERROR_EXEC_UNINSTALL_COMMAND_FAILED'; Description = 'Running uninstall command failed' }
	-1978335183 = @{ Hex = '0x8A150031'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_BREAK_ITERATOR_ERROR'; Description = 'ICU break iterator error' }
	-1978335182 = @{ Hex = '0x8A150032'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_CASEMAP_ERROR'; Description = 'ICU casemap error' }
	-1978335181 = @{ Hex = '0x8A150033'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_REGEX_ERROR'; Description = 'ICU regex error' }
	-1978335180 = @{ Hex = '0x8A150034'; Symbol = 'APPINSTALLER_CLI_ERROR_IMPORT_INSTALL_FAILED'; Description = 'Failed to install one or more imported packages' }
	-1978335179 = @{ Hex = '0x8A150035'; Symbol = 'APPINSTALLER_CLI_ERROR_NOT_ALL_PACKAGES_FOUND'; Description = 'Could not find one or more requested packages' }
	-1978335178 = @{ Hex = '0x8A150036'; Symbol = 'APPINSTALLER_CLI_ERROR_JSON_INVALID_FILE'; Description = 'Json file is invalid' }
	-1978335177 = @{ Hex = '0x8A150037'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NOT_REMOTE'; Description = 'The source location is not remote' }
	-1978335176 = @{ Hex = '0x8A150038'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_RESTSOURCE'; Description = 'The configured rest source is not supported' }
	-1978335175 = @{ Hex = '0x8A150039'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTSOURCE_INVALID_DATA'; Description = 'Invalid data returned by rest source' }
	-1978335174 = @{ Hex = '0x8A15003A'; Symbol = 'APPINSTALLER_CLI_ERROR_BLOCKED_BY_POLICY'; Description = 'Operation is blocked by Group Policy' }
	-1978335173 = @{ Hex = '0x8A15003B'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTAPI_INTERNAL_ERROR'; Description = 'Rest API internal error' }
	-1978335172 = @{ Hex = '0x8A15003C'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTSOURCE_INVALID_URL'; Description = 'Invalid rest source url' }
	-1978335171 = @{ Hex = '0x8A15003D'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTAPI_UNSUPPORTED_MIME_TYPE'; Description = 'Unsupported MIME type returned by rest API' }
	-1978335170 = @{ Hex = '0x8A15003E'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTSOURCE_INVALID_VERSION'; Description = 'Invalid rest source contract version' }
	-1978335169 = @{ Hex = '0x8A15003F'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_DATA_INTEGRITY_FAILURE'; Description = 'The source data is corrupted or tampered' }
	-1978335168 = @{ Hex = '0x8A150040'; Symbol = 'APPINSTALLER_CLI_ERROR_STREAM_READ_FAILURE'; Description = 'Error reading from the stream' }
	-1978335167 = @{ Hex = '0x8A150041'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_AGREEMENTS_NOT_ACCEPTED'; Description = 'Package agreements were not agreed to' }
	-1978335166 = @{ Hex = '0x8A150042'; Symbol = 'APPINSTALLER_CLI_ERROR_PROMPT_INPUT_ERROR'; Description = 'Error reading input in prompt' }
	-1978335165 = @{ Hex = '0x8A150043'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_SOURCE_REQUEST'; Description = 'The search request is not supported by one or more sources' }
	-1978335164 = @{ Hex = '0x8A150044'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTAPI_ENDPOINT_NOT_FOUND'; Description = 'The rest API endpoint is not found.' }
	-1978335163 = @{ Hex = '0x8A150045'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_OPEN_FAILED'; Description = 'Failed to open the source.' }
	-1978335162 = @{ Hex = '0x8A150046'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_AGREEMENTS_NOT_ACCEPTED'; Description = 'Source agreements were not agreed to' }
	-1978335161 = @{ Hex = '0x8A150047'; Symbol = 'APPINSTALLER_CLI_ERROR_CUSTOMHEADER_EXCEEDS_MAXLENGTH'; Description = 'Header size exceeds the allowable limit of 1024 characters. Please reduce the size and try again.' }
	-1978335160 = @{ Hex = '0x8A150048'; Symbol = 'APPINSTALLER_CLI_ERROR_MISSING_RESOURCE_FILE'; Description = 'Missing resource file' }
	-1978335159 = @{ Hex = '0x8A150049'; Symbol = 'APPINSTALLER_CLI_ERROR_MSI_INSTALL_FAILED'; Description = 'Running MSI install failed' }
	-1978335158 = @{ Hex = '0x8A15004A'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_MSIEXEC_ARGUMENT'; Description = 'Arguments for msiexec are invalid' }
	-1978335157 = @{ Hex = '0x8A15004B'; Symbol = 'APPINSTALLER_CLI_ERROR_FAILED_TO_OPEN_ALL_SOURCES'; Description = 'Failed to open one or more sources' }
	-1978335156 = @{ Hex = '0x8A15004C'; Symbol = 'APPINSTALLER_CLI_ERROR_DEPENDENCIES_VALIDATION_FAILED'; Description = 'Failed to validate dependencies' }
	-1978335155 = @{ Hex = '0x8A15004D'; Symbol = 'APPINSTALLER_CLI_ERROR_MISSING_PACKAGE'; Description = 'One or more package is missing' }
	-1978335154 = @{ Hex = '0x8A15004E'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_TABLE_COLUMN'; Description = 'Invalid table column' }
	-1978335153 = @{ Hex = '0x8A15004F'; Symbol = 'APPINSTALLER_CLI_ERROR_UPGRADE_VERSION_NOT_NEWER'; Description = 'The upgrade version is not newer than the installed version' }
	-1978335152 = @{ Hex = '0x8A150050'; Symbol = 'APPINSTALLER_CLI_ERROR_UPGRADE_VERSION_UNKNOWN'; Description = 'Upgrade version is unknown and override is not specified' }
	-1978335151 = @{ Hex = '0x8A150051'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_CONVERSION_ERROR'; Description = 'ICU conversion error' }
	-1978335150 = @{ Hex = '0x8A150052'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_INSTALL_FAILED'; Description = 'Failed to install portable package' }
	-1978335149 = @{ Hex = '0x8A150053'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_REPARSE_POINT_NOT_SUPPORTED'; Description = 'Volume does not support reparse points.' }
	-1978335148 = @{ Hex = '0x8A150054'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_PACKAGE_ALREADY_EXISTS'; Description = 'Portable package from a different source already exists.' }
	-1978335147 = @{ Hex = '0x8A150055'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_SYMLINK_PATH_IS_DIRECTORY'; Description = 'Unable to create symlink, path points to a directory.' }
	-1978335146 = @{ Hex = '0x8A150056'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_PROHIBITS_ELEVATION'; Description = 'The installer cannot be run from an administrator context.' }
	-1978335145 = @{ Hex = '0x8A150057'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_UNINSTALL_FAILED'; Description = 'Failed to uninstall portable package' }
	-1978335144 = @{ Hex = '0x8A150058'; Symbol = 'APPINSTALLER_CLI_ERROR_ARP_VERSION_VALIDATION_FAILED'; Description = 'Failed to validate DisplayVersion values against index.' }
	-1978335143 = @{ Hex = '0x8A150059'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_ARGUMENT'; Description = 'One or more arguments are not supported.' }
	-1978335142 = @{ Hex = '0x8A15005A'; Symbol = 'APPINSTALLER_CLI_ERROR_BIND_WITH_EMBEDDED_NULL'; Description = 'Embedded null characters are disallowed for SQLite' }
	-1978335141 = @{ Hex = '0x8A15005B'; Symbol = 'APPINSTALLER_CLI_ERROR_NESTEDINSTALLER_NOT_FOUND'; Description = 'Failed to find the nested installer in the archive.' }
	-1978335140 = @{ Hex = '0x8A15005C'; Symbol = 'APPINSTALLER_CLI_ERROR_EXTRACT_ARCHIVE_FAILED'; Description = 'Failed to extract archive.' }
	-1978335139 = @{ Hex = '0x8A15005D'; Symbol = 'APPINSTALLER_CLI_ERROR_NESTEDINSTALLER_INVALID_PATH'; Description = 'Invalid relative file path to nested installer provided.' }
	-1978335138 = @{ Hex = '0x8A15005E'; Symbol = 'APPINSTALLER_CLI_ERROR_PINNED_CERTIFICATE_MISMATCH'; Description = 'The server certificate did not match any of the expected values.' }
	-1978335137 = @{ Hex = '0x8A15005F'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALL_LOCATION_REQUIRED'; Description = 'Install location must be provided.' }
	-1978335136 = @{ Hex = '0x8A150060'; Symbol = 'APPINSTALLER_CLI_ERROR_ARCHIVE_SCAN_FAILED'; Description = 'Archive malware scan failed.' }
	-1978335135 = @{ Hex = '0x8A150061'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_ALREADY_INSTALLED'; Description = 'Found at least one version of the package installed.' }
	-1978335134 = @{ Hex = '0x8A150062'; Symbol = 'APPINSTALLER_CLI_ERROR_PIN_ALREADY_EXISTS'; Description = 'A pin already exists for the package.' }
	-1978335133 = @{ Hex = '0x8A150063'; Symbol = 'APPINSTALLER_CLI_ERROR_PIN_DOES_NOT_EXIST'; Description = 'There is no pin for the package.' }
	-1978335132 = @{ Hex = '0x8A150064'; Symbol = 'APPINSTALLER_CLI_ERROR_CANNOT_OPEN_PINNING_INDEX'; Description = 'Unable to open the pin database.' }
	-1978335131 = @{ Hex = '0x8A150065'; Symbol = 'APPINSTALLER_CLI_ERROR_MULTIPLE_INSTALL_FAILED'; Description = 'One or more applications failed to install' }
	-1978335130 = @{ Hex = '0x8A150066'; Symbol = 'APPINSTALLER_CLI_ERROR_MULTIPLE_UNINSTALL_FAILED'; Description = 'One or more applications failed to uninstall' }
	-1978335129 = @{ Hex = '0x8A150067'; Symbol = 'APPINSTALLER_CLI_ERROR_NOT_ALL_QUERIES_FOUND_SINGLE'; Description = 'One or more queries did not return exactly one match' }
	-1978335128 = @{ Hex = '0x8A150068'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_IS_PINNED'; Description = 'The package has a pin that prevents upgrade.' }
	-1978335127 = @{ Hex = '0x8A150069'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_IS_STUB'; Description = 'The package currently installed is the stub package' }
	-1978335126 = @{ Hex = '0x8A15006A'; Symbol = 'APPINSTALLER_CLI_ERROR_APPTERMINATION_RECEIVED'; Description = 'Application shutdown signal received' }
	-1978335125 = @{ Hex = '0x8A15006B'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_DEPENDENCIES'; Description = 'Failed to download package dependencies.' }
	-1978335124 = @{ Hex = '0x8A15006C'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_COMMAND_PROHIBITED'; Description = 'Failed to download package. Download for offline installation is prohibited.' }
	-1978335123 = @{ Hex = '0x8A15006D'; Symbol = 'APPINSTALLER_CLI_ERROR_SERVICE_UNAVAILABLE'; Description = 'A required service is busy or unavailable. Try again later.' }
	-1978335122 = @{ Hex = '0x8A15006E'; Symbol = 'APPINSTALLER_CLI_ERROR_RESUME_ID_NOT_FOUND'; Description = 'The guid provided does not correspond to a valid resume state.' }
	-1978335121 = @{ Hex = '0x8A15006F'; Symbol = 'APPINSTALLER_CLI_ERROR_CLIENT_VERSION_MISMATCH'; Description = 'The current client version did not match the client version of the saved state.' }
	-1978335120 = @{ Hex = '0x8A150070'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_RESUME_STATE'; Description = 'The resume state data is invalid.' }
	-1978335119 = @{ Hex = '0x8A150071'; Symbol = 'APPINSTALLER_CLI_ERROR_CANNOT_OPEN_CHECKPOINT_INDEX'; Description = 'Unable to open the checkpoint database.' }
	-1978335118 = @{ Hex = '0x8A150072'; Symbol = 'APPINSTALLER_CLI_ERROR_RESUME_LIMIT_EXCEEDED'; Description = 'Exceeded max resume limit.' }
	-1978335117 = @{ Hex = '0x8A150073'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_AUTHENTICATION_INFO'; Description = 'Invalid authentication info.' }
	-1978335116 = @{ Hex = '0x8A150074'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_TYPE_NOT_SUPPORTED'; Description = 'Authentication method not supported.' }
	-1978335115 = @{ Hex = '0x8A150075'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_FAILED'; Description = 'Authentication failed.' }
	-1978335114 = @{ Hex = '0x8A150076'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_INTERACTIVE_REQUIRED'; Description = 'Authentication failed. Interactive authentication required.' }
	-1978335113 = @{ Hex = '0x8A150077'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_CANCELLED_BY_USER'; Description = 'Authentication failed. User cancelled.' }
	-1978335112 = @{ Hex = '0x8A150078'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_INCORRECT_ACCOUNT'; Description = 'Authentication failed. Authenticated account is not the desired account.' }
	-1978335111 = @{ Hex = '0x8A150079'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_REPAIR_INFO_FOUND'; Description = 'Repair command not found.' }
	-1978335110 = @{ Hex = '0x8A15007A'; Symbol = 'APPINSTALLER_CLI_ERROR_REPAIR_NOT_APPLICABLE'; Description = 'Repair operation is not applicable.' }
	-1978335109 = @{ Hex = '0x8A15007B'; Symbol = 'APPINSTALLER_CLI_ERROR_EXEC_REPAIR_FAILED'; Description = 'Repair operation failed.' }
	-1978335108 = @{ Hex = '0x8A15007C'; Symbol = 'APPINSTALLER_CLI_ERROR_REPAIR_NOT_SUPPORTED'; Description = "The installer technology in use doesn't support repair." }
	-1978335107 = @{ Hex = '0x8A15007D'; Symbol = 'APPINSTALLER_CLI_ERROR_ADMIN_CONTEXT_REPAIR_PROHIBITED'; Description = 'Repair operations involving administrator privileges are not permitted on packages installed within the user scope.' }
	-1978335106 = @{ Hex = '0x8A15007E'; Symbol = 'APPINSTALLER_CLI_ERROR_SQLITE_CONNECTION_TERMINATED'; Description = 'The SQLite connection was terminated to prevent corruption.' }
	-1978335105 = @{ Hex = '0x8A15007F'; Symbol = 'APPINSTALLER_CLI_ERROR_DISPLAYCATALOG_API_FAILED'; Description = 'Failed to get Microsoft Store package catalog.' }
	-1978335104 = @{ Hex = '0x8A150080'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICABLE_DISPLAYCATALOG_PACKAGE'; Description = 'No applicable Microsoft Store package found from Microsoft Store package catalog.' }
	-1978335103 = @{ Hex = '0x8A150081'; Symbol = 'APPINSTALLER_CLI_ERROR_SFSCLIENT_API_FAILED'; Description = 'Failed to get Microsoft Store package download information.' }
	-1978335102 = @{ Hex = '0x8A150082'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICABLE_SFSCLIENT_PACKAGE'; Description = 'No applicable Microsoft Store package download information found.' }
	-1978335101 = @{ Hex = '0x8A150083'; Symbol = 'APPINSTALLER_CLI_ERROR_LICENSING_API_FAILED'; Description = 'Failed to retrieve Microsoft Store package license.' }
	-1978335100 = @{ Hex = '0x8A150084'; Symbol = 'APPINSTALLER_CLI_ERROR_SFSCLIENT_PACKAGE_NOT_SUPPORTED'; Description = 'The Microsoft Store package does not support download command.' }
	-1978335099 = @{ Hex = '0x8A150085'; Symbol = 'APPINSTALLER_CLI_ERROR_LICENSING_API_FAILED_FORBIDDEN'; Description = 'Failed to retrieve Microsoft Store package license. The Microsoft Entra Id account does not have required privilege.' }
	-1978335098 = @{ Hex = '0x8A150086'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_ZERO_BYTE_FILE'; Description = 'Downloaded zero byte installer; ensure that your network connection is working properly.' }
}

$KnownVerbatimToCode = @{
	'No applicable upgrade found' = -1978335189
	'Found an existing package already installed' = -1978335135
	'None of the installers are applicable' = -1978335216
	'No packages found'		      = -1978335212
	'Command requires administrator privileges' = -1978335207
	'Installer failed security check' = -1978335187
	'Download size does not match' = -1978335186
	'Uninstall command not found' = -1978335185
	'Running MSI install failed'  = -1978335159
	'Failed to open the source'   = -1978335163
	'Microsoft Store.*blocked by policy' = -1978335205
}

foreach ($kvp in $KnownVerbatimToCode.GetEnumerator())
{
	$code = [int]$kvp.Value
	if ($WingetErrorCatalog.Contains($code))
	{
		$cat = $WingetErrorCatalog[$code]
		$desc = "$($cat.Description) ($($cat.Symbol))"
		$tSuccess = $TreatAsSuccessCodes -contains $code
		if ($kvp.Key -match '(?i)no applicable upgrade found|found an existing package already installed') { $tSuccess = $true }
		Add-Rule -Rules $PatternRules -Regex "(?i)$($kvp.Key)" -Description $desc -TreatAsSuccess $tSuccess
	}
}


foreach ($code in $WingetErrorCatalog.Keys)
{
	$meta = $WingetErrorCatalog[$code]
	if ($null -eq $meta -or [string]::IsNullOrWhiteSpace($meta.Description)) { continue }
	$rx = ConvertTo-RegexFromPhrase -Text $meta.Description
	if ($null -ne $rx)
	{
		$desc = "$($meta.Description) ($($meta.Symbol))"
		$tSuccess = $TreatAsSuccessCodes -contains $code
		Add-Rule -Rules $PatternRules -Regex $rx -Description $desc -TreatAsSuccess $tSuccess
	}
}
foreach ($line in $BenignVerbatim)
{
	$rx = "(?i)$([regex]::Escape($line))"
	Add-Rule -Rules $PatternRules -Regex $rx -Description "Benign outcome: $line" -TreatAsSuccess $true
}

if ($wingetOption -eq 1)
{
	$install = "!!WingetCommand!!"
	if ($install -like "!!doe*")
	{
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
		{
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
			
		}
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
		{
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
			
		}
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
		{
			
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
			
		}
		
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
		{
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
		}
		$rawExit = [int]$LASTEXITCODE
		$log = Get-Content $loglocation -Raw
		$decision = $null
		foreach ($rule in $PatternRules)
		{
			if ($log -match $rule.Regex) { $decision = $rule; break }
		}
		
		if ($decision)
		{
			if ($decision.TreatAsSuccess)
			{
				$excode = 0
			}
			else
			{
				# ensure rawExit is numeric
				$excode = if ([int]$rawExit -ne 0) { [int]$rawExit }
				else { 1 }
			}
			
			Write-Log $loglocation "`r`n[Decision] Matched pattern: $($decision.Regex)"
			Write-Log $loglocation "[Decision] TreatAsSuccess: $($decision.TreatAsSuccess)"
		}
		else
		{
			$excode = [int]$rawExit
			
			if ($WingetErrorCatalog.Contains([int]$excode))
			{
				$m = $WingetErrorCatalog[[int]$excode]
				Write-Log $loglocation "`r`n[ExitCode] $($m.Hex) ($excode) $($m.Symbol) - $($m.Description)"
				
				if ($TreatAsSuccessCodes -contains $excode)
				{
					$excode = 0
					Write-Log $loglocation "[Decision] Exit code treated as success by policy."
				}
			}
			else
			{
				$hexUnknown = Convert-ToHex32 $excode
				Write-Log $loglocation "`r`n[ExitCode] $hexUnknown ($excode) - Unknown code"
			}
		}
		Write-Host $log
		$hexOut = Convert-ToHex32 $excode
		Write-Host "ExitCode=$excode (hex $hexOut)"
		
		
		
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
		
		
	}
	else
	{
		& $wingetexe uninstall --id $WinGetID -h *>&1 |
		Tee-Object -FilePath $loglocation | Out-Null
		$rawExit = [int]$LASTEXITCODE
		$log = Get-Content $loglocation -Raw
		$decision = $null
		foreach ($rule in $PatternRules)
		{
			if ($log -match $rule.Regex) { $decision = $rule; break }
		}
		
		if ($decision)
		{
			if ($decision.TreatAsSuccess)
			{
				$excode = 0
			}
			else
			{
				# ensure rawExit is numeric
				$excode = if ([int]$rawExit -ne 0) { [int]$rawExit }
				else { 1 }
			}
			
			Write-Log $loglocation "`r`n[Decision] Matched pattern: $($decision.Regex)"
			Write-Log $loglocation "[Decision] TreatAsSuccess: $($decision.TreatAsSuccess)"
		}
		else
		{
			$excode = [int]$rawExit
			
			if ($WingetErrorCatalog.Contains([int]$excode))
			{
				$m = $WingetErrorCatalog[[int]$excode]
				Write-Log $loglocation "`r`n[ExitCode] $($m.Hex) ($excode) $($m.Symbol) - $($m.Description)"
				
				if ($TreatAsSuccessCodes -contains $excode)
				{
					$excode = 0
					Write-Log $loglocation "[Decision] Exit code treated as success by policy."
				}
			}
			else
			{
				$hexUnknown = Convert-ToHex32 $excode
				Write-Log $loglocation "`r`n[ExitCode] $hexUnknown ($excode) - Unknown code"
			}
		}

		Write-Host $log
		$hexOut = Convert-ToHex32 $excode
		Write-Host "ExitCode=$excode (hex $hexOut)"
		
		
		
		
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
	}
}
else
{
	$install = "!!WingetCommand!!"
	if ($install -like "!!doe*")
	{
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
		{
			winget -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine
			
		}
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
		{
			winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
			
		}
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
		{
			
			winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget
			
		}
		
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
		{
			winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
		}
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
		
	}
	else
	{
		winget uninstall --id $WinGetID -h
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
	}
}



if ($install -like "!!doe*")
{
	try
	{
		#Searches for startmenu items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
		
	}
	try
	{
		#Searches for Desktop items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
	
}
#### Place extra actions here:










if ($decision)
{
	write-host "[Decision] Matched pattern: $($decision.Regex)"
	Write-Host "[Decision] TreatAsSuccess: $($decision.TreatAsSuccess)"
	if ($($decision.TreatAsSuccess) -like 'False')
	{
		$excode = 1
	}
}
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
if ($excode -eq 1) { $warning = 'Error'; }
else
{
	$warning = 'Information'; if ($install -like "!!doe*") { fDetectionInRegistry -succes $true }
	else
	{
		remove-item $regkeyApp
	}
}
#End; Write Log file
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}
Else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }


'@
			$installfile = $installfile.Replace('!!WinGetID!!', $WinGetID)
			$installfile = $installfile.Replace('!!DisplayName!!', $DisplayName)
			$installfile = $installfile.Replace('!!logdir!!', $logdir)
			$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$installfile = $installfile.Replace('!!version!!', $version)
			if ($wlo -ne $null)
			{
				$installfile = $installfile.Replace('!!locale!!', $wlo)
				$installfile = $installfile.Replace("!!localeSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!localeSelected!!", $false) }
			if ($wve -ne $null)
			{
				$installfile = $installfile.Replace('!!versionWinget!!', $wve)
				$installfile = $installfile.Replace("!!versionSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!versionSelected!!", $false) }
			$installfile = $installfile.Replace('!!includeWingetRequirment!!', $includeWingetRequirment)
			
			
			
			
			$installfile = $installfile.Replace('!!WingetCommand!!', "!!doeinstall!!")
			$installFile | Out-File "$outputDirectory\$DisplayName\$version\source\install.ps1" -Force
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$DisplayName\$version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
			$installFile | Out-File "$outputDirectory\$DisplayName\$version\source\uninstall.ps1" -Force
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\source\install.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\source\uninstall.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("You can test using Powershell ISE (button in GUI) or start the creation of intunewinfile`r`n")
			$winget_test_install_button1.Enabled = $true
			$winget_test_install_button1.Visible = $true
			$winget_uninstall_test_button.Enabled = $true
			$winget_uninstall_test_button.Visible = $true
			$winget_maakPackage_button1.Enabled = $true
			$winget_maakPackage_button1.Visible = $true
			$winget_final_panel7.Enabled = $true
		}
	}
	
}

$winget_test_install_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		$voorIntall = Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs"
		powershell_ise -file "$config_packagefolder\$DisplayName\$wingetversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	$winget_gotobuildingBlocks_buttonTestInstallPowershel.Enabled = $true
}

$winget_uninstall_test_button_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		
		powershell_ise -file "$config_packagefolder\$DisplayName\$wingetversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	$winget_addBuildingBlocksCSVbuttonOptionalAddBuildingB.Enabled = $true
	
}

$winget_show_version_button1_Click = {
	#TODO: Place custom script here
	$winget_show_string = $winget_WingetID_textbox1.text
	$winget_show_versions = winget show $winget_show_string --versions --accept-source-agreements
	
	
	$winget_output_textbox3.Text = "Search results: `r`n"
	foreach ($twi in $winget_show_versions)
	{
		
		$winget_output_textbox3.AppendText("$twi `r`n")
	}
}

$wsearch_s_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$wsearch_s_button1_Click = {
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$wsearchstring = $wsearch_s_textbox1.text
	$wsearch__winget_search_output = winget search $wsearchstring --accept-source-agreements
	
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			## - Display custom data created:
			$wsearch_datagridview1.DataSource = $table;
			
			
			
			
			
			
			
		}
		
	}
	
	
	
	
}


Write-Host $wsearch_datagridview1
$wsearch_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$cunfig_folder_pacakaging_button1_Click = {
	#TODO: Place custom script here
	if ($config_packagefolder_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_packagefolder_textbox.Text = $config_packagefolder_folderbrowsermoderndialog1.SelectedPath
	}
}

$config_logfolder_target_button1_Click = {
	#TODO: Place custom script here
	if ($config_logfolder_target_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_logfoldertarger_textbox.Text = $config_logfolder_target_folderbrowsermoderndialog1.SelectedPath
	}
}

$tools_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$tools_search_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_csv_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$upload_logo_button2_Click = {
		$dlg = $upload_logo_openfiledialog1.ShowDialog()
		if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
		[string]$logoPath = $upload_logo_openfiledialog1.FileName
		[string]$configPath = $config_csv_openfiledialog1.FileName
		
		if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
		if (-not (Test-Path -LiteralPath $configPath)) { [void][System.Windows.Forms.MessageBox]::Show('config.csv not selected.'); return }
		$destDir = Split-Path -Parent $configPath
		$destPng = Join-Path $destDir 'logo.png'
		
		# Size check (≤ 1 MB)
		$fi = Get-Item -LiteralPath $logoPath
		if ($fi.Length -gt 1MB)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
			return
		}
		$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
		
		switch ($ext)
		{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			Write-Host "WEBP conversion started..."
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
		[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
}

$timer1_Tick = {
	#TODO: Place custom script here
	
}

$weblink_logo_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$msi_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_Empty_Scheduled_Task_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Basic template: Creates install.ps1 and uninstall.ps1. With detection method in registry for Intune. And logging to the in Config defined log target"
}

$powershell_scheduledtask_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Template scheduled task: Creates install.ps1 that creates scheduled task to run Powershell script. Uninstall.ps1 cleans up the scheduled task"
}

$powershell_package_name_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package Name (String)"
}

$powershell_package_version_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package Version (String)"
}

$powershell_create_package_dir_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Creates package directory based on the chosen package folder (Config) and Package Name & Version"
}

$powershell_open_package_directory_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Open Package\source directory; Here you can place additional files when needed."
}


$config_listbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Select a customer / tenant"
}

$config_customername_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Customer name"
}

$config_logfoldertarger_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Log folder target. Location is used for Powershell transcript logging used by the packages; Also used for MSIEXEC logging when using an MSI source"
}

$config_packagefolder_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package folder. Must be a local folder. For example: when you create a package with Package Name: 'IntunePrepTool' with Package Version '1.0.3.5', and your package folder is c:\sources\gotomars. The folder created for this package = c:\sources\gotomars\IntunePrepTool\1.0.3.5\"
}

$config_tenanturl_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Tenant url is used for the upload function"
}

$helpbutton1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Opens https://github.com/rink-turksma/IntunePrepTool in Edge; If you need more information."
}

$config_delete_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Deletes selected customer. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_new_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click here to create new customer. Click save when done. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_save_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Save to append new customer to list. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_check_updates_button1_Click = {
	#TODO: Place custom script here
	$config_check_updates = @'
winget upgrade rink-turksma.IntunePrepTool
'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetupdate.ps1" -PathType Leaf))
		{
			$config_check_updates | Out-File "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$config_check_updates_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click to open Powershell ISE; Run script to upgrade IntunePrepTool using Winget; When you get the message: 'No applicable upgrade found.' You're already up to date. "
}

$winget_WingetID_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Exact Winget ID here; You can search for the Winget ID using Tabpage Tools"
}

$winget_checkurl_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Shows download URL in Popup window for chosen WingetID"
}

$winget_show_version_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Shows available versions for chosen WingetID; Output in textbox on the right side"
}

$toolstripstatuslabel1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_package_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_displayname_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package name (string)"
}

$versie_textbox2_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package version (string)"
}

$winget_locale_checkbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "'Winget Show' (Also available in tabpage Tools) can be used to find out if the chosen package is available in other languages. Check if you want to specify Locale. Like 'en-US' ; "
}

$global_selected_customer_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$config_listbox_SelectedValueChanged = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text + $config_listbox.SelectedItem
}

$winget_version_checkbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Check checkbox to select specify version. When you don't the latest version is used."
}

$winget_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When youre test and edit the installation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_uninstall_test_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When youre test and edit the uninstallation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_maakPackage_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create Intunewin file; don't forget to upload logo after creating Intunewinfile if you wan't to use the upload option."
}

$msi_buttonOpenMSIFile_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Open *.msi file to use for this package."
}

$msi_packagenaam_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package name (string)."
}

$msi_versie_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package version (string)."
}

$msi_buttonCreatePackageDirecto_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "After selecting MSI, Package name and package version, click Create package directory; The MSI file will be copied to the generated to the package directory"
}

$msi_OpenSourceDir_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click Open source directory to open the source directory for your package.You can add extra files when needed."
}

$msi_install_par_textbox3_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "MSIEXEC install parameters here; after creating package directory, a basic install string is already visible. Edit when needed. Leave the logging options as is. "
}

$msi_button1CreateInstallScript_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click create Install script to create the install.ps1 and i.cmd file; install.ps1 will provide detection method and logging; i.cmd is just the above filled install parameters in as batch file;  "
}

$msi_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click Test install to test your installation. Powershell_ISE will read the MSIEXEC log file and will show you a possible uninstall string. That you can use for uninstall script. Also when shorcuts are created the install.ps1 will give you the option to remove it."
}

$msi_uninstall_par_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Paste the suggested uninstall string from the install.ps1 here. Then click create uninstall script"
}

$msi_button3CreateUninstallScri_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create uninstall script"
}

$msi_button4TestUninstallPowers_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Test uninstall using Powershell_ISE; You can edit the uninstall.ps1 directly. If you need to change the u.cmd file. Please click Open source directory and edit. "
}

$msi_button5CreateIntunewinFile_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create intunewin package. This can take a while, depending on the size of your package. Application (STA) will not respond during creation of Intunewin"
}

$msi_buttonUploadLogoPNG_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When you plan to use Upload function. Please chose PNG file first. Used in Company portal"
}

$winget_remediations_createscripts_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Upload not yet available for Remediations.. For now use the Intune Admin Portal")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Please reopen IntunePrepTool to create more Remediations scripts")
				
				
			}
		}
		
		
	}
	
	
	
	
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
	
	
	
}

$configToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $true
	$config_tabpage.Visible = $true
	$config_tabpage.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$wingetToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_winget_tabcontrol2.Enabled = $true
	$package_winget_tabcontrol2.Visible = $true
	$package_winget_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}
$scheduledTaskToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'Fill'
	$package_ScheduledTask_tabcontrol2.Enabled = $true
	$package_ScheduledTask_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}


$mSIXToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$MSIX_tabcontrol1.Dock = 'Fill'
	$MSIX_tabcontrol1.Enabled = $true
	$MSIX_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$mSIToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $true
	$package_msi_tabcontrol2.Visible = $true
	$package_msi_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$eXEToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $true
	$package_exe_tabcontrol2.Visible = $true
	$package_exe_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$main_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$wingetUpdateToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Dock = 'Fill'
	$Remediations_winget_tabcontrol2.Enabled = $true
	$Remediations_winget_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$weblinkToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Dock = 'Fill'
	$package_weblink_tabcontrol2.Visible = $true
	$package_weblink_tabcontrol2.Enabled = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$intunewinToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Dock = 'Fill'
	$upload_intunewin_tabcontrol2.Enabled = $true
	$upload_intunewin_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$wingetSearchShowVersionToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Enabled = $true
	$tools_winget_searchtabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$findUninstallStringsToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'Fill'
	$tools_uninstallstring_tabcontrol1.Enabled = $true
	$tools_uninstallstring_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromWingetToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $true
	$download_tabcontrol1.Visible = $true
	$download_tabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromMSStoreUsingMSStoreURLToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $true
	$download_MSSTore_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Dock = 'Fill'
	
}


$powershellToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $true
	$Powershell.Visible = $true
	$Powershell.Dock = 'Fill'
	
	
}
$updateMSIOrEXEPackageToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $true
	$updatepackage_msi_tabcontrol1.Visible = $true
	$updatepackage_msi_tabcontrol1.Dock = 'Fill'
	
}

$updateEXEPackageToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $true
	$updatepackage_exe_tabcontrol1.Visible = $true
	$updatepackage_exe_tabcontrol1.Dock = 'Fill'
	
}

$chocolateyFindToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}
$chocolateyFindToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$chocolateyToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}




$fileWizzardToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'

	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}






$Weblink_intunewin_tabpage6_Click = {
	#TODO: Place custom script here
	
}

$weblink_packagename_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$remediations_winget_maxversion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_remediations_maxversion_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	
}

$remediate_winget_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_wingetid_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$remadiations_winget_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$remediations_winget_upload_button1_Click = {
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				
				
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				
				
				
				$encoding = [System.Text.Encoding]::UTF8
				$bytes = $encoding.GetBytes($remediate_detectFile)
				$Encoded_remediate_detectFile = [Convert]::ToBase64String($bytes)
				$Bytes2 = $encoding.GetBytes($remediate_remediateFile)
				$Encoded_remediate_remediateFile = [Convert]::ToBase64String($Bytes2)
				$UploadRemediationsFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	6/5/2023 3:38 PM
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	upload.ps1
	===========================================================================
	.DESCRIPTION
		Part of IntunePrepTool
		https://github.com/rink-turksma/IntunePrepTool
		Upload Remediations to Intune
#>
	Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
	else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
	$displayName = "!!displayName!!"
	$publisher = "!!publisher!!"
	$detectionScriptContent = '!!detectionScriptContent!!'
	$remediationScriptContent = '!!remediationScriptContent!!'
	$tenantID = "!!tenantid!!"
	$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547"; $RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	$MsalToken = Get-MsalToken -TenantId $tenantID -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	$body = @"
{"displayName":"$displayName","description":"Uploaded by IntunePrepTool","publisher":"$publisher","runAs32Bit":false,"runAsAccount":"system","enforceSignatureCheck":false,"detectionScriptContent":"$detectionScriptContent","remediationScriptContent":"$remediationScriptContent","roleScopeTagIds":["0"]}
"@
	$uri = "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts"
	$createdPolicy = Invoke-RestMethod -Uri $uri -Method POST -Body $body -Headers @{ Authorization = $MsalToken.CreateAuthorizationHeader() } -ContentType 'application/json'
	Write-Host "Remediationa policy created successfully with ID: $($createdPolicy.id)" -ForegroundColor Green
	Write-Host "Please assign and schedule with MS Intune Admin console" -ForegroundColor Green
	
'@
				$displayName = $winget_remediations_name_textbox1.Text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!publisher!!", $config_customername)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!displayName!!", $displayName)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!detectionScriptContent!!", $Encoded_remediate_detectFile)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!remediationScriptContent!!", $Encoded_remediate_remediateFile)
				$tenatURL = $upload_tenantURL_textbox.text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!tenantid!!", $tenatURL)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"
				}
				$UploadRemediationsFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1" -Force
				$remadiations_winget_textbox2.AppendText("Created Upload.ps1")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("After uploading; Please go to Intune Management Portal and assign devices or users. And add a schedule")
				
				if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE now?', 'upload.ps1 created', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
				{
					
					
					
					powershell_ise -file "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
			}
		}
	}
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
}

$remediations_winget_open_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
	$remediate_winget_version = $remediate_winget_version_textbox1.Text
	Invoke-Item "$config_packagefolder\$winget_remediations_name\$remediate_winget_version"
}

$powershell_scheduledtask_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	if ($powershell_scheduledtask_radiobutton.Checked -eq $true)
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $true
		$package_scheduled_task_WingetID_textbox.Visible = $true
		$package_scheduled_task_WingetID_label3.Enabled = $true
		$package_scheduled_task_WingetID_label3.Visible = $true
		#$package_ScheduledTask_create_scripts_button1.Enabled = $true
		#$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	else
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $false
		$package_scheduled_task_WingetID_textbox.Visible = $false
		$package_scheduled_task_WingetID_label3.Enabled = $false
		$package_scheduled_task_WingetID_label3.Visible = $false
		
	}
}

$powershell_Empty_Scheduled_Task_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	#$package_ScheduledTask_create_scripts_button1.Enabled = $true
	#$package_ScheduledTask_create_scripts_button1.Visible = $true
}



$package_scheduledtasK_option_weekly_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $true
		$package_scheduledtask_weekly_day_combobox1.Visible = $true
		$package_scheduledtask_weekly_time_combobox1.Enabled = $true
		$package_scheduledtask_weekly_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $true
		
	}
	else
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $false
		$package_scheduledtask_weekly_day_combobox1.Visible = $false
		$package_scheduledtask_weekly_time_combobox1.Enabled = $false
		$package_scheduledtask_weekly_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $false
		
	}
}

$package_scheduledtask_weekly_day_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$datetimepicker1_ValueChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_winget_max_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduled_Task_maxVersion_label4_Click = {
	#TODO: Place custom script here
	
}

$powershell_create_package_dir_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		if ($powershell_package_name_textbox1.Text -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package name textbox', 'Select Package Name')
		}
		else
		{
			if ($powershell_package_version_textbox1.Text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package version textbox', 'Select Package Version')
			}
			else
			{
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
				$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
				$package_scheduledTask_name = $powershell_package_name_textbox1.Text
				$package_scheduledTask_name = $package_scheduledTask_name -replace (" ", "")
				$powershell_package_name_textbox1.Text = $package_scheduledTask_name
				$package_scheduledTask_version = $powershell_package_version_textbox1.text
				
				
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"
				}
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"
				}
				$package_ScheduledTask_output_textbox1.Text = "`nNew package direcotory created: `r`n"
				$package_ScheduledTask_output_textbox1.AppendText("$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$powershell_open_package_directory_button1.Enabled = $true
				$powershell_open_package_directory_button1.Visible = $true
				$package_scheduledtask_system_panel5.Enabled = $true
				$package_scheduledtask_system_panel5.Visible = $true
				#$package_ScheduledTask_create_scripts_button1.Enabled = $true
				#$package_ScheduledTask_create_scripts_button1.Visible = $true
				$scheduledtask_buttonOpenSourceDirectory.Enabled = $true
				$scheduledtask_buttonOpenSourceDirectory.Visible = $true
				
				
				
			}
		}
	}
}

$powershell_package_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_open_package_directory_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	Invoke-Item "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\"
}

$package_ScheduledTask_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_ScheduledTask_create_scripts_button1_Click = {
	#TODO: Place custom script here
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	if ($package_scheduledTaskWarning -eq $true)
	{
		[void][System.Windows.Forms.MessageBox]::Show('For user context select logon or on schedule first; For system context. Select at startup or on schedule option first', 'Select option first')
	}
	else
	{
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$package_scheduledTask_name = $powershell_package_name_textbox1.Text
		$package_scheduledTask_version = $powershell_package_version_textbox1.text
		#$package_scheduledtask_system_panel3.Visible = $true
		#$package_scheduledtask_system_panel3.Enabled = $true
		
		
		
		$ScheduledTaskFile = @'
<#Place code here#>











'@
		$logdir = "$config_logfoldertarget\scheduledTasks"
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!ps1name!!", "scheduledTask_$package_scheduledTask_name.ps1")
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_name!!", $package_scheduledTask_name)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_version!!", $package_scheduledTask_version)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!logdir!!", $logdir)
		$ScheduledTaskFile | Out-File  "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1" -Force -Confirm:$false -ErrorAction SilentlyContinue
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$package_ScheduledTask_output_textbox1.AppendText("Template script to be scheduled created")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Please add your Powershell code between 'Place your Powershell code here' and 'End of your Powershell script'")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Save when done")
		
		$package_scheduledTask_Edit_script_button1.Enabled = $true
		$package_scheduledTask_Edit_script_button1.Visible = $true
		$package_scheduledtasK_option_startup_checkbox1.Enabled = $true
		$package_scheduledtasK_option_startup_checkbox1.Visible = $true
		$package_scheduledtasK_option_weekly_checkbox1.Enabled = $true
		$package_scheduledtasK_option_weekly_checkbox1.Visible = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Enabled = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Visible = $true
	}
	
}



$package_scheduledTask_Edit_script_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Powershell_ISE will open now. Please place powershell code between "Place your Powershell code here" and "End of your Powershell script"; Save when done', 'Powershell_ISE') # Casting the method to [void] suppresses the output. 
	
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	
	
	
}

$package_scheduledtasK_option_startup_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_createIntunewin_scripts_button1_Click = {
	#TODO: Place custom script here
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	
	
	$package_scheduledTask_Edit_script_test_install_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_install_button1.Visible = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Enabled = $true
	
	
	$ScheduledTaskInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	6-10-2024 17:54
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$systemContext = "!!systemContext!!"
$onSchedule = "!!onSchedule!!"
$StartupTask = "!!StartupTask!!"
$logonTask = "!!LogonTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!"
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$DailyTask = "!!DailyTask!!"
$DailyTaskHour = "!!DailyTaskHour!!"
$DailyTaskAMPM = "!!DailyTaskAMPM!!"

$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $version) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
if (test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force }
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
copy-item $psFile -Destination "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force

#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
# BEGIN: 3d5f4a6gch7
#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
$Acl = Get-Acl "$logdir\scheduledTasks"
$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators", "Modify", "Allow")
$System = New-Object System.Security.Principal.NTAccount("SYSTEM")
$Ar2 = New-Object System.Security.AccessControl.FileSystemAccessRule($System, "Modify", "Allow")
$Acl.SetAccessRule($Ar)
$Acl.SetAccessRule($Ar2)
Set-Acl "$logdir\scheduledTasks" $Acl
# END: 3d5f4a6gch7

try
{
	
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	# Creates the scheduled task
	
	
	$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -executionpolicy bypass -Command `"& '$logdir\scheduledTasks\scheduledTask_$appName.ps1'`""
	if ($logonTask -eq $true)
	{
		$trigger0 = New-ScheduledTaskTrigger -AtLogOn
	}
	else
	{
		$trigger0 = $null
	}
	
	if ($StartupTask -eq $true)
	{
		$trigger1 = New-ScheduledTaskTrigger -AtStartup -RandomDelay 00:00:30
	}
	else
	{
		$trigger1 = $null
	}
	if ($WeeklyTask -eq $true)
	{
		$trigger2 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $WeeklyTaskDay -At $WeeklyTaskHour$WeeklyTaskAMPM
	}
	else
	{
		$trigger2 = $null
	}
	if ($DailyTask -eq $true)
	{
		$trigger3 = New-ScheduledTaskTrigger -Daily -At $DailyTaskHour$DailyTaskAMPM
	}
	else
	{
		$trigger3 = $null
	}
	$triggers = @()
	if ($trigger0 -ne $null)
	{
		$triggers += $trigger0
	}
	if ($trigger1 -ne $null)
	{
		$triggers += $trigger1
	}
	if ($trigger2 -ne $null)
	{
		$triggers += $trigger2
	}
	if ($trigger3 -ne $null)
	{
		$triggers += $trigger3
	}
	
	if ($systemContext -eq $true)
	{
		$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	}
	else
	{
		$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -RunLevel Limited
	}
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	Register-ScheduledTask -Action $action -Trigger $triggers -Principal $principal -TaskName $appName -Settings $settings -Description "Scheduled Task for $appName" -Force -ErrorAction Stop
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	
	$excode = 0;
	
}
catch
{
	write-host "Error creating scheduled task" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error'; }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	
	$ScheduledTaskUnInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the deletion of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will delete the powershell script used by the task" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 


try
{
	# Script deletes the scheduled task here
	write-host "Script will delete the scheduled task" -ForegroundColor Green
	Unregister-ScheduledTask -TaskName $appName -Confirm:$false -ErrorAction Stop
	write-host "Scheduled Task deleted" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error with deleting scheduled task" -ForegroundColor Yellow
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
remove-item $regKeyApp -Confirm:$false -force }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$RegisterDetectionroot = "Intune_" + $config_customername
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Weekly or at startup', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				Write-Host "Eerste stap"
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			Write-Host "Check"
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $true)
			
			if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $false)
			}
			
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			Write-Host "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
			
		}
		
		
		
		
	}
	
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Select At logon or at schedule', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $true)
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $false)
			}
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
		}
	}
	
}

$windowsFirewallToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$config_InstallRequriedPSmodules_Click = {
	#TODO: Place custom script here
	$config_install_required_ps_modules = @'

<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	17-5-2024 15:24
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	InstallRequiredPowershellModules.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$problemPSModule = $null;;
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = $null;
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = $null;
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = $null
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if ($problemPSModule -eq 1)
{
	#Nuget installation
	$nugetUrl = "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
	$nugetInstallPath = "$env:ProgramFiles\NuGet"
	if (-not (Test-Path -Path $nugetInstallPath))
	{
		New-Item -ItemType Directory -Path $nugetInstallPath -Force
	}
	$nugetExePath = Join-Path -Path $nugetInstallPath -ChildPath "nuget.exe"
	Invoke-WebRequest -Uri $nugetUrl -OutFile $nugetExePath
	if (Test-Path -Path $nugetExePath)
	{
		Write-Host "NuGet has been installed successfully at $nugetExePath"
	}
	else
	{
		Write-Host "NuGet installation failed"
	}
	$path = [Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
	if ($path -notlike "*$nugetInstallPath*")
	{
		[Environment]::SetEnvironmentVariable("Path", "$path;$nugetInstallPath", [System.EnvironmentVariableTarget]::Machine)
		Write-Host "NuGet has been added to the system PATH"
	}
	else
	{
		Write-Host "NuGet is already in the system PATH"
	}
	& $nugetExePath | Select-String "NuGet Version"
	
	
	Get-PackageProvider -Name Nuget -Force
	
	#Installation Powershell Modules
	Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name IntuneWin32App)
	{
		$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
		
		if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
		{
			Write-Host "IntuneWin32App 1.4.4 already installed"
		}
		else
		{
			Write-Host "Required Version not found.. Now installing"
			Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Authentication 2.27.0 already installed"
		}
		else
		{
			Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Applications 2.27.0 already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name CredentialManager)
	{
		$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
		{
			Write-Host "CredentialManager 2.0.0 Powershell module already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Identity.SignIns 2.27.0 Powershell Module already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	"true" | Out-File 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Force -Confirm:$false
	
}
else
{
	write-host "Powershell Modules already installed!"
	"true" | Out-File 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Force -Confirm:$false
}


'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -PathType Leaf))
		{
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -Confirm:$false -Force
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$downloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$wingetToolStripMenuItem1_Click = {
	#TODO: Place custom script here
	
}

$config_download_folder_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_downloadFolderBrowse_Click = {
	#TODO: Place custom script here
	if ($config_download_folderbrowsermoderndialog2.ShowDialog() -eq 'OK')
	{
		$config_download_folder_textbox3.Text = $config_download_folderbrowsermoderndialog2.SelectedPath
	}
}

$download_winget_tab_Click = {
	#TODO: Place custom script here
	
}

$download_winget_search_button1_Click = {
	
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
	
	
}

$download_winget_search_textbox5_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$download_winget_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_version_listbox1.Items.Clear()
	
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	
	
	foreach ($wsearch_55 in $downloadwingetsearchversionselected)
	{
		
		
		if (($wsearch_55 -notlike "Found*") -and ($wsearch_55 -notlike "*-*") -and ($wsearch_55 -notlike "*Version*") -and ($wsearch_55 -notlike $null) -and ($wsearch_55 -notlike "* *"))
		{
			
			$download_winget_version_listbox1.Items.Add($wsearch_55)
			
			
		}
		
	}
	
	
	
	
}

$download_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	#Write-Host $download_datagridview1.SelectedRows.Item.ToString()
}

$download_winget_version_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_download_and_add_button1.Visible = $true
	$download_winget_download_and_add_button1.Enabled = $true
}

$download_winget_download_and_add_button1_Click = {
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	$download_winget_explorer_button1.Enabled = $true
	$download_winget_explorer_button1.Visible = $true
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	if (!(Test-Path -Path $download_winget_path))
	{
		
		New-Item -ItemType Directory -Path $download_winget_path
	}
	#$downloadWingetToLib = winget download --download-directory $download_winget_path --id $winget_download_selected_id --accept-package-agreements --accept-source-agreements
	
	#$download_winget_output_textbox3.Text = $downloadWingetToLib
	#$config_downloadpath
	#Write-Host $download_winget_version_listbox1.SelectedItem
	$download_winget_selectedversion = $download_winget_version_listbox1.SelectedItem
	$download_winget_package = @'
winget download --download-directory '!!@download_winget_path@!!' --id !!@winget_download_selected_id@!! --accept-package-agreements --accept-source-agreements --version !!@download_winget_selectedversion@!!
'@
	$download_winget_package = $download_winget_package.Replace("!!@winget_download_selected_id@!!", $winget_download_selected_id)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_selectedversion@!!", $download_winget_selectedversion)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_path@!!", $download_winget_path)
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -PathType Leaf))
		{
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -Confirm:$false -Force
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		
		powershell_ise 'C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1'
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}


$download_winget_explorer_button1_Click = {
	#TODO: Place custom script here
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	explorer $download_winget_path
}

$config_help_button1_Click = {
	#TODO: Place custom script here
	
}

$config_exit_help_button1_Click = {
	#TODO: Place custom script here
	
}

$exe_maak_uninstall_script_button1_Click = {
	#TODO: Place custom script here
	$exe_maak_intuneWIN_button1.Enabled = $true
	$exe_maak_intuneWIN_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	
	$exe_uninstallFile = @'
<#	
    .NOTES
    ===========================================================================
     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
     Created on:   	21-5-2023 18:04
     Created by:   	Rink Turksma
     Organization: 	
     Filename:     	uninstall.ps1
    ===========================================================================
    .DESCRIPTION
        Parameters will be filled by IntunePrepTool.
#>
#App Parameters
$appName = "!!AppName!!"
$version = "!!version!!"
$exeFile = "!!EXEFile!!"
$exeParameters = "!!EXEPARMS!!" ##Check EXE PARAMETERS.. 
#Customer variables
$logDir = "!!logdir!!"
$registerDetectionRoot = "!!RegisterDetectionroot!!"
#Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
#Create log directory in programdata if it does not exist.
if (!(Test-Path -Path $logDir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
    New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application Key in the Registry Root.
if (!(Test-Path -Path $regkeyApp))
{
    New-Item $regkeyApp -ItemType Key -Force | out-null
}



function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution..
	### Eventually you will have, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  
#The code you provided is a comment in PowerShell. It indicates that the following code block is related to a transcript that will be saved in a text file under the $logdir directory and will also be available in the event viewer.
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $EXEFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Uninstall completed" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
    write-host "Error executing $EXEbestand" -ForegroundColor Yellow
	Write-Host "Uinstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:





<#----Below is the end of the installation script---#>
#Now the Transcript logging is started
Stop-Transcript
#After this command, the log is automatically saved in the $logdir location
#Here is a way to split the log so that we only have the last run.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
    $lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try / catch block in the execution, we set $excode to 0 or 1
# Based on this, the Log in the Event viewer is set to Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful application message or an unsuccessful one.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$MSIPARSInput = '"' + $exe_msiexecuninstall.Text + '"'
		
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
		
		try
		{
			$exepnaam = $exe_packagenaam_textbox1.text
			$exeversie = $exe_versie_textbox1.text
			$outputDirectory = $config_packagefolder
			$jjmsii = $exe_msiexecuninstall.text
			
			$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
			$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
			$exe_output_textbox1.AppendText("`nu.cmd created `r`n")
			$exe_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
			
			
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
		}
		
		
	}
	else
	{
		
		if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
		{
			$EXEbestand = $exe_uninstall_exe_path_textbox2.Text
			
		}
		else
		{
			$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		}
		
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		#$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$EXEPARSInput = $exe_parsUnInstall_textbox1.Text
		
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!AppName!!"', $appnaam)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!logdir!!', $logdir)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!version!!', $versie)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEFile!!"', $EXEbestand)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEPARMS!!"', $EXEPARSInput)
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		try
		{
			$exe_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUbinstall.ps1 NOT created `r`n")
		}
	}
}

$exe_radiobutton3_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_msiexecuninstall_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_search_button1_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_uninstallstring_search_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$buttonSearch32Bit_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}




$package_scheduledTask_Edit_script_test_install_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $powershell_package_name_textbox1.Text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$package_ScheduledTask_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$package_ScheduledTask_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$package_ScheduledTask_output_textbox1.AppendText("`r`n")
	
	$package_ScheduledTask_output_textbox1.AppendText("Install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("un-install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$package_ScheduledTask_output_textbox1.AppendText("$regkeyApp `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Please reopen tool to make another Intunewin package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$package_ScheduledTask_output_textbox1.AppendText("Config.csv written to: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$package_ScheduledTask_output_textbox1.AppendText("  `r`n")
	$package_scheduledTask_Edit_script_UploadLogo_button1.Enabled = $true
	$package_scheduledTask_Edit_script_UploadLogo_button1.Visible = $true
	$package_ScheduledTask_output_textbox1.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
}

$package_scheduledTask_Edit_script_UploadLogo_button1_Click = {
	#TODO: Place custom script here
	
	$msipnaam = $powershell_package_name_textbox1.text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if ([System.Windows.Forms.MessageBox]::Show("Click yes to open the upload screen. Then load the $outputDirectory\$msipnaam\$msiversie\output\config.csv file there", 'Upload Now?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$package_ScheduledTask_tabcontrol2.Enabled = $false
		$package_ScheduledTask_tabcontrol2.Visible = $false
		
		
		$upload_intunewin_tabcontrol2.Enabled = $true
		$upload_intunewin_tabcontrol2.Visible = $true
		$upload_intunewin_tabcontrol2.Dock = 'Fill'
	}
	
}

$reloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}


$reopenIntunePrepToolToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	& "C:\Program Files\IntunePrepTool\IntunePrepTool.exe"
'@
	if (Test-Path "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1")
	{
		powershell.exe -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
	else
	{
		$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1" -Confirm:$false -Force
		Start-Sleep 1
		powershell -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
}

$buttonUser_folder_showInfo_Click = {
	#TODO: Place custom script here
	#$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547";
	#$RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	#$MsalToken = Get-MsalToken -TenantId 'CSNTestRink.onmicrosoft.com' -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	#$webbrowser1
}

$package_scheduledtask_usercontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		#$package_scheduledTask_systemcontext.Checked = $false
		
		$package_scheduledTask_systemcontext.Enabled = $true
		$package_scheduledTask_systemcontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $true
		$package_scheduledtask_user_panel4.Visible = $true
		$package_scheduledtask_system_panel3.Enabled = $false
		$package_scheduledtask_system_panel3.Visible = $false
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
	}
	
}

$Package_scheduledtask_User_atlogon_checkbox_logon_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledTask_systemcontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		#$package_scheduledtask_usercontext.Checked = $false
		$package_scheduledtask_usercontext.Enabled = $true
		$package_scheduledtask_usercontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $false
		$package_scheduledtask_user_panel4.Visible = $false
		$package_scheduledtask_system_panel3.Enabled = $true
		$package_scheduledtask_system_panel3.Visible = $true
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	
}

$package_scheduledtask_system_panel3_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$package_scheduledtasK_user_schedule_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
		
	}
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false)
	{
		if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
}

$package_scheduledtasK_system_onschedule_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
	}
	if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
	{
		if ($package_scheduledtasK_user_schedule_checkbox.checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
	
	
}

$config_app_refresh_button1_Click = {
	#TODO: Place custom script here
	
}

$config_treeview3_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$customPrivacyURL = $custinfo.customPrivacyURL
				$config_tenant_info_CustomPrivacyURL_textbox3.Text = $customPrivacyURL
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
}

$addTenantToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $false
	$config_tenant_info_panel4.Visible = $false
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
	
	
	
	
}

$config_tenant_add_menustrip2_ItemClicked = [System.Windows.Forms.ToolStripItemClickedEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$config_app_regg_add_tenant_button2_Click = {
	#TODO: Place custom script here
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
}

$treeview2_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$config_tenant_add_button2_Click = {
	#TODO: Place custom script here
	
	$tenantName = $config_tenant_name_textbox3.Text
	$tenantName  = $tenantName -replace (" ", "")
	
	$appRegName = $config_tenant_appRegName_textbox3.Text
	$appRegName = $appRegName -replace (" ", "")
	if ($config_tenant_checkboxYes.Checked -eq $true)
	{
		$customPrivacyURL = $config_tenant_customprivacy_textbox3.text
	}
	else
	{
		$customPrivacyURL = $null
	}
	
	Set-Location $PSScriptRoot
	
	if ([System.Windows.Forms.MessageBox]::Show('Please logon to the tenant with Global Admin rights. App registration will be added. Please wait a few seconds!', 'Logon to tenant', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		

		
		if ($config_tenant_checkboxYes.Checked -eq $true)
		{
			& 'C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe' -AppRegName $AppRegName -CustomerName $tenantName -CustomPrivacyUrl $CustomPrivacyUrl
		}
		else
		{
			& 'C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe' -AppRegName $AppRegName -CustomerName $tenantName -CustomPrivacyUrl 'nvt'
		}
		
		
		
		
		
		
		if (($config_add_Tenant_radiobutton2.Checked -eq $false) -and ($config_add_Tenant_radiobutton1.Checked -eq $false))
		{
			([System.Windows.Forms.MessageBox]::Show('Please select Windows Credential Manager or Plain Text mode', 'Please select savingmode first', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		}
		refreshTenants
		refreshTenantsUpload
		
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('All Done.', 'Customer added') # Casting the method to [void] suppresses the output. 
		
		
	}
	
	
	
}

$config_tenant_name_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_tenant_appRegName_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$tenanturl_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduledtasK_option_Daily_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $true
		$package_scheduledtask_daily_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $true
	}
	else
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $false
		$package_scheduledtask_daily_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $false
	}
	
	
	
	
}

$package_scheduledtask_daily_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$infoToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
	
	
	
}

$labelTenantName_Click = {
	#TODO: Place custom script here
	
}



$removeToolStripMenuItem_Click = {
	
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$config_tenant_info_secret_show_button2_Click = {
	#TODO: Place custom script here
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_secret_textbox3.Text = $checkCred.Password
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_secret_textbox3.Text = $custinfo.clientsecret
			}
		}
		
	}
}


$msix_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	if ($msixpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msixversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\output"
			}
			$msix_output_textbox3.Text = "`nNew package direcotory created: `r`n"
			$msix_output_textbox3.AppendText("$outputDirectory\$msixpnaam\$msixversie\source")
			$msix_output_textbox3.AppendText("`r`n")
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
				$msix_buttonOpenSourceDirectory.Enabled = $true
				$msix_buttonOpenSourceDirectory.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			
			
			
			
		}
	}
}

$msix_packagename_textbox3_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # 
}

$msix_packageVersion_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_download_winget_MSIX_bundle_Click = {
	#TODO: Place custom script here
	$config_install_required_winget= @'
# Resolve Winget path
$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($ResolveWingetPath) {
    $WingetPath = $ResolveWingetPath[-1].Path
}
$wingetexe = $ResolveWingetPath

# Check Winget version
if (Test-path $wingetexe) {
    Write-Host "We are now checking the version of Winget"
    $wingetOption = 1
    $version = & $wingetexe --version
    Write-Host $version
} else {
    Write-Host "We are now checking the version of Winget"
    $wingetOption = 2
    $version = winget --version
    Write-Host $version
}

# Install Winget if needed
if ($version -notlike 'v1.11.430') {
    Write-Host "Winget Version does not match.. installing now"
    [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
    $msixUrl  = "https://github.com/microsoft/winget-cli/releases/download/v1.11.430/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    $msixPath = "$($env:TEMP)\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    (New-Object System.Net.WebClient).DownloadFile($msixUrl, $msixPath)

    try {
        Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
        Write-Host "Winget installation completed successfully."
    } catch {
        if ($_.Exception.Message -match "Microsoft.VCLibs.140.00.UWPDesktop") {
            Write-Host "Now downloading: Missing dependency 'Microsoft.VCLibs.140.00.UWPDesktop'."
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            $dependencyURL = 'https://github.com/microsoft/winget-cli/releases/download/v1.11.430/DesktopAppInstaller_Dependencies.zip'
            $dependencyPath =  "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
            (New-Object System.Net.WebClient).DownloadFile($dependencyURL, $dependencyPath)
            unblock-file "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
            Expand-Archive -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip" -DestinationPath "$($env:TEMP)\DesktopAppInstaller_Dependencies"
            write-host "Now installing dependency"
            try {
            Add-AppxPackage -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies\x64\Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64.appx" -ErrorAction Stop
            write-host "Installing depedency done"
            }
            catch {
            Write-host "Installing depedency failed"
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
            }
            try {
            write-host "Now trying to install Winget again"
            Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
            write-host "Install winget done" 
            }
            catch {
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
            }
        } else {
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
        }
    }

    # Re-check Winget version after attempted install
    $ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
    if ($ResolveWingetPath) {
        $WingetPath = $ResolveWingetPath[-1].Path
    }
    $wingetexe = $ResolveWingetPath

    if (Test-path $wingetexe) {
        Write-Host "Re-checking Winget version..."
        $version = & $wingetexe --version
        Write-Host $version
    } else {
        Write-Host "Winget executable could not be found after installation attempt."
    }
} else {
    Write-Host "Winget is up to date."
}


'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installWinget.ps1" -PathType Leaf))
		{
			$config_install_required_winget | Out-File "C:\Program Files\IntunePrepTool\installWinget.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installWinget.ps1" -Confirm:$false -Force
			$config_install_required_winget | Out-File "C:\Program Files\IntunePrepTool\installWinget.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installWinget.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
	
	
	
	
	
	#Start-Process -FilePath "C:\Program Files\IntunePrepTool\MicrosoftDesktopApp.exe" -WindowStyle Normal
}

$MSIX_open_MSIX_button2_Click = {
	#TODO: Place custom script here
	$MSIX_openfiledialog1.ShowDialog()
	$msix_label4.Text = $msix_openfiledialog1.SafeFileName
	$msix_label4.Visible = $true;
	
}

$MSIX_CreateScripts_button2_Click = {
	
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		write-host "Package installed!"
		$excode = 0
	}
	else
	{
      	$MSIXName = $MSIXFile.Replace(".msixbundle", "")
        $PackageFullName = (Get-AppxPackage | where { $_.PackageFamilyName -like "*$MSIXName*" } | Select PackageFullName).PackageFullName
		Remove-AppxPackage -Package $PackageFullName -AllUsers -ErrorAction Stop
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}

if ($install -like "!!doe*")
{
	try
	{
		# Searches for start menu items created in the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startmenuItems)
		{
			Write-Host "`r`n"
			Write-Host "A start menu *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$startmenuI`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	} catch {
		Write-Host "Error looking for *.lnk files in start menu" -ForegroundColor Yellow
	}

	try {
		# Searches for Desktop items created in the last 10 minutes
		$desktopItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($desktopItem in $desktopItems) {
			Write-Host "`r`n"
			Write-Host "A Desktop *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$desktopItem`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	}
	catch
	{
		Write-Host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
		Write-Host "`r`n"
		Write-Host "Latest installed PackageFullName is:" -ForegroundColor Yellow
		$lastInstalledPackage = Get-AppxPackage | Sort-Object { $_.InstallDate } -Descending | Select-Object -Last 1
        #$lastInstalledPackage | Format-List
        $packageFullName = $lastInstalledPackage.PackageFullName
		Write-Host "$packageFullName" -ForegroundColor Green


}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -Force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$msixpnaam\$msixversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	#$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	#$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test install using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_install_button.Enabled = $true
	$MSIX_test_install_button.Visible = $true
	#$MSIX_test_uninstall_button.Enabled = $true
	#$MSIX_test_uninstall_button.Visible = $true
	#$MSIX_Create_Package.Enabled = $true
	#$MSIX_Create_Package.Visible = $true
	$MSIX_packageFullName_textbox3.Enabled = $true
	$MSIX_packageFullName_textbox3.Visible = $true
	$MSIX_create_uninstall_Script_button2.Enabled = $true
	$MSIX_create_uninstall_Script_button2.Visible = $true
	$msix_fullPackageName_label5.Enabled = $true
	$msix_fullPackageName_label5.Visible = $true
	
	
	
	
}

$msix_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	Invoke-Item "$config_packagefolder\$msixpnaam\$msixversie\source\"
}

$MSIX_test_install_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msix_GotoBuildingBlocks_Button.Enabled = $true
	}
}

$MSIX_test_uninstall_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msix_addBuildingBlokcsCSV_buttonOptionalAddBuildingB.Enabled = $true
	}
}

$MSIX_create_uninstall_Script_button2_Click = {
	#TODO: Place custom script here
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$PackageFullName = "!!PackageFullName!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		$excode = 0
	}
	else
	{
		Get-AppxProvisionedPackage -Online | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxProvisionedPackage -Online -ErrorAction Stop
		Get-AppxPackage -AllUsers | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxPackage -AllUsers -ErrorAction Stop
		write-host "Uninstall of $PackageFullName completed" -ForegroundColor Green
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$packageFullName = $MSIX_packageFullName_textbox3.Text
	$installfile = $installfile.Replace('!!PackageFullName!!', $packageFullName)
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test uninstall using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_uninstall_button.Enabled = $true
	$MSIX_test_uninstall_button.Visible = $true
	$MSIX_Create_Package.Enabled = $true
	$MSIX_Create_Package.Visible = $true
}

$download_winget_Search_store_Button_Click = {
	#TODO: Place custom script here
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
}

$Download_MSSTORE_download_button_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_MSStore_path = "$config_downloadpath\MSStore"
	$MSDownloadLink = $Download_MSSTORE_textbox3.Text
	$MSDownloadLink = $MSDownloadLink.Replace(" ", "")
	if (!(Test-Path -Path $download_MSStore_path))
	{
		
		New-Item -ItemType Directory -Path $download_MSStore_path
	}
	$download_MSSTore_package = @'
# Using: https://github.com/maxbakhub/winposh/blob/main/WindowsDesktopManagement/Download-AppxPackage.ps1
# Found on:
# https://woshub.com/how-to-download-appx-installation-file-for-any-windows-store-app/

function Download-AppxPackage {
[CmdletBinding()]
param (
  [string]$Uri,
  [string]$Path = "."
)
   
  process {
    $Path = (Resolve-Path $Path).Path
    #Get Urls to download
    $WebResponse = Invoke-WebRequest -UseBasicParsing -Method 'POST' -Uri 'https://store.rg-adguard.net/api/GetFiles' -Body "type=url&url=$Uri&ring=Retail" -ContentType 'application/x-www-form-urlencoded'
    $LinksMatch = $WebResponse.Links | where {$_ -like '*.appx*' -or $_ -like '*.appxbundle*' -or $_ -like '*.msix*' -or $_ -like '*.msixbundle*'} | where {$_ -like '*_neutral_*' -or $_ -like "*_"+$env:PROCESSOR_ARCHITECTURE.Replace("AMD","X").Replace("IA","X")+"_*"} | Select-String -Pattern '(?<=a href=").+(?=" r)'
    $DownloadLinks = $LinksMatch.matches.value 

    function Resolve-NameConflict{
    #Accepts Path to a FILE and changes it so there are no name conflicts
    param(
    [string]$Path
    )
        $newPath = $Path
        if(Test-Path $Path){
            $i = 0;
            $item = (Get-Item $Path)
            while(Test-Path $newPath){
                $i += 1;
                $newPath = Join-Path $item.DirectoryName ($item.BaseName+"($i)"+$item.Extension)
            }
        }
        return $newPath
    }
    #Download Urls
    foreach($url in $DownloadLinks){
        $FileRequest = Invoke-WebRequest -Uri $url -UseBasicParsing #-Method Head
        $FileName = ($FileRequest.Headers["Content-Disposition"] | Select-String -Pattern  '(?<=filename=).+').matches.value
        $FilePath = Join-Path $Path $FileName; $FilePath = Resolve-NameConflict($FilePath)
        [System.IO.File]::WriteAllBytes($FilePath, $FileRequest.content)
        echo $FilePath
    }
  }
}

Download-AppxPackage "!!MSStoreLink!!" "!!DLPath!!"
'@
	
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!MSStoreLink!!", "$MSDownloadLink")
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!DLPath!!", "$download_MSStore_path")
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -PathType Leaf))
		{
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -Confirm:$false -Force
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		
		powershell_ise "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		PowershellISEOnTop
	}
	
}


$MSIX_TIP_button2_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://store.rg-adguard.net/'
}

$MSIX_Create_Package_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msix_output_textbox3.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$msixpnaam\$msixversie\source\" -s "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -o "$config_packagefolder\$msixpnaam\$msixversie\output\" -q
	Rename-Item -Path "$config_packagefolder\$msixpnaam\$msixversie\output\install.intunewin" -NewName "$config_packagefolder\$msixpnaam\$msixversie\output\$msixpnaam.intunewin"
	$msix_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msipnaam\$msixversie\output\$msixpnaam.intunewin")
	$msix_output_textbox3.AppendText("`r`n")
	
	$msix_output_textbox3.AppendText("Install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msix_output_textbox3.AppendText("un-install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msix_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msixpnaam\"
	$regkeyApp
	$msix_output_textbox3.AppendText("$regkeyApp `r`n")
	$msix_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$msix_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: $msixversie `r`n")
	$msix_output_textbox3.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$msixpnaam.intunewin"
			DisplayName   = $msixpnaam
			Publisher	  = $config_customername
			AppVersion    = $msixversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$msixpnaam\$msixversie\output\"
	$msix_output_textbox3.AppendText("Config.csv written to: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\output\config.csv")
	$msix_output_textbox3.AppendText("  `r`n")
	$MSIX_UploadLogo_button.Enabled = $true
	$MSIX_UploadLogo_button.Visible = $true
	#.AppendText("First use Upload Logo to upload *.png file. `r`n")
	#$msix_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $msix_buildingblocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$msixpnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$msix_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$msix_output_textbox3.AppendText("$config_buildingblockspath\$msixpnaam\BuildingBlocks.csv `r`n")
		$msix_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$msix_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$msix_output_textbox3.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$msix_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
	
}

$MSIX_UploadLogo_button_Click = {
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msix_packagename_textbox3.text
	$msiversie = $msix_packageVersion_textbox3.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
	
	
	
	
}


$powershell_open_install_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_install_OpenFIledialog1.ShowDialog()
	$powershell_install_Script_label5.Text = $Powershell_install_OpenFIledialog1.SafeFileName
	$powershell_install_Script_label5.Visible = $true;
	
	
}

$powershell_open_uninstall_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_uninstall_OpenFIledialog1.ShowDialog()
	$powershell_uninstall_Script_label5.Text = $Powershell_uninstall_OpenFIledialog1.SafeFileName
	$powershell_uninstall_Script_label5.Visible = $true;
}

$powershell_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellpnaam = $powershellpnaam -replace (" ", "")
	$powershell_packagename_textbox.text = $powershellpnaam
	$powershellversie = $powershell_packageversion_textbox.Text
	
	if ($powershellpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($powershellversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
			}
			$powershell_output_textbox5.Text = "`nNew package direcotory created: `r`n"
			$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("Now select Powershell script for install and uninstall first")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("when needed, Add extra files in Package directory by using the 'Open: Source Directory' button")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_panel4.Enabled = $true
			$powershell_panel4.Visible = $true
			$powershell_opensource_button2.Enabled = $true
			$powershell_opensource_button2.Visible = $true
			<#
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			#>
			
			
			
		}
	}
}

$powershell_generateNEWPS_ps_button2_Click = {
	#TODO: Place custom script here
	if (($powershell_install_Script_label5.text -like "label5") -or ($powershell_uninstall_Script_label5.text -like "label5"))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Use button to select script', 'Please select install and / or uninstall source script first!')
	}
	else
	{
		if (($powershell_radiobutton2.Checked -eq $false) -and ($powershell_radiobutton1.Checked -eq $false))
		{
			[void][System.Windows.Forms.MessageBox]::Show('Select user or system context first', 'Please select user or system context first')
		}
		else
		{
			
			$powershell_output_textbox5.AppendText("`Generating install and uninstall powershell scripts...`r`n")
			
			$powershelll_user_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1  }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
			$powershelll_user_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1  }
else { remove-item $regkeyApp; exit 0 }
'@
			
if ($powershell_radiobutton2.Checked -eq $true)
	{
	$powershelll_installFile = $powershelll_user_installFile
	$powershell_uninstallFile = $powershelll_user_uninstallFile
	}
	if ($powershell_radiobutton1.Checked -eq $true) {
	$powershelll_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
			$powershell_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
				
			}
			
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
			$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
			$powershellpnaam = $powershell_packagename_textbox.text
			$powershellversie = $powershell_packageversion_textbox.Text
			$fid = $config_packagefolder; $outputDirectory = $fid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			[string]$powershell_install_org_path = $Powershell_install_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_install_org_path -Confirm:$false
			$powershellInputInstall = Get-Content -Path $powershell_install_org_path
			#Write-Host $powershellInputInstall
		
			$powershelll_installFile = $powershelll_installFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershelll_installFile = $powershelll_installFile.Replace('!!logdir!!', $logdir)
			$powershelll_installFile = $powershelll_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershelll_installFile = $powershelll_installFile.Replace('!!versie!!', $powershellversie)
			$powershelll_installFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			$powershelll_installFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			foreach ($line in $powershelll_installFile)
			{
				if ($line -like "#PowershellInstallStart*")
				{
					
					foreach ($inputLine in $powershellInputInstall)
					{
						
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
				}
				
				
			}
				
			
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$powershellpnaam\$powershellversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			
			
			
			
			
			
			[string]$powershell_uninstall_org_path = $Powershell_uninstall_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_UNinstall_org_path -Confirm:$false
			$powershellInputUNInstall = Get-Content -Path $powershell_UNinstall_org_path
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!logdir!!', $logdir)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!versie!!', $powershellversie)
			$powershell_uninstallFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			$powershell_uninstallFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			foreach ($line in $powershell_uninstallFile)
			{
				if ($line -like '#PowershellUninstallStart*')
				{
					
					foreach ($inputLine in $powershellInputUNInstall)
					{
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
				}
				
				
			}
			$powershell_output_textbox5.AppendText("`New install.ps1 and uninstall.ps1 created!`r`n")
			$powershell_output_textbox5.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
			$Powershell_testUnInstall_button2.Enabled = $true
			$Powershell_testUnInstall_button2.Visible = $true
			$Powershell_testInstall_button2.Enabled = $true
			$Powershell_testInstall_button2.Visible = $true
			$Powershell_CreateIntuneWIn_button2.Enabled = $true
			$Powershell_CreateIntuneWIn_button2.Visible = $true
			
		}
	}

}

$powershell_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	Invoke-Item "$config_packagefolder\$powershellpnaam\$powershellversie\source\"
}

$powershell_install_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_uninstall_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_packagename_textbox_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$Powershell_testInstall_button2_Click = {
	#TODO: Place custom script here
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$usercontext = 'In User context'
		$sysemcontext = $null;
		
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$usercontext = 'in Sytem context'
		$sysemcontext = 'Testing Sytem context as Elevated user;'
	}
	if ([System.Windows.Forms.MessageBox]::Show("Please test your script. After editing. Please use the save button in Powershell_ISE", "Openening Powershell_ISE in $32or64", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.Text
		$powershellversie = $powershell_packageversion_textbox.Text
		$installScript = Join-Path -Path $config_packagefolder -ChildPath "$powershellpnaam\$powershellversie\source\install.ps1"
		$ise32Path = "$env:windir\SysWOW64\WindowsPowerShell\v1.0\PowerShell_ISE.exe"
		$ise64Path = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe"
		if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
		{
				Start-Process -FilePath $ise32Path -ArgumentList $installScript
		}
		else
		{
				Start-Process -FilePath $ise64Path -ArgumentList $installScript
		}
		PowershellISEOnTop
		
	}
}

$Powershell_testUnInstall_button2_Click = {
	#TODO: Place custom script here
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$usercontext = 'In User context'
		$sysemcontext = $null;
		
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$usercontext = 'in Sytem context'
		$sysemcontext = 'Testing Sytem context as Elevated user;'
	}
	if ([System.Windows.Forms.MessageBox]::Show("Please test your script. After editing. Please use the save button in Powershell_ISE", "Openening Powershell_ISE in $32or64", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.Text
		$powershellversie = $powershell_packageversion_textbox.Text
		$installScript = Join-Path -Path $config_packagefolder -ChildPath "$powershellpnaam\$powershellversie\source\uninstall.ps1"
		$ise32Path = "$env:windir\SysWOW64\WindowsPowerShell\v1.0\PowerShell_ISE.exe"
		$ise64Path = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe"
		if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
		{
				Start-Process -FilePath $ise32Path -ArgumentList $installScript
		}
		else
		{
				Start-Process -FilePath $ise64Path -ArgumentList $installScript
		}
		PowershellISEOnTop
		
	}
}

$Powershell_CreateIntuneWIn_button2_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$powershell_output_textbox5.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$powershellpnaam\$powershellversie\source\" -s "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -o "$outputDirectory\$powershellpnaam\$powershellversie\output\" -q
	Rename-Item -Path "$outputDirectory\$powershellpnaam\$powershellversie\output\install.intunewin" -NewName "$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin"
	$powershell_output_textbox5.AppendText("`nIntunewin file created: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin")
	$powershell_output_textbox5.AppendText("`r`n")
	
	$powershell_output_textbox5.AppendText("Install command is: `r`n")
	if ($32or64 -like "32 Bit Mode")
	{
		$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
		$powershell_output_textbox5.AppendText("un-install command is: `r`n")
		$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
		$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	}
	else
	{
		$powershell_output_textbox5.AppendText("%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1 `r`n")
		$powershell_output_textbox5.AppendText("un-install command is: `r`n")
		$powershell_output_textbox5.AppendText("%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file uninstall.ps1 `r`n")
		$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	}
	
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		if ($32or64 -like "32 Bit Mode")
		{
			$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		}
		else
		{
			$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\$RegisterDetectionroot\"
		}
		
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	$powershell_output_textbox5.AppendText("$regkeyApp `r`n")
	$powershell_output_textbox5.AppendText("Detection Method is: 'String Comparison' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: 'Version' `r`n")
	$powershell_output_textbox5.AppendText("Detection Operator is: 'Equals' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: $powershellversie `r`n")
	$powershell_output_textbox5.AppendText("Please reopen tool to make another Powershell package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
		[string]$context
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$context = 'user'
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$context = 'system'
	}
	$IntuneWinPackageConfig = $null;
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $true)
	{
		$icmd = '%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1'
		$ucmd = 'SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1'
	}
	else
	{
		$icmd = "powershell -executionpolicy bypass -file install.ps1"
		$ucmd = "powershell -executionpolicy bypass -file uninstall.ps1"
	}
	
	
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$powershellpnaam.intunewin"
			DisplayName   = $powershellpnaam
			Publisher	  = $config_customername
			AppVersion    = $powershellversie;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = $icmd
			uninstallCMD  = $ucmd
			context		  = $context
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$powershellpnaam\$powershellversie\output\"
	$powershell_output_textbox5.AppendText("Config.csv written to: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv")
	$powershell_output_textbox5.AppendText("  `r`n")
	$Powershell_upload_logo_button.Enabled = $true
	$Powershell_upload_logo_button.Visible = $true
	$powershell_output_textbox5.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
	$powershell_output_textbox5.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
}

$Powershell_upload_logo_button_Click = {
	#TODO: Place custom script here
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $powershell_packagename_textbox.text
	$msiversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
	
}


$updatepackage_msi_open_config_button1_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$updatepackage_msi_appname_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appname_new_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appversion_textbox3.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$updatepackage_msi_appcustomer_textbox3.Text = $updatepackage_customername
	$updatepackage_msi_panel5.Enabled = $true
	$updatepackage_msi_panel5.Visible = $true
	$updatepackage_msi_panel4.Visible = $true
	$updatepackage_msi_panel4.Enabled = $true
}

$updatepackage_msi_label5_Click = {
	#TODO: Place custom script here
	
}

$labelAppName_Click = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_Yes_radiobutton1_CheckedChanged = {
	#TODO: Place custom script here
	if ($updatepackage_msi_Yes_radiobutton1.Checked -eq $true)
	{
		$updatepackage_msi_panel6.Enabled = $true
		$updatepackage_msi_panel6.Visible = $true
	}
	else
	{
		$updatepackage_msi_panel6.Enabled = $false
		$updatepackage_msi_panel6.Visible = $false
	}
}

$updatepackage_msi_clone_button_Click = {
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($updatepackage_msi_change_customer_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($updatepackage_msi_appversion_new_textbox3.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $updatepackage_msi_change_customer_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$updatepackage_msi_appname_new_textbox3.text = $powershellpnaam
		$powershellversie = $updatepackage_msi_appversion_new_textbox3.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_msi_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_msi_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_msi_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$versie  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_msi_output_textbox4.AppendText("config.csv creation done; Please open new package source dir and change MSI file and other source files; Step 3")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("Replace MSI file for newer version with a. MSI file with the same name or b. change the Install parameters below")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
	}
	
}


$updatepackage_msi_appname_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_appversion_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_panel5_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$updatepackage_msi_installParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_open_source_dir_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	
}

$updatepackage_msi_testinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Add-Type -AssemblyName PresentationFramework
	$imagePath = "C:\Program Files\IntunePrepTool\update_package_msi_copy_uninstallstring.png"
	$window = New-Object system.windows.window
	$window.Title = "IntunePrepTool MSI uninstall command help"
	$window.Width = 603
	$window.Height = 700
	$window.WindowStartupLocation = 'CenterScreen'
	$dockPanel = New-Object System.Windows.Controls.DockPanel
	$image = New-Object System.Windows.Controls.Image
	$image.Source = [System.Windows.Media.Imaging.BitmapImage]::new([Uri]::new($imagePath))
	$image.Stretch = "Fill"
	$button = New-Object System.Windows.Controls.Button
	$button.Content = "Understood, open PowerShell_ISE now"
	$button.Width = 250
	$button.HorizontalAlignment = "Center"
	$button.VerticalAlignment = "Bottom"
	$button.Add_Click({
			powershell_ise -file "$newpackage_sourcepath\install.ps1"
			$window.Close() # Close the window after opening PowerShell ISE
		})
	[System.Windows.Controls.DockPanel]::SetDock($button, [System.Windows.Controls.Dock]::Bottom)
	$dockPanel.Children.Add($button)
	$dockPanel.Children.Add($image)
	$window.Content = $dockPanel
	$window.ShowDialog()
	
	
	$updatepackage_msi_panel66.Enabled = $true
}

$updatepackage_msi_saveinstallparemeters_button_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_testinstall_button1.Enabled = $true
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_installParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\i.cmd" -encoding ascii -Force -ErrorAction Stop
}

$updatepackage_msi_testuninstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_uninstallParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\u.cmd" -encoding ascii -Force -ErrorAction Stop
	$updatepackage_msi_testuinstall_button1.Enabled = $true
}

$updatepackage_msi_uninstallParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_testuinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
	$updatepackage_msi_panel67.Enabled = $true
}

$updatepackage_msi_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_msi_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_msi_output_textbox4.AppendText("`r`n")
	
	$updatepackage_msi_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
	
}



$exe_open_Azure_OpenAI_Example_button1_Click = {
	#TODO: Place custom script here
	
	if (!(Test-Path "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"))
	{
		[void][System.Windows.Forms.MessageBox]::Show("Go to config tab to configure Azure AI OpenAI Deployment", 'Please setup Azure AI Config first')
	}
	else
	{
		$OpenAICSV = Import-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"
		
		
		$exe_appDname = $exe_packagenaam_textbox1.Text
		$EXEName = $exe_openfiledialog1.SafeFileName
		$apiKey = $OpenAICSV.Key
		$endpoint = $OpenAICSV.endpointURL
		$deployname = $OpenAICSV.deploymentName
		$uri = $endpoint + "openai/deployments/" + $deployname + "/chat/completions?api-version=2024-02-15-preview"
		$body = @"
{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Show example of silent install parameters for $exe_appDname EXE file: $EXEName"
        }
      ]
    }
  ],
  "temperature": 0.4,
  "top_p": 0.95,
  "max_tokens": 800
}
"@
		
		
		$headers = @{
			"Content-Type" = "application/json"
			"api-key"	   = $apiKey
		}
		try
		{
			$request = Invoke-RestMethod -Method POST -Uri $uri -ContentType "application/json" -Body $body -Headers $headers -ErrorAction Stop
			$text = $request.choices.message.content
			$startPattern = '```sh'
			$endPattern = '```'
			$start = $text.IndexOf($startPattern) + $startPattern.Length
			$end = $text.IndexOf($endPattern, $start)
			
			
			if ($start -ge 0 -and $end -gt $start)
			{
				$command = $text.Substring($start, $end - $start).Trim()
				
				$commandParts = $command -split " "
				$commandWithoutExe = $commandParts[1 .. ($commandParts.Length - 1)] -join " "
				
				$exe_parsInstall_textbox1.Text = "`"$commandWithoutExe`""
				$text = $text -replace '```sh', ""
				$text = $text -replace '`', ""
				$exe_richtextbox3.Text = $text
				$exe_panel5.Enabled = $true
				$exe_panel5.Visible = $true
				$exe_open_Azure_OpenAI_Example_button1.Text = "Retry Azure OpenAI"
				
			}
			
		}
		catch
		{
			
			if ($_.Exception.Message -like 'The remote server returned an error: (429) Too Many Requests.')
			{
				
				[void][System.Windows.Forms.MessageBox]::Show('Please wait 30 seconds before trying again', '(429) Too Many Requests.')
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show("($_.Exception.Message)", 'Error message')
			}
		}
	}
}

$config_openAI_save_button2_Click = {
	#TODO: Place custom script here
	class openAIAzure {
		[string]$key
		[string]$endpointURL
		[string]$deploymentName
		
	}
	$openAIAzure = $null;
	$openAIAzure += @([openAIAzure]@{
			key		       = $config_openAI_textbox6.Text
			endpointURL    = $config_openAI_textbox7.Text
			deploymentName = $config_openAI_textbox8.Text
			
		})
	
	$openAIAzure | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv" -NoTypeInformation -Force
	[void][System.Windows.Forms.MessageBox]::Show('U can use the Azure OpenAI button in the tool now', 'CSV file with config written to  c:\users\$env:USERNAME\.IntunePrepTool\')
	
}


$config_openAI_help_Click = {
	#TODO: Place custom script here
	Invoke-Item "C:\Program Files\IntunePrepTool\IntunePrepTool-AzureOpenAI-setup-Screenshots.pdf"

}




$config_openAI_textbox8_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox7_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox6_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_radiobutton2_CheckedChanged={
	#TODO: Place custom script here
	
}

$updatePackageIntunewinToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$updatepackage_exe_open_config_button1_Click={
	#TODO: Place custom script here
	$update_exe_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$update_exe_appname_old_textbox5.Text = $ConfigCSVImport.DisplayName
	$update_exe_new_appname_textbox7.Text = $ConfigCSVImport.DisplayName
	$update_exe_appversion_old_textbox4.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$update_exe_customer_old_textbox3.Text = $updatepackage_customername
	$updatepackage_EXE_panel6.Enabled = $true
	$updatepackage_EXE_panel6.Visible = $true
	$update_exe_panel4.Visible = $true
	$update_exe_panel4.Enabled = $true
}

$update_exe_buttonStep2CloneToNewDirec_Click={
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($update_exe_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($update_exe_new_appversion_textbox6.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $update_exe_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $update_exe_new_appname_textbox7.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$update_exe_new_appname_textbox7.text = $powershellpnaam
		$powershellversie = $update_exe_new_appversion_textbox6.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_exe_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_exe_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $update_exe_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_exe_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appName =*') -or ($lni -like '$version  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$appName =*') -or ($lni -like 'Versie =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("Replace EXE file for newer version with a. EXE file with the same name or b. change the Install parameters below")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		<#
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		#>
		$update_exe_panel6.Enabled = $true
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		foreach ($lni2 in $installparameters)
		{
			if ($lni2 -like '$exeParameters =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exeparameters2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exeparameters2 = $null
				}
				$exeparameters2 = $exeparameters2 -replace "^ ", ""
				$exeparameters2 = $exeparameters2.split("#")[0]
				$update_exe_installPar_textbox3.Text = $exeparameters2
			}
			if ($lni2 -like '$exeFile =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exefilename2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exefilename2 = $null
				}
				$exefilename2 = $exefilename2 -replace "^ ", ""
				
				$update_exe_Exefilename_textbox3.Text = $exefilename2
			}
			
		}

	
		$IsThisLineThereInUninstall = $old_uninstallps1 | ForEach-Object {
			if ($_ -match 'Please see u\.cmd for MSI parameters used by this script')
			{
				$_.Trim() 
			}
		} | Where-Object { $_ }
		if ($IsThisLineThereInUninstall)
		{
			Write-Host "De regel is aanwezig: $IsThisLineThereInUninstall"
			$update_exe_uninstall_panel6.Enabled = $false
			$update_exe_uninstall_panel6.Visible = $false
			$update_Exe_Uninstall_MSI_panel6.Enabled = $true
			$update_Exe_Uninstall_MSI_panel6.Visible = $true
			$update_exe_msi_uninstallcommandsOld = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\u.cmd"
			$udpdate_exe_msi_uninstall_textbox4.Text = $update_exe_msi_uninstallcommandsOld
			[void][System.Windows.Forms.MessageBox]::Show('See Find Uninstall String in the tools menu to search for new uninstall productcode and change the uninstall parameters after testing installation', 'Change uninstall string')
			
		}
		else
		{
			$oldInstallExeFilename = $old_installps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeFilename = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeParameters = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeParameters\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			#Write-Host "Old Install EXE Filename: $oldInstallExeFilename"
			#Write-Host "Old Uninstall EXE Filename: $oldUnInstallExeFilename"
			if ($oldInstallExeFilename -like $oldUnInstallExeFilename)
			{
				#Write-Host "Same EXE as install: $oldUnInstallExeFilename)"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
			Else
			{
				#Write-Host "Uninstall EXE path is $oldUnInstallExeFilename"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
		}
		
		
		
	}
}

$update_exe_buttonStep3OpenSourceDirec_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	$update_exe_buttonStep4SaveInstallPara.Enabled = $true
}

$update_exe_buttonStep4SaveInstallPara_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$installparameters = Get-Content "$newpackage_sourcepath\install.ps1"
	Remove-Item "$newpackage_sourcepath\install.ps1"
	foreach ($lni2 in $installparameters)
	{
		if (($lni2 -like '$exeParameters =*') -or ($lni2 -like '$exeFile =*'))
		{
			
			
			if ($lni2 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_installPar_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
			if ($lni2 -like '$exeFile =*')
			{
				
				'$exeFile = ' + $update_exe_Exefilename_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
		}
		else
		{
			$lni2 | Out-File "$newpackage_sourcepath\install.ps1" -Append
		}
		
	}
	$update_exe_buttonStep5TestAndEditInst.Enabled = $true
}

$update_exe_buttonStep5TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\install.ps1"
	
}

$buttonStep7TestAndEditUnin_Click={
	#TODO: Place custom script here
	
}

$update_exe_uninstall_msi_save_button3_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$udpdate_exe_msi_uninstall_textbox4.Text | Out-File "$newpackage_sourcepath\u.cmd" -Force
	$update_exe_uninstall_MSI_Test_button2.Enabled = $true
}

$update_exe_uninstall_MSI_Test_button2_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$buttonStep6SaveUninstallPa_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$uninstall_exe_uninstall = Get-Content "$newpackage_sourcepath\uninstall.ps1"
	Remove-Item "$newpackage_sourcepath\uninstall.ps1" -Confirm:$false -Force
	foreach ($lni5 in $uninstall_exe_uninstall)
	{
		if (($lni5 -like '$exeFile =*') -or ($lni5 -like '$exeParameters =*'))
		{
			if ($lni5 -like '$exeFile =*')
			{
				'$exeFile = ' + $update_exe_filetpathUninstall_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
			if ($lni5 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_uninstall_parameters_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
		}
		else
		{
			$lni5 | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			
		}
		
	}
	$update_exe_testuninstall_exe_buttonStep7TestAndEditInst.Enabled = $true
	
}

$update_exe_testuninstall_exe_buttonStep7TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$update_exe_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $update_exe_new_appname_textbox7.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_exe_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_exe_output_textbox4.AppendText("`r`n")
	
	$updatepackage_exe_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
}


$tools_choco_search_button2_Click={
	#TODO: Place custom script here
	
	
	function chocoSearch
	{
		param (
			[Parameter(Mandatory = $true)]
			[string]$name,
			[bool]$approvedOnly = $false
		)
		
		$chocoSearch = choco find $name --order-by-popularity
		if ($chocoSearch.Count -gt 2)
		{
			$chocoSearch = $chocoSearch[1 .. ($chocoSearch.Count - 2)]
		}
		
		$results = @()
		
		foreach ($ch in $chocoSearch)
		{
			$splitLine = $ch.Split(" ", 3, [System.StringSplitOptions]::RemoveEmptyEntries)
			if ($splitLine.Count -lt 2)
			{
				continue
			}
			
			$currentName = $splitLine[0]
			$currentVersion = $splitLine[1]
			$remaining = ""
			if ($splitLine.Count -eq 3)
			{
				$remaining = $splitLine[2]
			}
			if ($ch -match 'found|know|Learn')
			{
				continue
			}
			$isApproved = ($remaining -match '\[Approved\]')
			if ($approvedOnly -and -not $isApproved)
			{
				continue
			}
			$obj = [pscustomobject]@{
				Name	 = $currentName
				Version  = $currentVersion
				Approved = $isApproved
			}
			
			$results += $obj
		}
		
		return $results
	}
	$sChoco = $tools_choco_search_textbox3.Text
	
	
	if ($tools_choco_checkbox1.Checked -eq $true)
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $true
	}
	else
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $false
	}
	try
	{
		New-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script
	}
	

	$tools_choco_treeview2.BeginUpdate()
	$tools_choco_treeview2.Refresh()
	$tools_choco_treeview2.Nodes.Clear()
	#$tools_choco_treeview2.CheckBoxes = $true
	$Root = $tools_choco_treeview2.Nodes.Add("Choco Packages")
	foreach ($p in $chocoOutput)
	{
		#$upload_treeview2.Nodes.Add($tenantCSV.customername)
		$node = $Root.Nodes.Add($p.Name)
		
		$node.ContextMenuStrip = $tools_choco_contextmenustrip1
		#$node.Tag = $tenantCSV.target
		$node.Name = $p.Name
		
		
	}
	$Root.Expand()
	$tools_choco_treeview2.EndUpdate()
}

$config_tenants_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}



$tools_choco_contextmenustrip1_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$choco_toolstripmenuitem1_Click= {
	#TODO: Place custom script here
	

}
$tools_choco_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$chocoAll = Get-Variable -Name 'chocoOutput2' -Scope Script -ValueOnly
	$tools_choco_details_richtextbox1.text = ""
	
	foreach ($ch1 in $chocoAll)
	{
		if ($ch1.Name -eq $tools_choco_treeview2.SelectedNode.Name)
		{
			$tools_choco_panel6.Enabled = $true
			$tools_choco_selected_label6.Enabled = $true
			$tools_choco_selected_label6.Visible = $true
			$tools_choco_selected_label6.Text = $ch1.Name
			$chocoDetails = choco find $ch1.Name --exact --detail
			foreach ($ch2 in $chocoDetails)
			{
				$tools_choco_details_richtextbox1.AppendText("`r`n")
				$tools_choco_details_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}



$tools_choco_createdir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $tools_choco_displayname_textbox3.text
	$exeversie = $tools_choco_appversion_textbox3.text
	$exepnaam = $exepnaam -replace (" ", "")
	$tools_choco_displayname_textbox3.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$tools_choco_output_textbox3.Text = "`nNew package directory created: `r`n"
			$tools_choco_output_textbox3.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$tools_choco_output_textbox3.AppendText("`r`n")
			$tools_choco_panel7.Enabled = $true
			$tools_choco_open_PackageDir_button2.Enabled = $true
			$tools_choco_buttonOpenPackageDirectory.Enabled = $true
			$tools_choco_buttonOpenPackageDirectory.Visible = $true
		}
	}
}
$tools_choco_displayname_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_appversion_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_createscriots_button2_Click={
	#TODO: Place custom script here
	$choco_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:19
	 Created by:   	Rink Turksma
	 Organization: 	https://githhub.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"
$paramsChoco = "!!paramsChocho!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
if (!(test-path -Path "$env:programdata\chocolatey"))
	{
		write-host "Installing Chocolatey"
		[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
	}


write-host "Now installing: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green
try
{
	write-host "Choco installation started" -ForegroundColor Green
	if ($paramsChoco -eq 'false')
	{
		choco install $chocoName --exact --yes --force
	}
	else
	{
		choco install $chocoName --exact --params $paramsChoco --yes --force
	}
	write-host "Installation success" -ForegroundColor Green
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	write-host "Now creating weekly scheduled task to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek Monday -At 10:00
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}

if ($startupUpdateTask -eq 'true')
{
	write-host "Now creating scheduled task at startup to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -AtStartup
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}


try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	fDetectionInRegistry -succes $true
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	$choco_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:25
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
write-host "Now uninstalling: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green




try
{
	write-host "Choco uninstallation started" -ForegroundColor Green
	choco uninstall $chocoName --exact --yes --force
	write-host "UnInstallation success" -ForegroundColor Green
}
catch
{
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}
if ($startupUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
	
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000)
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	remove-item $regkeyApp
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$RegisterDetectionroot = "Intune_" + $config_customername
	$appVersion = $tools_choco_appversion_textbox3.text
	$appName = '"' + $tools_choco_displayname_textbox3.text + '"'
	$appName2 = $tools_choco_displayname_textbox3.text
	$chocoName = $tools_choco_selected_label6.Text
	
	$choco_installFile  = $choco_installFile.Replace('"!!AppName!!"', $appName)
	$choco_installFile  = $choco_installFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_installFile  = $choco_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_installFile  = $choco_installFile.Replace('!!version!!', $appVersion)
	$choco_installFile = $choco_installFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true' 
	$choco_installFile = $choco_installFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true) { $paramschoco = $tools_choco_parammstextbox3.Text; $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', $paramschoco) }
	else { $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', 'false') }
	try
	{
		$choco_installFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$appName2\$appVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	$choco_uninstallFile = $choco_uninstallFile.Replace('"!!AppName!!"', $appName)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!version!!', $appVersion)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true'
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	try
	{
		$choco_uninstallFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\uninstall.ps1" -Force -ErrorAction Stop
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
		$tools_choco_panel11.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 NOT created `r`n")
	}
}

$tools_choco_open_PackageDir_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$AppVersion = $tools_choco_appversion_textbox3.text
	Invoke-Item "$config_packagefolder\$appName\$appVersion\"
}

$tools_choco_testinstall_button2_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$appName = $tools_choco_displayname_textbox3.text
		$appVersion = $tools_choco_appversion_textbox3.text
		powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$tools_choco_testUNinstall_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	$tools_choco_addBuildingBlocksCSVButton.Enabled = $true
}

$config_download_Choco_MSIX_bundle_Click={
	#TODO: Place custom script here
	
	$config_install_required_chocolatey = @'
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$picturebox1_Click={
	#TODO: Place custom script here
	
}

$tools_choco_AddParams_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true)
	{
		$tools_choco_parammstextbox3.Enabled = $true
		$tools_choco_parammstextbox3.Visible = $true
	}
	else
	{
		$tools_choco_parammstextbox3.Enabled = $false
		$tools_choco_parammstextbox3.Visible = $false
	}
}

$tools_choco_create_intunewin_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$appName\$appVersion\source\" -s "$config_packagefolder\$appName\$appVersion\source\install.ps1" -o "$config_packagefolder\$appName\$appVersion\output\" -q
	Rename-Item -Path "$config_packagefolder\$appName\$appVersion\output\install.intunewin" -NewName "$config_packagefolder\$appName\$appVersion\output\$appName.intunewin"
	$tools_choco_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\$appName.intunewin")
	$tools_choco_output_textbox3.AppendText("`r`n")
	
	$tools_choco_output_textbox3.AppendText("Install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("un-install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$appName\"
	$regkeyApp
	$tools_choco_output_textbox3.AppendText("$regkeyApp `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: $appVersion `r`n")
	$tools_choco_output_textbox3.AppendText("Please reopen tool to make another Chocolatey package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$appName.intunewin"
			DisplayName   = $appName
			Publisher	  = $config_customername
			AppVersion    = $appVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$appName\$appVersion\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$appName\$appVersion\output\"
	$tools_choco_output_textbox3.AppendText("Config.csv written to naar: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\config.csv")
	$tools_choco_output_textbox3.AppendText("  `r`n")
	$buildingBlokcsCSV = $choco_buildingBlocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$config_packagefolder\$appName\$appVersion\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appName\BuildingBlocks.csv" -force -NoTypeInformation
		$tools_choco_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$tools_choco_output_textbox3.AppendText("$config_buildingblockspath\$appName\BuildingBlocks.csv `r`n")
		$tools_choco_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$tools_choco_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$tools_choco_output_textbox3.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$tools_choco_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
	
}

$tools_choco__upload_logo_button2_Click={
	#TODO: Place custom script here
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $tools_choco_displayname_textbox3.text
	$msiversie = $tools_choco_appversion_textbox3.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
	$tools_choco_output_textbox3.AppendText("`r`n")
	$tools_choco_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}

$winget_search_button2_Click={
	$downloadWingetSearchText = $winget_search_textbox3.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$winget_output_textbox3.Text = $null
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	$winget_search_treeview2.BeginUpdate()
	$winget_search_treeview2.Refresh()
	$winget_search_treeview2.Nodes.Clear()
	$Root = $winget_search_treeview2.Nodes.Add("Winget Packages")
	$wingetOutp1 = @()
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$wingetOutp2 = $row_download_winget | Select ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$wingetOutp1 += [PSCustomObject]@{ ID = $wingetOutp2 }
				$node = $Root.Nodes.Add($download_winget_listboxInput)
				$node.Name = $wingetOutp2
			}
			$table_download_winget.AcceptChanges();	
			
		}
		
	}
	$Root.Expand()
	$winget_search_treeview2.EndUpdate()
	try
	{
		New-Variable -Name 'wingetOutput' -Value $wingetOutp1 -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'wingetOutput' -Value $wingetOutp1 -Scope Script
	}
	
	
}

$winget_search_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$wingetAll = Get-Variable -Name 'wingetOutput' -Scope Script -ValueOnly
	$winget_show_info_richtextbox1.text = $null;
	foreach ($ch1 in $wingetAll.ID)
	{
		if ($ch1 -eq $winget_search_treeview2.SelectedNode.Name)
		{
			#$tools_choco_panel6.Enabled = $true
			#$tools_choco_selected_label6.Enabled = $true
			#$tools_choco_selected_label6.Visible = $true
			#$tools_choco_selected_label6.Text = $ch1.Name
			#$winget_settings_panel7.Enabled = $true;
			$winget_selected_panel7.Enabled = $true
			$winget_createPackageDIR_panel7.Enabled = $true
			$wingetDetails = winget show --id $ch1
			$ch1 = $ch1.Replace('"','')
			$winget_WingetID_textbox1.Text = $ch1
			foreach ($ch2 in $wingetDetails)
			{
				$winget_show_info_richtextbox1.AppendText("`r`n")
				$winget_show_info_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}

$winget_CreatePackageDir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$version = $versie_textbox2.Text
		if ($version -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
		
			if (!(Test-Path -Path "$config_packagefolder\$DisplayName\$version\source"))
			{
				
				New-Item -ItemType Directory -Path "$config_packagefolder\$DisplayName\$version\source"
			}
			if (!(Test-Path -Path "$config_packagefoldery\$DisplayName\$version\output"))
			{
				
				New-Item -ItemType Directory -Path "$config_packagefolder\$DisplayName\$version\output"
			}
			$winget_open_package_dir_button3.Enabled = $true
			$winget_settings_panel7.Enabled = $true
			$winget_buttonAddCustomDescription.Enabled = $true
			$winget_buttonAddCustomDescription.Visible = $true
			
		}
	}
}
$winget_open_package_dir_button3_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$version = $versie_textbox2.Text
	Invoke-Item "$config_packagefolder\$DisplayName\$version"
}

$checkbox1_CheckedChanged={
	#TODO: Place custom script here
	
}

$radiobutton64Bit_CheckedChanged={
	#TODO: Place custom script here
	
}

$config_version_label1_Click={
	#TODO: Place custom script here
	
}

$config_install_sandbox_buttonInstallSanboxPowersh_Click={
	#TODO: Place custom script here
	$config_install_required_chocolatey = @'
Enable-WindowsOptionalFeature -FeatureName "Containers-DisposableClientVM" -All -Online
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installSandbox.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey | Out-File "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installSandbox.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey | Out-File "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$config_add_Tenant_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}



$registryToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}


$capture_registry_loadTreeview_button2_Click={
	#TODO: Place custom script here

		

	
	
}

$Registry_capture_panel7_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$capture_registry_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	#Source https://www.sapien.com/forums/viewtopic.php?t=11679
	if ($_.Node.Nodes.Count -eq 0)
	{
		foreach ($keyName in ($_.Node.Tag.GetSubkeyNames()))
		{
			Try
			{
				$regKey = $_.Node.Tag.OpenSubKey($keyName)
				$n = New-Object System.Windows.Forms.TreeNode
				$n.Name = $regKey.PsPath
				$n.Text = $keyName
				$n.Tag = $regKey
				$_.Node.Nodes.Add($n)
			}
			Catch
			{
				Write-Host $_
			}
		}
	}

}

$registry_capture_tabpage5_Click={
	#TODO: Place custom script here
	
}

$Registry_Capture_Step2_CreateBackup_button2_Click = {
	if ($registry_name_textbox3.Text -notlike $null)
	{
		
		$node = $capture_registry_treeview2.SelectedNode
		$nodeTexts = @()
		while ($node)
		{
			$nodeTexts += $node.Text
			$node = $node.Parent
		}
		$reversedNodeTexts = @()
		for ($i = $nodeTexts.Count - 1; $i -ge 0; $i--)
		{
			$reversedNodeTexts += $nodeTexts[$i]
		}
		$rootHive = ""
		$allNodesString = $rootHive + ($reversedNodeTexts -join "\")
		
		$RegistryCaptureScript = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	22-3-2025 20:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	regcompare.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$regexportpath = "!!regexportpath!!"
$backupFolder = "!!backupFolder!!"
if (!(Test-Path $backupFolder))
{
	New-Item -Path $backupFolder -ItemType Directory | Out-Null
}
$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$preBackupPath = Join-Path $backupFolder "PreChanges_$timeStamp.reg"
$postBackupPath = Join-Path $backupFolder "PostChanges_$timeStamp.reg"
$DiffRegName = "!!DiffRegName!!"
$diffPath = Join-Path $backupFolder "$DiffRegName`_$timeStamp.reg"

Write-Host "Exporting registry from: $regExportPath"  
Write-Host "Creating first registry backup (pre-changes)..."  
reg export "$regExportPath" "$preBackupPath" /y | Out-Null
Write-Host "  Pre-changes backup saved to: $preBackupPath`n"
Write-Host "Make any desired changes to your registry/application now." -ForegroundColor Green
Write-Host "Press ENTER when finished..." -ForegroundColor Green
Read-Host
Write-Host "`nCreating second registry backup (post-changes)..."  
reg export "$regExportPath" "$postBackupPath" /y | Out-Null
Write-Host "  Post-changes backup saved to: $postBackupPath`n"  
Write-Host "Now comparing backups to find differences..."  

function Compare-RegFiles
{
	param (
		[string]$OldRegPath,
		[string]$NewRegPath,
		[string]$DiffOutPath
	)
	
	$oldLines = [System.IO.File]::ReadAllLines($OldRegPath)
	$newLines = [System.IO.File]::ReadAllLines($NewRegPath)
	$oldHashSet = [System.Collections.Generic.HashSet[string]]::new($oldLines)
	$differences = New-Object System.Collections.Specialized.OrderedDictionary
	$currentKey = $null
	foreach ($line in $newLines)
	{
		if ($line -match '^\[\S+\]$')
		{
			$currentKey = $line
			continue
		}
		if ($line -match '^\S+=' -and $currentKey)
		{
			if (-not $oldHashSet.Contains($line))
			{
				if (-not $differences.Contains($currentKey))
				{
					$differences[$currentKey] = [System.Collections.Generic.List[string]]::new()
				}
				$differences[$currentKey].Add($line)
			}
		}
	}
	if ($differences.Count -gt 0)
	{
		Set-Content -Path $DiffOutPath -Value "Windows Registry Editor Version 5.00`r`n"
		foreach ($key in $differences.Keys)
		{
			Add-Content -Path $DiffOutPath -Value "`r`n$key"
			foreach ($val in $differences[$key])
			{
				Add-Content -Path $DiffOutPath -Value $val
			}
		}
		Write-Host "Differences found! Saved to: $DiffOutPath" -ForegroundColor Green
		$DiffOutPath | out-file "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt" -force
	}
	else
	{
		Write-Host "No differences detected."  
		if (Test-Path $DiffOutPath)
		{
			Remove-Item $DiffOutPath -ErrorAction SilentlyContinue
		}
	}
}

Compare-RegFiles -OldRegPath $preBackupPath `
				 -NewRegPath $postBackupPath `
				 -DiffOutPath $diffPath


Write-Host "`nRemoving the two backup files..."  
Remove-Item -Path $preBackupPath -ErrorAction SilentlyContinue
Remove-Item -Path $postBackupPath -ErrorAction SilentlyContinue

Write-Host "`nAll done. Please close this Powershell_ISE window and continue in the IntunePrepTool"


'@
		if (Get-Process -Name "powershell_ise" -ErrorAction SilentlyContinue)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please close any existing Powershell_ISE windows, When done.. Start again', 'Please close existing Powershell_ISE windows')
		}
		else
		{
			
			if ($registry_name_textbox3.text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please select Name first, When done.. Start again', 'Please select Name first')
			}
			else
			{
				if ($Registry_HKLM_radiobutton1.Checked -eq $true)
				{
					$regName = "HKLM_"
				}
				if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
				{
					$regName = "HKCU_"
				}
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!regexportpath!!", $allNodesString)
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$BackupLocation = $config_packagefolder + '\' + "0_BuildingBlocks\Registry"
				$BackupLocation = $BackupLocation -replace ("\\", "\")
				$regName2 = $regName + $registry_name_textbox3.text
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!DiffRegName!!", $regName2)
				
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!backupFolder!!", $BackupLocation)
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!DiffRegName!!", $regName2)
				
				
				
				if (!(Test-Path "C:\Program Files\IntunePrepTool\regcompare.ps1" -PathType Leaf))
				{
					$RegistryCaptureScript | Out-File "C:\Program Files\IntunePrepTool\regcompare.ps1"
					powershell_ise -file "C:\Program Files\IntunePrepTool\regcompare.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
				else
				{
					try
					{
						Remove-Item "C:\Program Files\IntunePrepTool\regcompare.ps1" -Confirm:$false -ErrorAction Stop
						$RegistryCaptureScript | Out-File "C:\Program Files\IntunePrepTool\regcompare.ps1"
						powershell_ise -file "C:\Program Files\IntunePrepTool\regcompare.ps1"
						Start-Sleep 1
						PowershellISEOnTop
					}
					catch
					{
						[void][System.Windows.Forms.MessageBox]::Show('When done.. Start again', 'Please close existing Powershell_ISE windows')
					}
					
					
				}
			}
		}
	}
	else
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Enter name and start again please', 'Please enter Name first')
	}
	
	
	
}



$Registry_load_button2_Click={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$capture_registry_treeview2.Refresh()
		$capture_registry_treeview2.Nodes.Clear()
		$capture_registry_treeview2.Refresh()
		if ($Registry_HKLM_radiobutton1.Checked -eq $true)
		{
			$regKey = Get-Item HKLM:\ -ErrorAction SilentlyContinue
		}
		if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
		{
			$regKey = Get-Item HKCU:\
		}
		
		$n = New-Object System.Windows.Forms.TreeNode
		$n.Name = $regKey.PsPath
		$n.Text = $regKey.Name
		$n.Tag = $regKey
		$capture_registry_treeview2.Nodes.Add($n)
		
		
	
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$toolstripstatuslabel1.Text = "Selected Customer: $config_customername"
	}
	
}

$registry_capture_label5_Click={
	#TODO: Place custom script here
	
}

$registry_name_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$registry_button2_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Please remove all irrelevant items and then click Save in Notepad.', 'Edit .reg file in Notepad')
	$regfile = Get-Content "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt"
	notepad $regfile
	
}

$buttonStep6AddBuildingBloc_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$BackupLocation = $config_packagefolder + '\' + "1_BuildingBlocksPackages\Registry"
	$BackupLocation = $BackupLocation -replace ("\\", "\")
	$regfile = Get-Content "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt"
	
	if ($Registry_HKLM_radiobutton1.Checked -eq $true)
	{
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if([System.Windows.Forms.MessageBox]::Show('In this case, a separate package is not needed. You can also add the created .reg file to your existing MSI, MSIX, or EXE package. Do you want to continue creating a separate package?', 'HKLM selected',[System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
			$systemoruser = "system"
			$regName = "HKLM_"
			$registry_output_textbox3.Text = "Creating Building Block Package in the System context"
			$registry_output_textbox3.AppendText("  `r`n")
			$BuildingBlockRegistrySystem = @'
if (Test-Path 'hklm.reg') {
    Write-Host "hklm.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hklm.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}

'@
			$BackupLocation = $BackupLocation + "\system\"
			$regName2 = $regName + $registry_name_textbox3.text
			$BackupLocation = $BackupLocation + $regName2
			if (!(Test-Path $backupLocation))
			{
				New-Item -Path $backupLocation -ItemType Directory -Force | Out-Null
				$registry_output_textbox3.AppendText("$backupLocation created")
				$registry_output_textbox3.AppendText("  `r`n")
			}
			else
			{
				$registry_output_textbox3.AppendText("$backupLocation already exists")
				$registry_output_textbox3.AppendText("  `r`n")
			}
			$BuildingBlockRegistrySystem | Out-File "$BackupLocation\BuildingBlock.ps1"
			$registry_output_textbox3.AppendText("BuildingBlock.ps1 created")
			$registry_output_textbox3.AppendText("  `r`n")
			Copy-Item $regfile "$backupLocation\hklm.reg"
			$registry_output_textbox3.AppendText("hklm.reg created")
			$registry_output_textbox3.AppendText("  `r`n")
			$registry_output_textbox3.AppendText("You can use this Building Block with other Building Blocks by selecting the System Context when creating the Intunewin file using the 'Building Blocks → Intunewin' function.")
			$registry_buidingblocksfiledir_textbox3.Text = $BackupLocation
			
		}
	}
	if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
	{
		$systemoruser = "user"
		$regName = "HKCU_"
		$registry_output_textbox3.Text = "Creating Building Block Package in the User context"
		$registry_output_textbox3.AppendText("  `r`n")
		$BuildingBlockRegistryUser = @'
if (Test-Path 'hkcu.reg') {
    Write-Host "hkcu.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hkcu.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
'@
		$BackupLocation = $BackupLocation + "\User\"
		$regName2 = $regName + $registry_name_textbox3.text
		$BackupLocation = $BackupLocation + $regName2
		if (!(Test-Path $backupLocation))
		{
			New-Item -Path $backupLocation -ItemType Directory -Force | Out-Null
			$registry_output_textbox3.AppendText("$backupLocation created")
			$registry_output_textbox3.AppendText("  `r`n")
		}
		else
		{
			$registry_output_textbox3.AppendText("$backupLocation already exists")
			$registry_output_textbox3.AppendText("  `r`n")
		}
		$BuildingBlockRegistryUser | Out-File "$BackupLocation\BuildingBlock.ps1"
		$registry_output_textbox3.AppendText("BuildingBlock.ps1 created")
		$registry_output_textbox3.AppendText("  `r`n")
		Copy-Item $regfile "$BackupLocation\hkcu.reg"
		$registry_output_textbox3.AppendText("hkcu.reg created")
		$registry_output_textbox3.AppendText("  `r`n")
		$registry_output_textbox3.AppendText("You can use this Building Block with other Building Blocks by selecting the User Context when creating the Intunewin file using the 'Building Blocks → Intunewin' function.")
		#$registry_buidingblocksfiledir_textbox3.Text = $BackupLocation
		
		
	}
	
	

	
	
	
	
}

$msi_addBuildBlock_regHKLM_Click={
	#TODO: Place custom script here
	<#
	$msi_add_HKLM_openfiledialog1.ShowDialog()
	$msi_reg_hklm_label5.Text = $msi_add_HKLM_openfiledialog1.SafeFileName
	$msi_reg_hklm_label5.Visible = $true
	$msi_reg_hklm_label5.Enabled = $true
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$paname = $msi_packagenaam_textbox1.text
	$paversion = $msi_versie_textbox1.text
	$selectedpadir = "$config_packagefolder\$paname\$paversion\source"
	$msi_output_textbox1.AppendText("`n.reg file will now be copied`r`n")
	[string]$msi_reg_hklm_org_path = $msi_add_HKLM_openfiledialog1.FileNames
	Copy-Item -Path $msi_reg_hklm_org_path -Destination "$selectedpadir\hklm.reg"
	$msi_output_textbox1.AppendText("`n.reg file copy done to HKLM.reg `r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("There`'s no need to recreate your install.ps1 script when already created. The created install.ps1 already checks for a file named 'hklm.reg' and imports it when available.", 'HKLM.reg file added') # Casting the method to [void] suppresses the output. 
	#>
}

$buttonOptionalOpenRegedit_Click={
	#TODO: Place custom script here
	regedit
}

$capture_registry_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$node = $capture_registry_treeview2.SelectedNode
	$nodeTexts = @()
	while ($node)
	{
		$nodeTexts += $node.Text
		$node = $node.Parent
	}
	$reversedNodeTexts = @()
	for ($i = $nodeTexts.Count - 1; $i -ge 0; $i--)
	{
		$reversedNodeTexts += $nodeTexts[$i]
	}
	$rootHive = ""
	$allNodesString = $rootHive + ($reversedNodeTexts -join "\")
	$registry_selected_textbox3.Text = $allNodesString
}

$Registry_OpenBuildingBLockLocationbutton2_Click={
	#TODO: Place custom script here
	explorer $registry_buidingblocksfiledir_textbox3.Text
}

$file_loadFolder_button2_Click={
	#TODO: Place custom script here
	$file_folderbrowsermoderndialog2.ShowDialog()
	$file_selected_source_folder_textbox3.Text = $file_folderbrowsermoderndialog2.SelectedPath
	$file_folder_destination_textbox3.Text = $file_folderbrowsermoderndialog2.SelectedPath
}

$hscrollbar1_Scroll=[System.Windows.Forms.ScrollEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ScrollEventArgs]
	#TODO: Place custom script here
	
}

$addFolderToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-BuildingBlocksFilesAndFolders_psf) -eq 'OK')
	{
		
	}
	
	<#
	$file_folder_panel8.Enabled = $true
	$file_folder_panel8.Visible = $true
	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
#>
	}

$file_folder_cancel_buttonAdd_Click={
	#TODO: Place custom script here
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false

}

$file_folder_add_button2_Click={
	#TODO: Place custom script here
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false
	
	if ($file_folder_skip_checkbox1.Checked -eq $true) {
		$file_folder_SKIP = $true
	}
	if ($file_folder_skip_checkbox1.Checked -eq $FALSE)
	{
		$file_folder_SKIP = $false
	}
	
	if ($file_folder_overwrite_checkbox1.Checked -eq $true)
	{
		$file_folder_overwrite = $true
	}
	if ($file_folder_overwrite_checkbox1.Checked -eq $FALSE)
	{
		$file_folder_overwrite = $false
	}
	
	
	$row = $table.NewRow();
	$row["Sort"] = 'folder';
	$row["Source"] = $file_selected_source_folder_textbox3.text;
	$row["Destination"] = $file_folder_destination_textbox3.Text;
	$row["Skip"] = $file_folder_SKIP;
	$row["Overwrite"] = $file_folder_overwrite;
	$table.Rows.Add($row);
	
	## - Save changes to the table:
	$table.AcceptChanges();
	## - Display custom data created:
	#$files_folders_datagridview1.DataSource = $table;
	
	
}

$config_tenant_info_secret_delete_button2_Click={
	#TODO: Place custom script here
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$file_file_cancel_buttonAdd_Click={
	#TODO: Place custom script here
	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
}

$addFileToolStripMenuItem_Click={
	#TODO: Place custom script here
	$file_file_panel8.Enabled = $true
	$file_file_panel8.Visible = $true
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false
}

$file_loadFile_button2_Click={
	#TODO: Place custom script here
	$file_file_openfiledialog1.ShowDialog()
	$file_selected_source_file_textbox3.Text = $file_file_openfiledialog1.FileNames
	$file_file_destination_textbox3.Text = $file_file_openfiledialog1.FileNames
}

$file_file_add_button2_Click={
	#TODO: Place custom script here
	if ($file_file_skip_checkbox1.Checked -eq $true)
	{
		$file_file_SKIP = $true
	}
	if ($file_file_skip_checkbox1.Checked -eq $FALSE)
	{
		$file_file_SKIP = $false
	}
	
	if ($file_file_overwrite_checkbox1.Checked -eq $true)
	{
		$file_file_overwrite = $true
	}
	if ($file_file_overwrite_checkbox1.Checked -eq $FALSE)
	{
		$file_file_overwrite = $false
	}
	
	
	$row = $table.NewRow();
	$row["Sort"] = 'file';
	$row["Source"] = $file_selected_source_file_textbox3.text;
	$row["Destination"] = $file_file_destination_textbox3.Text;
	$row["Skip"] = $file_file_SKIP ;
	$row["Overwrite"] = $file_file_overwrite;
	$table.Rows.Add($row);
	
	## - Save changes to the table:
	$table.AcceptChanges();

	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
}

$showCompleteToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-ChildForm_psf) -eq 'OK')
	{
		
	}
}

$addRegistryToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-BuildingBlocksRegistry_psf) -eq 'OK')
	{
		
	}
}

$file_folder_tablelayoutpanel1_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$toolstripstatuslabel1_Click={
	#TODO: Place custom script here
	
}

$statusbar1_PanelClick=[System.Windows.Forms.StatusBarPanelClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.StatusBarPanelClickEventArgs]
	#TODO: Place custom script here
	
}

$user_folder_context_system_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}

$BuildingBlocks_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$building_blocks_show_Refresh_button1_Click={
	#TODO: Place custom script here
	
}

$buttonAddFileOrFolder_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage5
	if ((Show-BuildingBlocksFilesAndFolders_psf) -eq 'OK')
	{
		
	}
}

$buildingblocks_buttonAddRegistryCapture_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage6
	if ((Show-BuildingBlocksRegistry_psf) -eq 'OK')
	{
		
	}
}

$buildingBlocks_clear_button1_Click={
	#TODO: Place custom script here
	$BuildingBlocksTable.Clear()
	$BuildingBlocks_datagridview1.DataSource = $BuildingBlocksTable;
	$BuildingBlocksTable2.Clear()
	$BuildingBlocks_datagridview2.DataSource = $BuildingBlocksTable2;
	$BuildingBlocksTable3.Clear()
	$BuildingBlocks_datagridview3.DataSource = $BuildingBlocksTable3;
	
	#$buildingBlocks_panel85.Enabled = $false;
	$bb_usePackageInProgress_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $true
	$bb_usePackageInProgress_radiobutton1.Enabled = $true
	$buildingblocks_Name_textbox4.Text = $null
	$buildingblocks_version_textbox3.Text = $null
}

$tablelayoutpanel9_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$buildingblocks_add_Shortcuts_button1_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage7
	if ((Show-BuildingBlocksShortcut_psf) -eq 'OK')
	{
		
	}
}

$buttonBuild_Click={
	#TODO: Place custom script here
	if ($buildingblocks_Name_textbox4.Text -like $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Select name and try again please!", 'Please select a name for Building Blocks first') # Casting the method to [void] suppresses the output.
	}
	else
	{
		class IntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
			[string]$context
		}
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
		if ($config_buildingblockspath -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please add Building Blocks location for your customer in the Start / Config menu first", 'Building Blocks location missing!')
		}
		else
		{
			$BBAppName = $buildingblocks_Name_textbox4.Text
			if (Test-Path "$config_buildingblockspath\$BBAppName")
			{
				[void][System.Windows.Forms.MessageBox]::Show("Please remove $config_buildingblockspath\$BBAppName before you can continue", 'Location Already exists')
			}
			else
			{
				$bbSystemContext = $false
				$bbUserContext = $false
				$newNameBuildingBlocks = $buildingblocks_Name_textbox4.Text
				$newNameBuildingBlocks = $newNameBuildingBlocks -replace (' ', '')
				$buildingblocks_Name_textbox4.Text = $newNameBuildingBlocks
				$buildingblocks_output_textbox5.Text = "Building Block Name: $newNameBuildingBlocks"
				$buildingblocks_output_textbox5.AppendText("  `r`n")
				$BuildingBlocksSystemLocation = $config_buildingblockspath + '\' + $newNameBuildingBlocks + "\System"
				$BuildingBlocksSystemLocation = $BuildingBlocksSystemLocation -replace ("\\", "\")
				$BuildingBlocksUserLocation = $config_buildingblockspath + '\' + $newNameBuildingBlocks + "\User" + "\BuildingBlocksData"
				$BuildingBlocksUserLocation = $BuildingBlocksUserLocation -replace ("\\", "\")
				$buildingBlockFolder = $config_buildingblockspath + '\' + $newNameBuildingBlocks
				$buildingBlockFolder = $buildingBlockFolder -replace ("\\", "\")
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show("IntunePrepTool may temporarily become unresponsive while creating the building blocks.", 'Please wait while the building block(s) are being created.') # Casting the method to [void] suppresses the output.
				$is = 1;
				$iu = 1;
				
				
				
				if ($BuildingBlocksTable -notlike $null)
				{
					
					foreach ($r in $BuildingBlocksTable)
					{
						$BuildingBlocksFilesAndFolders = @'
$sort = "!!sort!!"
$source = "!!source!!"
$destination = "!!destination!!"
$skip = "!!skip!!"
$overwrite = "!!overwrite!!"
#Replace when needed
$destination = $destination -replace("%USERPROFILE%", $env:USERPROFILE)
$destination = $destination -replace("%APPDATA%", $env:APPDATA)
$destination = $destination -replace("%LOCALAPPDATA%", $env:LOCALAPPDATA)
Set-Location $PSScriptRoot

if (($skip -eq $true) -and ($overwrite -eq $true))
{
	Write-Host "Overwrite takes precedence over skip."
	$skip = $false
}

if (($skip -eq $false) -and ($overwrite -eq $false))
{
	Write-Host "No Skip or Overwrite selected; Overwrite takes precedence over skip."
	$overwrite = $true
}

if ($overwrite -eq $true)
{
	if ($sort -like 'folder')
	{
		if (-not (Test-Path $destination))
		{
			New-Item -ItemType Directory -Path $destination | Out-Null
		}
		Get-ChildItem -Path "Data" -Recurse | ForEach-Object {
			$targetPath = Join-Path $destination $_.FullName.Substring((Get-Item "Data").FullName.Length)
			
			if ($_.PSIsContainer)
			{
				if (-not (Test-Path $targetPath))
				{
					New-Item -ItemType Directory -Path $targetPath | Out-Null
				}
			}
			else
			{
				try
				{
					Copy-Item $_.FullName -Destination $targetPath -Force -ErrorAction Stop
					$fn = $_.FullName
					Write-Host "Copy from $fn to  $targetPath done!"
				}
				catch
				{
					$fn = $_.FullName
					Write-Error "Copy from $fn to  $targetPath failed!"
				}
				
			}
		}
	}
	
	if ($sort -like 'file')
	{
		$parentfolder = Split-Path $destination -Parent
		if (-not (Test-Path $parentfolder))
		{
			New-Item -ItemType Directory -Path $parentfolder | Out-Null
		}
		try
		{
			Copy-Item $source -Destination $destination -Force -ErrorAction Stop
			Write-Host "Copy from $source to  $destination done!"
		}
		catch
		{
			Write-Error "Copy from $source to  $destination failed!"
		}
		
	}
}

if ($skip -eq $true)
{
	if ($sort -like 'folder')
	{
		if (-not (Test-Path $destination))
		{
			New-Item -ItemType Directory -Path $destination | Out-Null
		}
		Get-ChildItem -Path "Data" -Recurse | ForEach-Object {
			$targetPath = Join-Path $destination $_.FullName.Substring((Get-Item "Data").FullName.Length)
			
			if ($_.PSIsContainer)
			{
				if (-not (Test-Path $targetPath))
				{
					New-Item -ItemType Directory -Path $targetPath | Out-Null
				}
			}
			else
			{
				if (-not (Test-Path $targetPath))
				{
					try
					{
						Copy-Item $_.FullName -Destination $targetPath -ErrorAction Stop
						$fn = $_.FullName
						Write-Host "Copy from $fn to $targetPath done!"
					}
					catch
					{
						Write-Error "Copy from $fn to $targetPath failed!"
					}
					
				}
			}
		}
	}
	
	if ($sort -like 'file')
	{
		$parentfolder = Split-Path $destination -Parent
		if (-not (Test-Path $parentfolder))
		{
			New-Item -ItemType Directory -Path $parentfolder | Out-Null
		}
		if (-not (Test-Path $destination))
		{
			try
			{
				Copy-Item $source -Destination $destination -ErrorAction Stop
				Write-Host "Copy from $source to $destination done!"
			}
			catch
			{
				Write-Host "Copy from $source to $destination failed!"
			}
			
		}
	}
}
'@
						$BuildingBlocksFilesAndFoldersUninstall = @'
$sort = "!!sort!!"
$destination = "!!destination!!"
#Replace when needed
$destination = $destination -replace("%USERPROFILE%", $env:USERPROFILE)
$destination = $destination -replace("%APPDATA%", $env:APPDATA)
$destination = $destination -replace("%LOCALAPPDATA%", $env:LOCALAPPDATA)
Set-Location $PSScriptRoot
if ($sort -like 'folder') {
remove-item $destination -recurse -confirm:$false -force
}
if ($sort -like 'file') {
remove-item $destination -confirm:$false -force
}
write-host "Uninstall file or folder action done!"
'@
						
						if ($r["Context"] -like 'system')
						{
							$bbSystemContext = $true
							$buildingblocks_output_textbox5.AppendText('File or folder actions in the system context will now be added.')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\data"
							$BuildingBlocksISLocation = $BuildingBlocksISLocation -replace ("\\", "\")
							
							if (!(test-Path $BuildingBlocksISLocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksISLocation
							}
							$sourceIs = $($r["Source"])
							$sourceIs = $sourceIs -replace ("\\", "\")
							$sort = $r["Sort"]
							$source = $r["Source"]
							if ($sort -like 'file')
							{
								$newsourcevar = $source.Split('\')[-1]
								$newsourcevar = "Data\$newsourcevar"
							}
							if ($sort -like 'folder')
							{
								$newsourcevar = "Data\*"
								
							}
							$buildingblocks_output_textbox5.AppendText("Data is being copied to the Building Blocks location.`r`n")
							if ($sort -like 'file')
							{
								$sourcefilename = $sourceIs.Split('\')[-1]
								$dest = $BuildingBlocksISLocation + "\$sourcefilename"
								Copy-Item $sourceIs -Destination $dest
							}
							if ($sort -like 'folder')
							{
								Write-Host "Copy $sourceIs to $BuildingBlocksISLocation"
								Copy-Item "$sourceIs\*" -Destination "$BuildingBlocksISLocation" -Recurse -Container
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!source!!", $newsourcevar)
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!skip!!", $r["Skip"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!overwrite!!", $r["Overwrite"])
							$instfile = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\i.ps1"
							
							$BuildingBlocksFilesAndFolders | Out-File $instfile -force
							if ($r["Uninstall"] -like $true)
							{
								$uninstfile = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\u.ps1"
								$BuildingBlocksFilesAndFoldersUninstall | Out-File $uninstfile -force
							}
							
							$is = $is + 1
						}
						if ($r["Context"] -like 'user')
						{
							$bbUserContext = $true;
							$buildingblocks_output_textbox5.AppendText('File or folder actions in the user context will now be added.')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							$BuildingBlocksIULocation = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\data"
							if (!(test-Path $BuildingBlocksIULocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksIULocation
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$sourceIu = $($r["Source"])
							$sort = $r["Sort"]
							$source = $r["Source"]
							if ($sort -like 'file')
							{
								$newsourcevar = $source.Split('\')[-1]
								$newsourcevar = "Data\$newsourcevar"
							}
							if ($sort -like 'folder')
							{
								$newsourcevar = "Data\*"
								
							}
							$buildingblocks_output_textbox5.AppendText("Data is being copied to the Building Blocks location.`r`n")
							
							if ($sort -like 'file')
							{
								$sourcefilename = $sourceIu.Split('\')[-1]
								$dest = $BuildingBlocksIULocation + "\$sourcefilename"
								Copy-Item $sourceIu -Destination $dest
							}
							if ($sort -like 'folder')
							{
								Copy-Item "$sourceIU\*" -Destination $BuildingBlocksIULocation -Recurse
								
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!source!!", $newsourcevar)
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!skip!!", $r["Skip"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!overwrite!!", $r["Overwrite"])
							$instfile = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\i.ps1"
							$BuildingBlocksFilesAndFolders | Out-File $instfile -force
							if ($r["Uninstall"] -like $true)
							{
								$uninstfile = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\u.ps1"
								$BuildingBlocksFilesAndFoldersUninstall | Out-File $uninstfile -force
							}
							
							
							$iu = $iu + 1
						}
						
					}
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No file or folder activity detected.")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				if ($BuildingBlocksTable3 -notlike $null)
				{
					foreach ($r3 in $BuildingBlocksTable3)
					{
						
						$BuildingBlockRegistryScript = @'
Set-Location $PSScriptRoot
$regfilename = "!!regfilename!!"
if (Test-Path $regfilename) {
    $output = reg import $regfilename /reg:64 2>&1
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Registry Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Registry Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
'@
						$is = 1;
						$iu = 1;
						if ($r3["Context"] -like 'system')
						{
							$bbSystemContext = $true
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\Registry$is"
							$sourceReg = $($r3["Source"])
							if (!(test-Path $BuildingBlocksISLocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksISLocation
							}
							$buildingblocks_output_textbox5.AppendText('Registry file is now being copied to Building Block Location')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							try
							{
								Copy-Item $sourceReg -Destination "$BuildingBlocksISLocation\hklm.reg" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks done!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks failed!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$BuildingBlockRegistryScript = $BuildingBlockRegistryScript -replace ("!!regfilename!!", 'hklm.reg')
							try
							{
								$BuildingBlockRegistryScript | Out-File "$BuildingBlocksISLocation\i.ps1" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("i.ps1 created!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("failed to create i.ps1")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							
							$is = $is + 1
						}
						if ($r3["Context"] -like 'user')
						{
							$bbUserContext = $true
							$BuildingBlocksIULocation = $BuildingBlocksUserLocation + "\Registry$iu"
							$sourceReg = $($r3["Source"])
							if (!(test-Path $BuildingBlocksIULocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksIULocation
							}
							try
							{
								Copy-Item $sourceReg -Destination "$BuildingBlocksIULocation\hkcu.reg" -force
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks done!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks failed!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$BuildingBlockRegistryScript = $BuildingBlockRegistryScript -replace ("!!regfilename!!", 'hkcu.reg')
							try
							{
								$BuildingBlockRegistryScript | Out-File "$BuildingBlocksIULocation\i.ps1" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("i.ps1 created!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("failed to create i.ps1")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$iu = $iu + 1
						}
						
						
						
						
					}
					$buildingblocks_output_textbox5.AppendText("Registry done")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No Registry actions found")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				if ($BuildingBlocksTable2 -ne $Null)
				{
					$i = 1;
					foreach ($r2 in $BuildingBlocksTable2)
					{
						$BuildingBlockShortcutScript = @'	
$Context = "!!context!!"
$Name = "!!name!!"
$TargetLocation = "!!targetlocation!!"
$Arguments = "!!arguments!!"
$ICOFile = "!!icofile!!" ; $ICOFile = $ICOFile + ".ico"
$Subfolder = "!!subfolder!!"
$Desktop = "!!desktop!!"
$StartMenu = "!!startmenu!!"

Set-Location $PSScriptRoot
if ($Context -like 'user') {
    $folderPath = Join-Path $env:AppData "IntunePrepTool\ICONS"
    if (-not (Test-Path $folderPath)) {
        New-Item -ItemType Directory -Path $folderPath -Force | Out-Null
    }
    $destinationFile = Join-Path $folderPath (Split-Path $ICOFile -Leaf)
    Copy-Item -Path $ICOFile -Destination $destinationFile -Force
}
elseif ($Context -like 'system') {
    $folderPath = Join-Path $env:ProgramData "IntunePrepTool\ICONS"
    if (-not (Test-Path $folderPath)) {
        New-Item -ItemType Directory -Path $folderPath -Force | Out-Null
    }
    $destinationFile = Join-Path $folderPath (Split-Path $ICOFile -Leaf)
    Copy-Item -Path $ICOFile -Destination $destinationFile -Force
}


function fCreateShortcut
{
    <#
    .SYNOPSIS
    Creates a shortcut in the Desktop and/or Start Menu, for user or system context.

    .PARAMETER TargetFile
    The path to the executable or file the shortcut should point to.

    .PARAMETER ShortcutName
    The name of the shortcut (without .lnk extension).

    .PARAMETER Icon
    (Optional) Path to the icon file.

    .PARAMETER ShortcutArguments
    (Optional) Arguments to pass to the target.

    .PARAMETER Location
    One or more of 'Desktop' and/or 'StartMenu'.

    .PARAMETER Scope
    'User' or 'System' (default is 'User').

    .PARAMETER Subfolder
    (Optional) Subfolder within the Desktop or Start Menu path.
    #>
	
	param (
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[Parameter(Mandatory = $true)]
		[string]$ShortcutName,
		[string]$Icon = "",
		[string]$ShortcutArguments = "",
		[Parameter(Mandatory = $true)]
		[ValidateSet("Desktop", "StartMenu")]
		[string[]]$Location,
		[ValidateSet("User", "System")]
		[string]$Scope = "User",
		[string]$Subfolder = ""
	)
	
	$WorkingDir = Split-Path -Path $TargetFile -Parent
	
	foreach ($loc in $Location)
	{
		switch ($Scope)
		{
			'User' {
				$BasePath = switch ($loc)
				{
					'Desktop'   { [Environment]::GetFolderPath("Desktop") }
					'StartMenu' { [Environment]::GetFolderPath("StartMenu") }
				}
			}
			'System' {
				$BasePath = switch ($loc)
				{
					'Desktop'   { "$env:PUBLIC\Desktop" }
					'StartMenu' { "$env:ProgramData\Microsoft\Windows\Start Menu\Programs" }
				}
			}
		}
		
		$FullPath = if ($Subfolder)
		{
			Join-Path -Path $BasePath -ChildPath $Subfolder
		}
		else
		{
			$BasePath
		}
		if (-not (Test-Path $FullPath))
		{
			New-Item -Path $FullPath -ItemType Directory -Force | Out-Null
		}
		$ShortcutPath = Join-Path -Path $FullPath -ChildPath "$ShortcutName.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutPath)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.WorkingDirectory = $WorkingDir
		if ($Icon)
		{
			$Shortcut.IconLocation = $Icon
		}
		if ($ShortcutArguments)
		{
			$Shortcut.Arguments = $ShortcutArguments
		}
		$Shortcut.Save()
	}
}

if ($Desktop -like 'true') {
    fCreateShortcut -TargetFile $TargetLocation `
                    -Scope $Context `
                    -ShortcutName $Name `
                    -Location Desktop `
                    -Icon $destinationFile `
                    -ShortcutArguments $Arguments `
                    -Subfolder $Subfolder
Write-Host "Shortcut created successfully in: Desktop"
}

if ($StartMenu -like 'true') {
    fCreateShortcut -TargetFile $TargetLocation `
                    -Scope $Context `
                    -ShortcutName $Name `
                    -Location StartMenu `
                    -Icon $destinationFile `
                    -ShortcutArguments $Arguments

}
Write-Host "Shortcut created successfully in: Startmenu"
'@
						$BuildingBlockUninstallShortcutScript = @'	
$Context = "!!context!!"
$Name = "!!name!!"
$TargetLocation = "!!targetlocation!!"
$Arguments = "!!arguments!!"
$ICOFile = "!!icofile!!" ; $ICOFile = $ICOFile + ".ico"
$Subfolder = "!!subfolder!!"
$Desktop = "!!desktop!!"
$StartMenu = "!!startmenu!!"

Set-Location $PSScriptRoot

$Locations = @()
if ($Desktop)   { $Locations += 'Desktop' }
if ($StartMenu) { $Locations += 'StartMenu' }

foreach ($loc in $Locations)
{
    switch ($Context) {
        'User' {
            $BasePath = switch ($loc) {
                'Desktop'   { [Environment]::GetFolderPath('Desktop') }
                'StartMenu' { [Environment]::GetFolderPath('StartMenu') }
            }
        }
        'System' {
            $BasePath = switch ($loc) {
                'Desktop'   { Join-Path $env:Public 'Desktop' }
                'StartMenu' { Join-Path $env:ProgramData 'Microsoft\Windows\Start Menu\Programs' }
            }
        }
    }
    $FullPath = if ($Subfolder) {
        Join-Path -Path $BasePath -ChildPath $Subfolder
    }
    else {
        $BasePath
    }
    $ShortcutPath = Join-Path -Path $FullPath -ChildPath ("$Name.lnk")
    if (Test-Path $ShortcutPath) {
        Remove-Item $ShortcutPath -Force
        Write-Host "Removed shortcut: $ShortcutPath"
    }
    if ((Test-Path $FullPath) -and !(Get-ChildItem -Path $FullPath -Force)) {
        Remove-Item $FullPath -Force
        Write-Host "Removed empty folder: $FullPath"
    }
}
if ($ICOFile)
{
    if ($Context -like 'user') {
        $iconFolderPath = Join-Path $env:AppData ".IntunePrepTool\ICONS"
    }
    elseif ($Context -like 'system') {
        $iconFolderPath = Join-Path $env:ProgramData ".IntunePrepTool\ICONS"
    }
    $destinationFile = Join-Path $iconFolderPath (Split-Path $ICOFile -Leaf)
    if (Test-Path $destinationFile) {
        Remove-Item $destinationFile -Force
        Write-Host "Removed icon: $destinationFile"
    }
}

Write-Host "`nUninstall script completed."
'@
						
						
						
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!context!!", $r2["Context"])
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!context!!", $r2["Context"])
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!name!!", $($r2["Name"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!name!!", $($r2["Name"]))
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!targetlocation!!", $($r2["Target location"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!targetlocation!!", $($r2["Target location"]))
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!arguments!!", $($r2["Arguments"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!arguments!!", $($r2["Arguments"]))
						
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!subfolder!!", $($r2["Subfolder"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!subfolder!!", $($r2["Subfolder"]))
						if ($r2["Desktop"] -like 'true')
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!desktop!!", $true)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!desktop!!", $true)
						}
						else
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!desktop!!", $false)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!desktop!!", $false)
						}
						if ($r2["Startmenu"] -like 'true')
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!startmenu!!", $true)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!startmenu!!", $true)
						}
						else
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!startmenu!!", $false)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!startmenu!!", $false)
						}
						if ($r2["Context"] -like 'system')
						{
							$bbSystemContext = $true;
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\BuildingBlocksData" + "\shortcut$i"
						}
						if ($r2["Context"] -like 'user')
						{
							$bbUserContext = $true;
							$BuildingBlocksISLocation = $BuildingBlocksUserLocation + "\shortcut$i"
						}
						
						
						if (!(test-Path $BuildingBlocksISLocation))
						{
							New-Item -ItemType Directory -Path $BuildingBlocksISLocation
						}
						$icoName = -join (
							(97 .. 122) |
							Get-Random -Count 6 |
							ForEach-Object { [char]$_ }
						)
						$icoName = 'shortcut-' + $icoName
						$buildingblocks_output_textbox5.AppendText("Shortcut actions found!")
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						Copy-Item $($r2["ICO File"]) "$BuildingBlocksISLocation\$icoName.ico" -Force
						$buildingblocks_output_textbox5.AppendText('The ICO file (shortcut) is now being copied to the Building Block location.')
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!icofile!!", $icoName)
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!icofile!!", $icoName)
						$buildingblocks_output_textbox5.AppendText('Scripts (shortcuts) are now being copied to the Building Block location.')
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						$BuildingBlockShortcutScript | Out-File "$BuildingBlocksISLocation\i.ps1" -Force
						$BuildingBlockUninstallShortcutScript | Out-File "$BuildingBlocksISLocation\u.ps1" -Force
						$buildingblocks_output_textbox5.AppendText("done!")
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						
						
						
						
						$i = $i + 1
					}
					
					
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No Shortcut actions found")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				
				
				$buildingblocks_output_textbox5.AppendText("Building Blocks created: $buildingBlockFolder")
				$buildingblocks_output_textbox5.AppendText("  `r`n")
				#$buildingBlocks_panel85.Enabled = $true;
				if ($bbUserContext -like $true)
				{
					$userContext_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!" ; $version = $version + "user"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextInstall_$appname$version.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 

	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\i.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
		
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1 }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
					$userContext_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!" ; $version = $version + "user"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextUninstall_$appname$version.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
	
	
}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1 }
else { remove-item $regkeyApp; exit 0 }
'@
					$buildingblocks_output_textbox5.AppendText("`Generating install and uninstall powershell scripts for the User Context Package...`r`n")
					$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
					$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
					$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
					$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
					$appname = $buildingblocks_Name_textbox4.text
					$appversion = $buildingblocks_version_textbox3.Text
					$RegisterDetectionroot = "Intune_" + $config_customername
					$userContext_installFile = $userContext_installFile.Replace('!!AppName!!', "$appname")
					$userContext_installFile = $userContext_installFile.Replace('!!logdir!!', $config_logfoldertarget)
					$userContext_installFile = $userContext_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
					$userContext_installFile = $userContext_installFile.Replace('!!version!!', $appversion)
					$userContext_installFile | Out-File "$config_buildingblockspath\$appname\User\install.ps1" -Force
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!AppName!!', "$appname")
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!version!!', $appversion)
					$userContext_uninstallFile | Out-File "$config_buildingblockspath\$appname\User\uninstall.ps1" -Force
					$buildingblocks_output_textbox5.AppendText("`install.ps1 and uninstall.ps1 created! `r`n")
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show(
						'The IntunePrepTool will not respond until packaging is complete. Large packages may take several minutes. Please wait.',
						'Creating User Context Package'
					) # Casting the method to [void] suppresses the output. 
					if (!(Test-Path "$config_buildingblockspath\$appname\output-UserContext\"))
					{
						mkdir "$config_buildingblockspath\$appname\output-UserContext\" -Force
					}
					
					
					& .\IntuneWinAppUtil.exe -c "$config_buildingblockspath\$appname\User\" -s "$config_buildingblockspath\$appname\User\install.ps1" -o "$config_buildingblockspath\$appname\output-UserContext\" -q
					Rename-Item -Path "$config_buildingblockspath\$appname\output-UserContext\install.intunewin" -NewName "$config_buildingblockspath\$appname\output-UserContext\$appname.intunewin"
					$buildingblocks_output_textbox5.AppendText("`nIntunewin file created: `r`n")
					$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-UserContext\$appname.intunewin")
					$buildingblocks_output_textbox5.AppendText("`r`n")
					
					$context = 'user'
					$icmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File install.ps1"
					$ucmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File uninstall.ps1"
					$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
					$regkeyApp = "$regkeyRoot$appname"
					$usercontextVersion = $appversion + "user"
					$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
							IntuneWinFile = "$appname.intunewin"
							DisplayName   = $appname
							Publisher	  = $config_customername
							AppVersion    = $usercontextVersion;
							reglocation   = $regkeyApp
							regValue	  = 'Version'
							installCMD    = $icmd
							uninstallCMD  = $ucmd
							context	      = $context
						})
					$IntuneWinPackageConfig | Export-Csv "$config_buildingblockspath\$appname\output-UserContext\config.csv" -NoTypeInformation
					$buildingblocks_output_textbox5.AppendText("`Config.csv created: `r`n")
					$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-UserContext\config.csv")
					$buildingblocks_output_textbox5.AppendText("`r`n")
					if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
					{
						if ($bbSystemContext -like $false)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $false
									usercontext				     = $true
									systemcontextconfig		     = $null;
									systembuildingblockslocation = $null;
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv";
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
							
						}
						
					}
					else
					{
						if ($bbSystemContext -like $false)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $false
									systemcontext			     = $false
									usercontext				     = $true
									systemcontextconfig		     = $null;
									systembuildingblockslocation = $null;
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv";
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Building Blocks - Standalone Package Info')
							
						}
					}
					
				}
				if ($bbSystemContext -like $true)
				{
					$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
					$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
					$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
					$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
					$appname = $buildingblocks_Name_textbox4.text
					$appversion = $buildingblocks_version_textbox3.Text
					
					if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
					{
						if ($bbUserContext -like $true)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $true
									usercontext				     = $true
									systemcontextconfig		     = $null
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv"
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
						}
						else
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $true
									usercontext				     = $false
									systemcontextconfig		     = $null;
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig		     = $null;
									userbuildingblockslocation   = $null;
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
						}
					}
					else
					{
						
						
						$systemContext_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksSystemContextInstall_$appname$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 

	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\i.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
		
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1 }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
						$systemContext_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextUninstall_$appname$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
	
	
}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1 }
else { remove-item $regkeyApp; exit 0 }
'@
						$buildingblocks_output_textbox5.AppendText("`Generating install and uninstall powershell scripts for the System Context Package...`r`n")
						$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
						$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
						$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
						$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
						$appname = $buildingblocks_Name_textbox4.text
						$appversion = $buildingblocks_version_textbox3.Text
						$RegisterDetectionroot = "Intune_" + $config_customername
						$systemContext_installFile = $systemContext_installFile.Replace('!!AppName!!', "$appname")
						$systemContext_installFile = $systemContext_installFile.Replace('!!logdir!!', $config_logfoldertarget)
						$systemContext_installFile = $systemContext_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
						$systemContext_installFile = $systemContext_installFile.Replace('!!version!!', $appversion)
						$systemContext_installFile | Out-File "$config_buildingblockspath\$appname\System\install.ps1" -Force
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!AppName!!', "$appname")
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!version!!', $appversion)
						$systemContext_uninstallFile | Out-File "$config_buildingblockspath\$appname\System\uninstall.ps1" -Force
						$buildingblocks_output_textbox5.AppendText("`install.ps1 and uninstall.ps1 created! `r`n")
						#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
						[void][System.Windows.Forms.MessageBox]::Show(
							'The IntunePrepTool will not respond until packaging is complete. Large packages may take several minutes. Please wait.',
							'Creating System Context Package'
						) # Casting the method to [void] suppresses the output. 
						if (!(Test-Path "$config_buildingblockspath\$appname\output-SystemContext\"))
						{
							mkdir "$config_buildingblockspath\$appname\output-SystemContext\" -Force
						}
						
						
						& .\IntuneWinAppUtil.exe -c "$config_buildingblockspath\$appname\System\" -s "$config_buildingblockspath\$appname\System\install.ps1" -o "$config_buildingblockspath\$appname\output-SystemContext\" -q
						Rename-Item -Path "$config_buildingblockspath\$appname\output-SystemContext\install.intunewin" -NewName "$config_buildingblockspath\$appname\output-SystemContext\$appname.intunewin"
						$buildingblocks_output_textbox5.AppendText("`nIntunewin file created: `r`n")
						$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-SystemContext\$appname.intunewin")
						$buildingblocks_output_textbox5.AppendText("`r`n")
						
						$context = 'system'
						$icmd = "powershell -executionpolicy bypass -file install.ps1"
						$ucmd = "powershell -executionpolicy bypass -file uninstall.ps1"
						$regkeyRoot = "HKEY_LOCAL_MACHINE\Software\$RegisterDetectionroot\"
						$regkeyApp = "$regkeyRoot$appname"
						$IntuneWinPackageConfig = $null;
						$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
								IntuneWinFile = "$appname.intunewin"
								DisplayName   = $appname
								Publisher	  = $config_customername
								AppVersion    = $appversion;
								reglocation   = $regkeyApp
								regValue	  = 'Version'
								installCMD    = $icmd
								uninstallCMD  = $ucmd
								context	      = $context
							})
						$IntuneWinPackageConfig | Export-Csv "$config_buildingblockspath\$appname\output-SystemContext\config.csv" -NoTypeInformation
						$buildingblocks_output_textbox5.AppendText("`Config.csv created: `r`n")
						$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-SystemContext\config.csv")
						$buildingblocks_output_textbox5.AppendText("`r`n")
						
						if ($bbUserContext -like $true)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress   = $false
									systemcontext	    = $true
									usercontext		    = $true
									systemcontextconfig = "$config_buildingblockspath\$appname\output-SystemContext\config.csv"
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig   = "$config_buildingblockspath\$appname\output-UserContext\config.csv"
									userbuildingblockslocation = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Building Blocks - Standalone Package Info')
						}
						else
						{
							
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress   = $false
									systemcontext	    = $true
									usercontext		    = $false
									systemcontextconfig = "$config_buildingblockspath\$appname\output-SystemContext\config.csv"
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig   = $null
									userbuildingblockslocation = $null;
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - Standalone Package Info')
							
						}
					}
				}
				
			}
		}
	}
	
	
}

$buildingblocks_Name_textbox4_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		
	}
}

$config_buildingBlocksBrowse_button1_Click={
	#TODO: Place custom script here
	if ($config_buildingBlcoks_folderbrowsermoderndialog3.ShowDialog() -eq 'OK')
	{
		$config_buildingblocks_textbox3.Text = $config_buildingBlcoks_folderbrowsermoderndialog3.SelectedPath
	}
}

$config_install_orca_buttonInstallOrcaPowershel_Click={
	#TODO: Place custom script here
$installOrca = @'



[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
$WinSDKSetup = "C:\windows\Temp\winsdksetup.exe"
try {
Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/?linkid=2313119" -OutFile $WinSDKSetup -ErrorAction Stop
Write-Host "Downloaded winsdksetup.exe to $WinSDKSetup"
}
catch {
Write-Error "Failed downloading winsdksetup.exe"
}

$exeParameters = '/layout "C:\Program Files\IntunePrepTool" /q /features OptionId.MSIInstallTools /quiet /norestart'

try
{
	Start-Process -FilePath $WinSDKSetup -ArgumentList $exeParameters -Wait -NoNewWindow -ErrorAction Stop
	write-host "Installation completed of $WinSDKSetup" -ForegroundColor Green
	
	
}
catch
{
	write-host "Error executing "C:\windows\Temp\winsdksetup.exe"" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	
	
}

try
{
	$startPMSI = Start-Process msiexec.exe `
    -ArgumentList '/i', '"C:\Program Files\IntunePrepTool\Installers\Orca-x86_en-us.msi"', '/qn', '/l*v', '"C:\Windows\Temp\OrcaMSI.txt"' `
    -Wait `
    -NoNewWindow `
    -ErrorAction Stop

	write-host $startPMSI
	$msilog = get-content 'c:\windows\temp\OrcaMSI.txt'
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Install done!" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green

	}
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content 'c:\windows\temp\OrcaMSI.txt'
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
}
write-host "Cleaning temp install files now" -ForegroundColor Green
Remove-Item $WinSDKSetup -Confirm:$false
Remove-Item -Path "C:\Program Files\IntunePrepTool\Installers" -Recurse -Force -Confirm:$false
Remove-Item  "C:\Windows\Temp\OrcaMSI.txt" -Confirm:$false

'@

	
	if (!(Test-Path "c:\program files\IntunePrepTool\installOrca.ps1" -PathType Leaf))
	{
		$installOrca  | Out-File "c:\program files\IntunePrepTool\installOrca.ps1"
	}
	else
	{
		Remove-Item -Path "c:\program files\IntunePrepTool\installOrca.ps1" -Confirm:$false -Force
		$installOrca | Out-File "c:\program files\IntunePrepTool\installOrca.ps1"
	}
	
	powershell_ise -file "c:\program files\IntunePrepTool\installOrca.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$msi_open_Orca_button1_Click={
	#TODO: Place custom script here
	if (Test-Path "C:\Program Files (x86)\Orca\Orca.exe" -Type Leaf)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		$MSINewname = $msi_openfiledialog1.FileName
		$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
		$MSINewname = $MSINewname.Replace(" ", "")
		$MSIbestand = "$config_packagefolder\$msipnaam\$msiversie\source\$MSINewname"
		Start-Process "C:\Program Files (x86)\Orca\Orca.exe" -ArgumentList $MSIbestand
	}
	else
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Use the Install Orca (PowerShell_ISE) button in the Start/Config menu.", 'Please install Orca first') # Casting the method to [void] suppresses the output.
		
	}
	
}

$msi_gotobuildingblocks_button2TestInstallPowershe_Click={
	#TODO: Place custom script here
	
}

$msi_buttonOptionalGoToBuilding_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'msi'| Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'msi' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $msi_packagenaam_textbox1.text
	$buildingblocks_version_textbox3.text = $msi_versie_textbox1.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
	
	
}

$msi_addBuildingBlocksSystemContextbutton5CreateIntunewinFile_Click= {
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $msi_packagenaam_textbox1.text
			$PacVersion = $msi_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$MSI_buildigblocks_Package_InProgresstextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			$MSI_buildigblocks_Package_InProgresstextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
		}
	}
}

$bb_gobackToPackageInProgress_button1_Click={
	#TODO: Place custom script here
	if (!(Test-Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Type Leaf))
	{
		
	}
	else
	{
		$BBWheretoGoBack = get-content 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt'
		if ($BBWheretoGoBack -like 'msi')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $true
			$package_msi_tabcontrol2.Visible = $true
			$package_msi_tabcontrol2.Dock = 'Fill'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'exe')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $true
			$package_exe_tabcontrol2.Visible = $true
			$package_exe_tabcontrol2.Dock = 'Fill'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'msix')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'Fill'
			$MSIX_tabcontrol1.Enabled = $true
			$MSIX_tabcontrol1.Visible = $true
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'choco')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $true
			$tools_chocolatey_tabcontrol1.Visible = $true
			$tools_chocolatey_tabcontrol1.Dock = 'Fill'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'winget')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $true
			$package_winget_tabcontrol2.Visible = $true
			$package_winget_tabcontrol2.Dock = 'Fill'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
	}
	
}

$bb_standalone_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($bb_standalone_radiobutton1.Enabled -eq $true)
	{
		#$bb_usePackageInProgress_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $true
		$buildingblocks_version_textbox3.Enabled = $true
	}
	if ($bb_standalone_radiobutton1.Enabled -eq $false)
	{
		#$bb_usePackageInProgress_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $false
		$buildingblocks_version_textbox3.Enabled = $false
		
	}
	
}

$bb_usePackageInProgress_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($bb_usePackageInProgress_radiobutton1.Enabled -eq $true)
	{
		#$bb_standalone_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $false
		$buildingblocks_version_textbox3.Enabled = $false
		
		
	}
	if ($bb_usePackageInProgress_radiobutton1.Enabled -eq $false)
	{
		#$bb_standalone_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $true
		$buildingblocks_version_textbox3.Enabled = $true
	}
	if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
	{
		if (($buildingblocks_Name_textbox4.Text -like $Null) -or ($buildingblocks_version_textbox3.Text -like $Null))
		{
			[void][System.Windows.Forms.MessageBox]::Show(
				"Please go to your MSI, MSIX, EXE, Chocolatey or Winget package. After testing install, then use the '(Optional) Go to Building Blocks' button",
				"Button '(Optional) Go to Building Blocks' not used!"
			)
		}
	}
	
	
}

$buildingblocks_add_script_buttonAddShotcut_Click={
	#TODO: Place custom script here
	
}

$exe_open_withqquestion_button1_Click={
	#TODO: Place custom script here
	[void][System.Windows.Forms.MessageBox]::Show(
		"If the EXE file supports this, a popup will open with all the install parameters. If the EXE file does not support it, it might launch the setup. In that case, please close it before continuing.",
		'Testing opening EXE file with /?'
	)
	[string]$exe_org_path = $exe_openfiledialog1.FileNames
	Unblock-File -Path $exe_org_path -Confirm:$false
	Start-Process $exe_org_path -ArgumentList '/?' -WindowStyle Normal
	
}

$exe_test_done_button1CreateInstallScript_Click={
	#TODO: Place custom script here
	$exe_preBackupPath64 = Get-Variable -Name exe_preBackupPath64 -ValueOnly -Scope Script
	$exe_preBackupPath32 = Get-Variable -Name exe_preBackupPath32 -ValueOnly -Scope Script
	$backupFolder = "$env:LOCALAPPDATA\temp"
	$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$PostBackupPath64 = Join-Path $backupFolder "PostChanges64_$timeStamp.reg"
	$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$PostBackupPath32 = Join-Path $backupFolder "PostChanges32_$timeStamp.reg"
	$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	reg export "$regExportPath" "$PostBackupPath32" /y | Out-Null
	$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	reg export "$regExportPath" "$PostBackupPath64" /y | Out-Null
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$regDiffFile64 = Join-Path $backupFolder "Difffile64_$timeStamp.reg"
	$regDiffFile32 = Join-Path $backupFolder "Difffile32_$timeStamp.reg"
	function Compare-RegFiles
	{
		param (
			[string]$OldRegPath,
			[string]$NewRegPath,
			[string]$DiffOutPath
		)
		
		$oldLines = [System.IO.File]::ReadAllLines($OldRegPath)
		$newLines = [System.IO.File]::ReadAllLines($NewRegPath)
		$oldHashSet = [System.Collections.Generic.HashSet[string]]::new($oldLines)
		$differences = New-Object System.Collections.Specialized.OrderedDictionary
		$currentKey = $null
		foreach ($line in $newLines)
		{
			if ($line -match '^\[\S+\]$')
			{
				$currentKey = $line
				continue
			}
			if ($line -match '^\S+=' -and $currentKey)
			{
				if (-not $oldHashSet.Contains($line))
				{
					if (-not $differences.Contains($currentKey))
					{
						$differences[$currentKey] = [System.Collections.Generic.List[string]]::new()
					}
					$differences[$currentKey].Add($line)
				}
			}
		}
		if ($differences.Count -gt 0)
		{
			Set-Content -Path $DiffOutPath -Value "Windows Registry Editor Version 5.00`r`n"
			foreach ($key in $differences.Keys)
			{
				Add-Content -Path $DiffOutPath -Value "`r`n$key"
				foreach ($val in $differences[$key])
				{
					Add-Content -Path $DiffOutPath -Value $val
				}
			}
			$DiffOutPath | out-file "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt" -force
		}
		else
		{
			if (Test-Path $DiffOutPath)
			{
				Remove-Item $DiffOutPath -ErrorAction SilentlyContinue
			}
		}
	}
	
	Compare-RegFiles -OldRegPath $exe_preBackupPath64 `
					 -NewRegPath $PostBackupPath64 `
					 -DiffOutPath $regDiffFile64
	
	Compare-RegFiles -OldRegPath $exe_preBackupPath32 `
					 -NewRegPath $PostBackupPath32 `
					 -DiffOutPath $regDiffFile32
	Remove-Item $PostBackupPath64 -Confirm:$false
	Remove-Item $exe_preBackupPath64 -Confirm:$false
	Remove-Item $PostBackupPath32 -Confirm:$false
	Remove-Item $exe_preBackupPath32 -Confirm:$false
	
	foreach ($file in @($regDiffFile64, $regDiffFile32))
	{
		if (Test-Path $file -PathType Leaf)
		{
			$regString = Get-Content $file
			$regInfo = @{ }
			
			foreach ($line in $regString)
			{
				if ($line -match '^\s*\"(?<key>.+?)\"=\"(?<value>.*)\"')
				{
					$regInfo[$matches['key']] = $matches['value']
				}
				elseif ($line -match '^\s*\"(?<key>.+?)\"=dword:(?<value>.+)')
				{
					$regInfo[$matches['key']] = [Convert]::ToInt32($matches['value'], 16)
				}
				elseif ($line -match '^\s*\"(?<key>.+?)\"=(?<value>.+)')
				{
					$regInfo[$matches['key']] = $matches['value'].Trim().Trim('"')
				}
			}
			
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("DisplayName: " + $regInfo["DisplayName"] + "`r`n")
			$exe_output_textbox1.AppendText("DisplayVersion: " + $regInfo["DisplayVersion"] + "`r`n")
			$exe_output_textbox1.AppendText("InstallDate: " + $regInfo["InstallDate"] + "`r`n")
			$exe_output_textbox1.AppendText("UninstallString: " + $regInfo["UninstallString"] + "`r`n")
			$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
			$wattezoeken = $regInfo["DisplayName"]
			$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
			if ($InstallsUninstallString -notlike $null)
			{
				
				foreach ($ius in $InstallsUninstallString)
				{
					$exe_output_textbox1.AppendText("Another possible uninstall string: " + $ius.UninstallString + "`r`n")
					$uninststr = $ius.UninstallString
					if ($uninststr -like '*.exe*') { $exe_uninstall_exe_path_textbox2.Text = $uninststr; $exe_radiobuttonUninstallEXEPath.Checked = $true; $exe_parsUnInstall_textbox1.Text = $exe_parsInstall_textbox1.Text }
					if ($uninststr -like '*{*')
					{
						$newuni = $uninststr.Split("{")[1]
						$newuni = $newuni.Split("}")[0]
						$exe_radiobutton3.Checked = $true
						$MSIXECUninstall = $exe_msiexecuninstall.Text
						$MSIXECUninstall = $MSIXECUninstall -replace ("PlaceProductIDhere", $newuni)
						$exe_msiexecuninstall.Text = $MSIXECUninstall;
					}
				}
			}
			$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
			$wattezoeken = $regInfo["DisplayName"]
			$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
			if ($InstallsUninstallString -notlike $null)
			{
				
				foreach ($ius in $InstallsUninstallString)
				{
					$exe_output_textbox1.AppendText("Another possible uninstall string: " + $ius.UninstallString + "`r`n")
					$uninststr = $ius.UninstallString
					if ($uninststr -like '*.exe*') { $exe_uninstall_exe_path_textbox2.Text = $uninststr; $exe_radiobuttonUninstallEXEPath.Checked = $true; $exe_parsUnInstall_textbox1.Text = $exe_parsInstall_textbox1.Text  }
					if ($uninststr -like '*{*')
					{
						$newuni = $uninststr.Split("{")[1]
						$newuni = $newuni.Split("}")[0]
						$exe_radiobutton3.Checked = $true
						$MSIXECUninstall = $exe_msiexecuninstall.Text
						$MSIXECUninstall = $MSIXECUninstall -replace("PlaceProductIDhere", $newuni)
						$exe_msiexecuninstall.Text = $MSIXECUninstall;
						 }
				}
			}
			
		}
	}
	
	
}

$tablelayoutpanel3_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_buttonOpenReleaseNotesOnIn_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/updates/intunepreptool-1-7-0-0/'
}


$exe_gotobuildingblocksButton_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'exe' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'exe' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $exe_packagenaam_textbox1.text
	$buildingblocks_version_textbox3.text = $exe_versie_textbox1.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$tools_choco_gotoBuildingBlocks_Button_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'choco' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'choco' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $tools_choco_displayname_textbox3.text
	$buildingblocks_version_textbox3.text = $tools_choco_appversion_textbox3.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$msix_GotoBuildingBlocks_Button_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'msix' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'msix' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $msix_packagename_textbox3.text
	$buildingblocks_version_textbox3.text = $msix_packageVersion_textbox3.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$winget_gotobuildingBlocks_buttonTestInstallPowershel_Click={
	#TODO: Place custom script here
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'winget' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'winget' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $winget_displayname_textbox1.text
	$buildingblocks_version_textbox3.text = $versie_textbox2.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$exe_addBuildingBlocksCSVButton_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $exe_packagenaam_textbox1.text
			$PacVersion = $exe_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$exe_buildingblockscsv_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
			$exe_buildingblockscsv_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$msix_addBuildingBlokcsCSV_buttonOptionalAddBuildingB_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $msix_packageVersion_textbox3.text
			$PacVersion = $msi_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$msix_buildingblocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
			$msix_buildingblocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$tools_choco_addBuildingBlocksCSVButton_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $tools_choco_displayname_textbox3.text
			$PacVersion = $tools_choco_appversion_textbox3.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$choco_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
			$choco_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$winget_addBuildingBlocksCSVbuttonOptionalAddBuildingB_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $winget_displayname_textbox1.text
			$PacVersion = $versie_textbox2.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$winget_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
			$winget_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$upload_LoadBuildingBlocksg_button1_Click={
	#TODO: Place custom script here
	$upload2_IntuneWinFile_textbox1.Text = $null;
	$upload2_DisplayName_textbox2.Text = $null;
	$upload2_Publisher_textbox1.Text = $null;
	$upload2_AppVersion_textbox1.Text = $null;
	$upload2_reglocation_textbox2.Text = $null;
	$upload2_regValue_textbox1.Text = $null;
	$upload2_installCMD_textbox1.Text = $null;
	$upload2_uninstallCMD_textbox1.Text = $null;
	$upload2_context_textbox1.Text = $null;
	
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		$upload_configLoaded_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		$upload_checkboxSetupAssignmentLikeP.Enabled = $false
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		$systemcsvLOC = $BuildingBlocksCSVContent.systemcontextconfig
		$usercsvLOC = $BuildingBlocksCSVContent.usercontextconfig
		if (($BuildingBlocksCSVContent.usercontext -like $true) -and ($BuildingBlocksCSVContent.systemcontext -like $true))
		{
			$upload_panel2.Enabled = $true
			$upload_panel2.Visible = $true
			$ConfigCSVImport = $null
			$ConfigCSVImport = Import-Csv $systemcsvLOC
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $systemcsvLOC.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload_context_textbox1.Text = $context
			$ConfigCSVImport = $null
			$ConfigCSVImport = Import-Csv $usercsvLOC
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $usercsvLOC.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload2_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload2_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload2_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload2_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload2_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload2_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload2_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload2_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload2_context_textbox1.Text = $context
	
			if (!(test-path "$filepath\Logo.png" -PathType Leaf))
			{
				[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
				$upload_logo_button2.Enabled = $true
				$upload_logo_button2.Visible = $true
				
			}
			
		}
		else
		{
			
			if ($systemcsvLOC -like $null)
			{
				$ConfigCSVImport = $null
				$ConfigCSVImport = Import-Csv $usercsvLOC
				$itwnf = $ConfigCSVImport.IntuneWinFile
				$filepath = $usercsvLOC.TrimEnd("config.csv")
				$itwnffilepath = $filepath + $itwnf
				$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
				
				$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
				$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
				$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
				$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
				$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
				$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
				$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
				if ($ConfigCSVImport.context)
				{
					$context = $ConfigCSVImport.context
				}
				else
				{
					$context = 'system'
				}
				$upload_context_textbox1.Text = $context
				
				if (!(test-path "$filepath\Logo.png" -PathType Leaf))
				{
					[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
					$upload_logo_button2.Enabled = $true
					$upload_logo_button2.Visible = $true
					
				}
			}
			else
			{
				$ConfigCSVImport = $null
				$ConfigCSVImport = Import-Csv $systemcsvLOC
				$itwnf = $ConfigCSVImport.IntuneWinFile
				$filepath = $systemcsvLOC.TrimEnd("config.csv")
				$itwnffilepath = $filepath + $itwnf
				$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
				
				$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
				$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
				$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
				$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
				$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
				$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
				$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
				if ($ConfigCSVImport.context)
				{
					$context = $ConfigCSVImport.context
				}
				else
				{
					$context = 'system'
				}
				$upload_context_textbox1.Text = $context
				
				if (!(test-path "$filepath\Logo.png" -PathType Leaf))
				{
					[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
					$upload_logo_button2.Enabled = $true
					$upload_logo_button2.Visible = $true
					
				}
			}
		
		}
		
		
	}
	
	
	
}

$config_howtoBasicSetup_buttonOpenHowToBasicSetupO_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/basic-setup/'
}

$BB_OpenHowTo_button_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/building-blocks/'
}

$tools_choco_label5_Click={
	#TODO: Place custom script here
	
}

$buttonRefreshTenants_Click={
	#TODO: Place custom script here
	refreshTenants
	refreshTenantsUpload
}


$msi_addDescription_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $msi_packagenaam_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $msi_packagenaam_textbox1.text  -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $msi_versie_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $msi_versie_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$exe_buttonAddCustomPackageDesc_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $exe_packagenaam_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $exe_packagenaam_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $exe_versie_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $exe_versie_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$winget_buttonAddCustomDescription_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $winget_displayname_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $winget_displayname_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $versie_textbox2.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $versie_textbox2.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$msix_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $msix_packagename_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $msix_packagename_textbox3.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $msix_packageVersion_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $msix_packageVersion_textbox3.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$powershell_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $powershell_packagename_textbox.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $powershell_packagename_textbox.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $powershell_packageversion_textbox.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $powershell_packageversion_textbox.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$scheduledtask_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $powershell_package_name_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $powershell_package_name_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $powershell_package_version_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $powershell_package_version_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$tools_choco_buttonOpenPackageDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $tools_choco_displayname_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $tools_choco_displayname_textbox3.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $tools_choco_appversion_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $tools_choco_appversion_textbox3.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$config_tenant_customprivacy_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_tenant_checkboxYes_CheckedChanged={
	#TODO: Place custom script here
	if ($config_tenant_checkboxYes.Checked -eq $true)
	{
		$config_tenant_customprivacy_textbox3.Enabled = $true
	}
	if ($config_tenant_checkboxYes.Checked -eq $false) {
		$config_tenant_customprivacy_textbox3.Text = $null
		$config_tenant_customprivacy_textbox3.Enabled = $false
	}
}

$config_tenant_info_secret_label_Click={
	#TODO: Place custom script here
	
}

$msi_howtoPackageMSI_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/package-msi-example-foxit-reader-language-mst/'
}

$msi_verbose_radiobutton1_CheckedChanged={
	$msiTempinstallPar = $msi_install_par_textbox3.Text
	$msiTempUninstallPar = $msi_uninstall_par_textbox1.text
	if ($msi_radiobuttonStatusMessages.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*v', '/l*i')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*v', '/l*i')
	}
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*i', '/l*v')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*i', '/l*v')
		
	}
	$msi_install_par_textbox3.Text = $msiTempinstallPar
	$msi_uninstall_par_textbox1.text = $msiTempUninstallPar
}

$msi_radiobuttonStatusMessages_CheckedChanged={
	$msiTempinstallPar = $msi_install_par_textbox3.Text
	$msiTempUninstallPar = $msi_uninstall_par_textbox1.text
	if ($msi_radiobuttonStatusMessages.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*v', '/l*i')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*v', '/l*i')
	}
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*i', '/l*v')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*i', '/l*v')
		
	}
	$msi_install_par_textbox3.Text = $msiTempinstallPar
	$msi_uninstall_par_textbox1.text = $msiTempUninstallPar
}

$UploadLogo_openfiledialog1_FileOk=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$config_install_libwebp_Click={
	#TODO: Place custom script here
	$installlibwebp = @'

$Url = 'https://storage.googleapis.com/downloads.webmproject.org/releases/webp/libwebp-1.6.0-windows-x64.zip'
[string]$DownloadDir = "c:\windows\temp"
[switch]$Extract = $true
[switch]$Overwrite = $true

# Ensure TLS 1.2
try { [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 } catch {}

# Create target dir
if (!(Test-Path -LiteralPath $DownloadDir)) {
  New-Item -ItemType Directory -Path $DownloadDir -Force | Out-Null
}

$uri = [Uri]$Url
$fileName = [IO.Path]::GetFileName($uri.AbsolutePath)
$outFile = Join-Path $DownloadDir $fileName

# FIX: wrap Test-Path before using -and
if ((Test-Path -LiteralPath $outFile -PathType Leaf) -and (-not $Overwrite)) {
  Write-Host "Already exists: $outFile  (use -Overwrite to redownload)"
} else {
  try {
    $iwrParams = @{ Uri = $Url; OutFile = $outFile; TimeoutSec = 600; ErrorAction = 'Stop' }
    if ($PSVersionTable.PSVersion.Major -lt 6) { $iwrParams['UseBasicParsing'] = $true }
    Invoke-WebRequest @iwrParams
    Write-Host "Downloaded to: $outFile"
  } catch {
    Write-Warning "Invoke-WebRequest failed: $($_.Exception.Message)"
    Write-Host "Falling back to BITS transfer…"
    Start-BitsTransfer -Source $Url -Destination $outFile -DisplayName 'libwebp zip' -ErrorAction Stop
    Write-Host "Downloaded to: $outFile (via BITS)"
  }

  # Sanity check
  $fi = Get-Item -LiteralPath $outFile -ErrorAction SilentlyContinue
  if (-not $fi -or $fi.Length -lt 1024) {
    throw "Download looks incorrect or incomplete: $outFile"
  }
}

if ($Extract) {
  $extractDir = Join-Path $DownloadDir ([IO.Path]::GetFileNameWithoutExtension($fileName))
  if (Test-Path -LiteralPath $extractDir) {
    if ($Overwrite) { Remove-Item -LiteralPath $extractDir -Recurse -Force }
    else { throw "Extract folder already exists: $extractDir (use -Overwrite)" }
  }
  # Make extraction fail fast if the ZIP isn't there/valid
  Expand-Archive -LiteralPath $outFile -DestinationPath $extractDir -Force -ErrorAction Stop
  Write-Host "Extracted to: $extractDir"
  copy-item "C:\Windows\Temp\libwebp-1.6.0-windows-x64\libwebp-1.6.0-windows-x64\bin\dwebp.exe" 'C:\Program Files\IntunePrepTool\dwebp.exe' -Force
  Write-Host "dwebp.exe copied to C:\Program Files\IntunePrepTool"
  remove-item "C:\Windows\Temp\libwebp-1.6.0-windows-x64.zip" -Confirm:$false
  remove-item 'C:\Windows\Temp\libwebp-1.6.0-windows-x64' -Recurse -Confirm:$false
  Write-Host "Removed Temp files; All Done now!"
}


'@
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\installlibwebp.ps1" -PathType Leaf))
	{
		$installlibwebp | Out-File "c:\program files\IntunePrepTool\installlibwebp.ps1"
	}
	else
	{
		Remove-Item -Path "c:\program files\IntunePrepTool\installlibwebp.ps1" -Confirm:$false -Force
		$installlibwebp | Out-File "c:\program files\IntunePrepTool\installlibwebp.ps1"
	}
	
	powershell_ise -file "c:\program files\IntunePrepTool\installlibwebp.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$menustrip1_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$MSIX_tabpage4_Click={
	#TODO: Place custom script here
	
}
]]></Code>
  <TV>0</TV>
  <Bookmarks />
  <BreakPoints>
    <Line Disabled="False">1689</Line>
    <Line Disabled="False">13262</Line>
  </BreakPoints>
  <TracePoints />
  <Mode>1</Mode>
  <Assemblies />
</File>