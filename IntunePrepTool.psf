<File version="3.2">
  <FileID>373d466f-0843-40eb-9006-241e20fcf1fd</FileID>
  <LastExport>133227411031353429</LastExport>
  <Preview>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
LhWXRHHx5Th3viju3LsfxcUlUV33NCorKuNRaXmUllVEWVl51NTWR9mj0qh+Uh9VldVx7uyZKLlw
ygCQpONa9j/n7Je1SA8b+/LfBpj9IqDs/fv29rYodHZGT3d3fPbZ5/Hhhx/Ef/z2t3HqzNn49A//
GydPnoxPP/lDfPrJJ3H2zJn45NOT8bSlLa5ePBMf/+HjKHtwL5ZWNwwASZKOc+XNA1EYnIyl5ZVY
Xd+M9c2tWN988ep240WsrK3H2sZmLC6vxPLqeiytrOW3y6trsbi0EstrG7G6vhHLK2v5fSur6zE6
9Tz/fMGbz/VtBoAkSceg6m9663jrqw+LvrP83NePvf1Yr2cASJJ0TKp89jP2Zx7/9QwASZISzACQ
JCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQp
wQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEM
AEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJ
khLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZIS
zACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswA
kCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAk
KcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnB
DABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwA
SZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmS
EswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLM
AJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQ
JCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQp
wQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEM
AEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJ
khLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZIS
zACQJCnBDABJkhLMAJAkKcEMAEmSEswAkCQpwQwASZISzACQJCnBftQAWDmIKK1pigvX70VV22j+
IJIk6f3pQUNv9AxP/7ABsLAb0VQYiub2rhgYf54vCEmS9P6UXfynny/F6ML20QbAhaIrRfPbEcPz
OzG5vJcvB0mS9P6VX/znd2Lk+da7B8Dnp87dXN6JGJrdyBeDJEl6fxuZ34rx+c13DwAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAA4C/6PykPzH6cExoZAAAAAElFTkSuQmCC</Preview>
  <Form>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
R7lmxzcbte7A7hYqXv9R/d//B4PHRPCcgggA</Form>
  <Code><![CDATA[


class config_customerinfo {
	[string]$customername
	[string]$customPrivacyURL
	[string]$logfoldertarget
	[string]$packagefolder
	[string]$tenanturl
	[string]$downloadpath
	[string]$buildingblockspath
}
function refreshTenants
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$config_treeview3.BeginUpdate()
		$config_treeview3.Refresh()
		$config_treeview3.Nodes.Clear()
		$Root = $config_treeview3.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			
			$node = $Root.Nodes.Add($tenantCSV.customername)
			#$upload_upload_listbox1.Items.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			$node.ContextMenuStrip = $config_tenants_contextmenustrip1
			
		}
		$Root.Expand()
		$config_treeview3.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function refreshTenantsUpload
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$upload_treeview2.BeginUpdate()
		$upload_treeview2.Refresh()
		$upload_treeview2.Nodes.Clear()
		$upload_treeview2.CheckBoxes = $true
		$Root = $upload_treeview2.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			#$upload_treeview2.Nodes.Add($tenantCSV.customername)
			$node = $Root.Nodes.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			
			
		}
		$Root.Expand()
		$upload_treeview2.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function PowershellISEOnTop
{
	Add-Type @"
using System;
using System.Runtime.InteropServices;
public class User32 {
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
    
    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
    
    public static IntPtr HWND_TOPMOST = new IntPtr(-1);
    public static IntPtr HWND_NOTOPMOST = new IntPtr(-2);
    public const UInt32 SWP_NOSIZE = 0x0001;
    public const UInt32 SWP_NOMOVE = 0x0002;
    public const UInt32 SWP_SHOWWINDOW = 0x0040;
}
"@
	$hwnd = [User32]::FindWindow($null, "Administrator: Windows PowerShell ISE")
	if ($hwnd -ne [IntPtr]::Zero)
	{
		[User32]::SetWindowPos($hwnd, [User32]::HWND_TOPMOST, 0, 0, 0, 0, [User32]::SWP_NOSIZE -bor [User32]::SWP_NOMOVE -bor [User32]::SWP_SHOWWINDOW)
	}
}



$IntunePrepTool_Load = {
	Set-ControlTheme $IntunePrepTool -Theme Dark
	#Set-ControlTheme $config_tabpage -Theme Dark
	$scaledHeight = ConvertTo-ScaledPixel -Form $IntunePrepTool -Height 720
	$scaledWidth = ConvertTo-ScaledPixel -Form $IntunePrepTool -Width 1725
	

	if (!(Test-Path -Path "c:\users\$env:username\.IntunePrepTool"))
	{
		
		New-Item -ItemType Directory -Path "c:\users\$env:username\.IntunePrepTool"
	}
	
	try
	{
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			Copy-Item -Path "C:\Program Files\IntunePrepTool\config_customerinfo.csv" -Destination "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
			Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
			Update-ListBox $update_exe_listbox1 $cis.customername -Append
		}
		
	}
	catch
	{
		
		[void][System.Windows.Forms.MessageBox]::Show('Add customers in the config tab', 'Please Add Customer first')
		
	}
	
	$rechten = [bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544")
	if ($rechten -eq $false)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Admin Rights needed!, Please run as Administrator', 'Please run as Administrator') # Casting the method to [void] suppresses the output. 
		
	}
	else
	{
		$restrictionpolicy = Get-ExecutionPolicy -ErrorAction SilentlyContinue;
		if ($restrictionpolicy -ne 'Unrestricted')
		{
			
			if ([System.Windows.Forms.MessageBox]::Show('Set-ExecutionPolicy Unrestricted?; Please reopen IntunePrepTool', 'Powershell Execution Policy needs to be unrestricted', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	Set-ExecutionPolicy Unrestricted

'@
				if (Test-Path "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1")
				{
					powershell.exe -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
				}
				else
				{
					$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1" -Confirm:$false -Force
					Start-Sleep 1
					powershell -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
				}
			}
		}
		else
		{
			if (Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf)
			{
				Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
			}
			$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
			if ($ResolveWingetPath)
			{
				$WingetPath = $ResolveWingetPath[-1].Path
			}
			$wingetexe = $ResolveWingetPath
			
			if (Test-path $wingetexe)
			{
				$wingetOption = 1
				$version = & $wingetexe --version
			}
			else
			{
				$wingetOption = 2
				$version = winget --version
			}
			if (($version -notlike 'v1.9*') -and ($version -notlike 'v1.10*') -and ($version -notlike 'v1.11*'))
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use button to Install / Update Winget', 'Winget missing or wrong version')
				
			}
			else
			{
			<#
			if ($wingetOption -like 1)
			{
				& $wingetexe search rink-turksma.IntunePrepTool --accept-source-agreements 2>$null
				$IntunePrepToolversion = & $wingetexe list --id rink-turksma.IntunePrepTool
			}
			else
			{
				winget search rink-turksma.IntunePrepTool --accept-source-agreements
				$IntunePrepToolversion = winget list --id rink-turksma.IntunePrepTool
			}
			Write-Host $IntunePrepToolversion
			if ($IntunePrepToolversion | Select-String '\bVersion\s+Available\b')
			{
				[void][System.Windows.Forms.MessageBox]::Show('Use button on config page to check for updates ', 'New version IntunePrepTool available')
			} #>
			}
			
			
			
			try
			{
				
				Get-ChildItem -Path "IntuneWinAppUtil.exe" -ErrorAction Stop
			}
			catch
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download Microsoft Win32 Content Prep Tool. Place EXE file in same directory as this script', 'IntuneWinAppUtil missing') # Casting the method to [void] suppresses the output. 
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			}
			if (Test-Path 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -PathType Leaf)
			{
				$reqPSModules = Get-Content 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt'
				if ($reqPSModules -like 'false')
				{
					Remove-Item 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Confirm:$false -Force
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
				}
				else
				{
					
				}
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
			}
			
			
			if (!(test-path -path 'C:\ProgramData\chocolatey'))
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use the Button: "Install Chocolatey"', 'Chocolatey missing') # Casting the method to [void] suppresses the output. 
				
			}
			
			
			refreshTenants
			refreshTenantsUpload
			
			$config_tabpage.Dock = 'Fill'
			$config_tabpage.Visible = $true
			$config_tabpage.Enabled = $true
			
			
			
			
			$BuildingBlocks_datagridview1.DataSource = $BuildingBlocksTable;
			$BuildingBlocks_datagridview2.DataSource = $BuildingBlocksTable2;
			$BuildingBlocks_datagridview3.DataSource = $BuildingBlocksTable3;
			
		}
	}
}





$darkToolStripMenuItem_Click = {
	#TODO: Place custom script here
	Set-ControlTheme -Control $IntunePrepTool -Theme Dark
}

$lightToolStripMenuItem_Click = {
	Set-ControlTheme -Control $IntunePrepTool -Theme Light
}

#region Control Theme Helper Function
<#
	.SYNOPSIS
		Applies a theme to the control and its children.
	
	.PARAMETER Control
		The control to theme. Usually the form itself.
	
	.PARAMETER Theme
		The color theme:
		Light
		Dark

	.PARAMETER CustomColor
		A hashtable that contains the color values.
		Keys:
		WindowColor
		ContainerColor
		BackColor
		ForeColor
		BorderColor
		SelectionForeColor
		SelectionBackColor
		MenuSelectionColor
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -Theme Dark
	
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -CustomColor @{ WindowColor = 'White'; ContainerBackColor = 'Gray'; BackColor... }
	.NOTES
		Created by SAPIEN Technologies, Inc.
#>
function Set-ControlTheme
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.ComponentModel.Component]$Control,
		[ValidateSet('Light', 'Dark')]
		[string]$Theme = 'Dark',
		[System.Collections.Hashtable]$CustomColor
	)
	
	$Font = [System.Drawing.Font]::New('Segoe UI', 9)
	
	#Initialize the colors
	if ($Theme -eq 'Dark')
	{
		$WindowColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ContainerColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
		$BackColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ForeColor = [System.Drawing.Color]::White
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::DimGray
	}
	else
	{
		$WindowColor = [System.Drawing.Color]::White
		$ContainerColor = [System.Drawing.Color]::WhiteSmoke
		$BackColor = [System.Drawing.Color]::Gainsboro
		$ForeColor = [System.Drawing.Color]::Black
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::LightSteelBlue
	}
	
	if ($CustomColor)
	{
		#Check and Validate the custom colors:
		$Color = $CustomColor.WindowColor -as [System.Drawing.Color]
		if ($Color) { $WindowColor = $Color }
		$Color = $CustomColor.ContainerColor -as [System.Drawing.Color]
		if ($Color) { $ContainerColor = $Color }
		$Color = $CustomColor.BackColor -as [System.Drawing.Color]
		if ($Color) { $BackColor = $Color }
		$Color = $CustomColor.ForeColor -as [System.Drawing.Color]
		if ($Color) { $ForeColor = $Color }
		$Color = $CustomColor.BorderColor -as [System.Drawing.Color]
		if ($Color) { $BorderColor = $Color }
		$Color = $CustomColor.SelectionBackColor -as [System.Drawing.Color]
		if ($Color) { $SelectionBackColor = $Color }
		$Color = $CustomColor.SelectionForeColor -as [System.Drawing.Color]
		if ($Color) { $SelectionForeColor = $Color }
		$Color = $CustomColor.MenuSelectionColor -as [System.Drawing.Color]
		if ($Color) { $MenuSelectionColor = $Color }
	}
	
	#Define the custom renderer for the menus
	#region Add-Type definition
	try
	{
		[SAPIENTypes.SAPIENColorTable] | Out-Null
	}
	catch
	{
		if ($PSVersionTable.PSVersion.Major -ge 7)
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing', 'System.Drawing.Primitives'
		}
		else
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing'
		}
		Add-Type -ReferencedAssemblies $Assemblies -TypeDefinition "
using System;
using System.Windows.Forms;
using System.Drawing;
namespace SAPIENTypes
{
    public class SAPIENColorTable : ProfessionalColorTable
    {
        Color ContainerBackColor;
        Color BackColor;
        Color BorderColor;
		Color SelectBackColor;

        public SAPIENColorTable(Color containerColor, Color backColor, Color borderColor, Color selectBackColor)
        {
            ContainerBackColor = containerColor;
            BackColor = backColor;
            BorderColor = borderColor;
			SelectBackColor = selectBackColor;
        } 
		public override Color MenuStripGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuStripGradientEnd { get { return ContainerBackColor; } }
        public override Color ToolStripBorder { get { return BorderColor; } }
        public override Color MenuItemBorder { get { return SelectBackColor; } }
        public override Color MenuItemSelected { get { return SelectBackColor; } }
        public override Color SeparatorDark { get { return BorderColor; } }
        public override Color ToolStripDropDownBackground { get { return BackColor; } }
        public override Color MenuBorder { get { return BorderColor; } }
        public override Color MenuItemSelectedGradientBegin { get { return SelectBackColor; } }
        public override Color MenuItemSelectedGradientEnd { get { return SelectBackColor; } }      
        public override Color MenuItemPressedGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientEnd { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientMiddle { get { return ContainerBackColor; } }
        public override Color ImageMarginGradientBegin { get { return BackColor; } }
        public override Color ImageMarginGradientEnd { get { return BackColor; } }
        public override Color ImageMarginGradientMiddle { get { return BackColor; } }
    }
}"
	}
	#endregion
	
	$colorTable = New-Object SAPIENTypes.SAPIENColorTable -ArgumentList $ContainerColor, $BackColor, $BorderColor, $MenuSelectionColor
	$render = New-Object System.Windows.Forms.ToolStripProfessionalRenderer -ArgumentList $colorTable
	[System.Windows.Forms.ToolStripManager]::Renderer = $render
	
	#Set up our processing queue
	$Queue = New-Object System.Collections.Generic.Queue[System.ComponentModel.Component]
	$Queue.Enqueue($Control)
	
	Add-Type -AssemblyName System.Core
	
	#Only process the controls once.
	$Processed = New-Object System.Collections.Generic.HashSet[System.ComponentModel.Component]
	
	#Apply the colors to the controls
	while ($Queue.Count -gt 0)
	{
		$target = $Queue.Dequeue()
		
		#Skip controls we already processed
		if ($Processed.Contains($target)) { continue }
		$Processed.Add($target)
		
		#Set the text color
		$target.ForeColor = $ForeColor
		
		#region Handle Controls
		if ($target -is [System.Windows.Forms.Form])
		{
			#Set Font
			$target.Font = $Font
			$target.BackColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.SplitContainer])
		{
			$target.BackColor = $BorderColor
		}
		elseif ($target -is [System.Windows.Forms.PropertyGrid])
		{
			$target.BackColor = $BorderColor
			$target.ViewBackColor = $BackColor
			$target.ViewForeColor = $ForeColor
			$target.ViewBorderColor = $BorderColor
			$target.CategoryForeColor = $ForeColor
			$target.CategorySplitterColor = $ContainerColor
			$target.HelpBackColor = $BackColor
			$target.HelpForeColor = $ForeColor
			$target.HelpBorderColor = $BorderColor
			$target.CommandsBackColor = $BackColor
			$target.CommandsBorderColor = $BorderColor
			$target.CommandsForeColor = $ForeColor
			$target.LineColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.ContainerControl] -or
			$target -is [System.Windows.Forms.Panel])
		{
			#Set the BackColor for the container
			$target.BackColor = $ContainerColor
			
		}
		elseif ($target -is [System.Windows.Forms.GroupBox])
		{
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.Button])
		{
			$target.FlatStyle = 'Flat'
			$target.FlatAppearance.BorderColor = $BorderColor
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.CheckBox] -or
			$target -is [System.Windows.Forms.RadioButton] -or
			$target -is [System.Windows.Forms.Label])
		{
			#$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.ComboBox])
		{
			$target.BackColor = $BackColor
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.TextBox])
		{
			$target.BorderStyle = 'FixedSingle'
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.DataGridView])
		{
			$target.GridColor = $BorderColor
			$target.BackgroundColor = $ContainerColor
			$target.DefaultCellStyle.BackColor = $WindowColor
			$target.DefaultCellStyle.SelectionBackColor = $SelectionBackColor
			$target.DefaultCellStyle.SelectionForeColor = $SelectionForeColor
			$target.ColumnHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.ColumnHeadersDefaultCellStyle.ForeColor = $ForeColor
			$target.EnableHeadersVisualStyles = $false
			$target.ColumnHeadersBorderStyle = 'Single'
			$target.RowHeadersBorderStyle = 'Single'
			$target.RowHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.RowHeadersDefaultCellStyle.ForeColor = $ForeColor
			
		}
		elseif ($PSVersionTable.PSVersion.Major -le 5 -and $target -is [System.Windows.Forms.DataGrid])
		{
			$target.CaptionBackColor = $WindowColor
			$target.CaptionForeColor = $ForeColor
			$target.BackgroundColor = $ContainerColor
			$target.BackColor = $WindowColor
			$target.ForeColor = $ForeColor
			$target.HeaderBackColor = $ContainerColor
			$target.HeaderForeColor = $ForeColor
			$target.FlatMode = $true
			$target.BorderStyle = 'FixedSingle'
			$target.GridLineColor = $BorderColor
			$target.AlternatingBackColor = $ContainerColor
			$target.SelectionBackColor = $SelectionBackColor
			$target.SelectionForeColor = $SelectionForeColor
		}
		elseif ($target -is [System.Windows.Forms.ToolStrip])
		{
			
			$target.BackColor = $BackColor
			$target.Renderer = $render
			
			foreach ($item in $target.Items)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ToolStripMenuItem] -or
			$target -is [System.Windows.Forms.ToolStripDropDown] -or
			$target -is [System.Windows.Forms.ToolStripDropDownItem])
		{
			$target.BackColor = $BackColor
			foreach ($item in $target.DropDownItems)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ListBox] -or
			$target -is [System.Windows.Forms.ListView] -or
			$target -is [System.Windows.Forms.TreeView])
		{
			$target.BackColor = $WindowColor
		}
		else
		{
			$target.BackColor = $BackColor
		}
		#endregion
		
		if ($target -is [System.Windows.Forms.Control])
		{
			#Queue all the child controls
			foreach ($child in $target.Controls)
			{
				$Queue.Enqueue($child)
			}
		}
	}
}
#endregion

$winget_maakPackage_button1_Click = {
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$fid = $config_packagefolder
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$wlo = $Winget_locale_textbox.text
		
	}
	else { $wlo = $null; }
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$wve = $winget_version_textbox1.text
	}
	else { $wve = $null; }
	
	$DisplayName = $winget_displayname_textbox1.text
	$WinGetID = $wid
	$regApp1 = $DisplayName
	$version = $vid
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$outputDirectory = $fid
	Set-Location $PSScriptRoot
	
	$winget_output_textbox3.Text = "`nNew intunewin package will now be created: `r`n"
	$winget_output_textbox3.AppendText("Please wait`r`n")
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$wingetID\$version\source" -s "$outputDirectory\$wingetID\$version\source\install.ps1" -o "$outputDirectory\$wingetID\$version\output" -q
	
	Rename-Item -Path "$outputDirectory\$wingetID\$version\output\install.intunewin" -NewName "$outputDirectory\$wingetID\$version\output\$wingetID.intunewin"
	
	
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$version\output\$wingetID.intunewin")
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Version: $Version `r`n")
	$winget_output_textbox3.AppendText("Install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$winget_output_textbox3.AppendText("un-install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$winget_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$regApp1\"
	$regkeyApp
	$winget_output_textbox3.AppendText("$regkeyApp `r`n")
	$winget_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$winget_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: $Version `r`n")
	$winget_output_textbox3.AppendText("Please reopen tool to make another winget package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$wingetID.intunewin"
			DisplayName   = $DisplayName
			Publisher	  = $config_customername_textbox.Text
			AppVersion    = $version;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$wingetID\$version\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$wingetID\$version\output\"
	$winget_output_textbox3.AppendText("Config.csv written to: `r`n")
	$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$version\output\config.csv")
	$winget_output_textbox3.AppendText("  `r`n")
	$winget_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$winget_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$winget_upload_logo_button1.Visible = $true
	$winget_upload_logo_button1.Enabled = $true;
	$buildingBlokcsCSV = $winget_buildingBlocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$wingetID\$version\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$DisplayName\BuildingBlocks.csv" -force -NoTypeInformation
		$winget_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$winget_output_textbox3.AppendText("$config_buildingblockspath\$DisplayName\BuildingBlocks.csv `r`n")
		$winget_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
	
	
}



$winget_WingetID_textbox1_TextChanged = {
	#TODO: Place custom script here
	
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$versie_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$config_packagefolder_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_output_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_intunewin_tabpage2_Click = {
	#TODO: Place custom script here
	
}

$config_packagefolder_label_Click = {
	#TODO: Place custom script here
	
}

$winget_checkurl_button1_Click = {
	
	$wgid = $winget_WingetID_textbox1.text
	
	
	$showurl = winget show $wgid --accept-source-agreements
	foreach ($l in $showurl)
	{
		if ($l -like "*Installer Url*") { $url = "https:" + $l.Split(":")[2] }
	}
	
	
	
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show($URL, 'Download source URL') # Casting the method to [void] suppresses the output. 
	
}

$config_customername_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_logfoldertarger_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_save_button_Click = {
	#TODO: Place custom script here
	
	[string]$c_customername = $config_customername_textbox.text
	[string]$c_logfoldertarget = $config_logfoldertarger_textbox.text
	[string]$c_packagefolder = $config_packagefolder_textbox.text
	[string]$c_buildingblocksfolder  = $config_buildingblocks_textbox3.text
	[string]$c_downloadfolder = $config_download_folder_textbox3.Text
	
	[string]$c_customername = $c_customername.Replace(" ","")
	[string]$c_logfoldertarget = $c_logfoldertarget.Replace(" ", "")
	[string]$c_packagefolder = $c_packagefolder.Replace(" ", "")
	[string]$c_buildingblocksfolder = $c_buildingblocksfolder.Replace(" ", "")
	[string]$c_downloadfolder = $c_downloadfolder.Replace(" ", "")

	$config_customerinfo += @([config_customerinfo]@{
			customername    = $c_customername
			logfoldertarget = $c_logfoldertarget
			packagefolder   = $c_packagefolder
			downloadpath    = $c_downloadfolder;
			buildingblockspath = $c_buildingblocksfolder;
		})
	
	
	$existing_customerinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$filtered_customerinfo = $existing_customerinfo | Where-Object { $_.customername -ne $config_customerinfo.customername }
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Force
	$filtered_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Append
	$config_listbox.ResetText()
	try
	{
		$config_import_csv = $null;
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		$config_listbox.ClearSelected()
		$config_listbox.Items.Clear()
		$config_listbox.Refresh()
		foreach ($cis in $config_import_csv)
		{
		
				Update-ListBox $config_listbox $cis.customername -Append
				Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
				Update-ListBox $update_exe_listbox1 $cis.customername -Append
			
			
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$tools_winget_searchtabcontrol1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$exe_openexe_button1_Click = {
	#TODO: Place custom script here
	$exe_openfiledialog1.ShowDialog()
	$exe_label1.Text = $exe_openfiledialog1.SafeFileName
	$exe_label1.Visible = $true;
	$exe_maakPackageDir_button1.Enabled = $true
	$exe_open_Azure_OpenAI_Example_button1.Enabled = $true
	$exe_open_withqquestion_button1.Enabled = $true
}

$exe_label1_Click = {
	#TODO: Place custom script here
	
}

$exe_maakPackageDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$exepnaam = $exepnaam -replace (" ", "")
	$exe_packagenaam_textbox1.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$exe_output_textbox1.Text = "`nNew package directory created: `r`n"
			$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("`nEXE file will be copied now `r`n")
			
			[string]$exe_org_path = $exe_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $exe_org_path -Confirm:$false
				Copy-Item -Path $exe_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\source" -ErrorAction Stop
				$exe_output_textbox1.AppendText("`nEXE file copy done!`r`n")
				$exe_output_textbox1.AppendText("`nIf you need any additional files please place in just created source directory `r`n")
				$exe_panel1.Enabled = $true
				$exe_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nEXE file copy failed. Please select EXE file first `r`n")
			}
			$exe_open_sourcedir_button1.Enabled = $true
			$exe_open_sourcedir_button1.Visible = $true
			$exe_maakScripting_button1.Enabled = $true
			$exe_buttonAddCustomPackageDesc.Enabled = $true
			$exe_buttonAddCustomPackageDesc.Visible = $true
			
		}
	}
	
	
}

$exe_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$exe_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_intunewin_tabpage5_Click = {
	#TODO: Place custom script here
	
}

$exe_parsInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	$argList = $exe_parsInstall_textbox1.Text
	$exebestand = $exe_openfiledialog1.SafeFileName
	$exe_output_installparameters.text = "Start-Process -FilePath $EXEbestand -ArgumentList $argList"
}

$exe_output_installparameters_Click = {
	#TODO: Place custom script here
	
}

$exe_install_test_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show("After successful test in PowerShell ISE. Please click the 'Test Done' button.", 'Test install.ps1?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		$backupFolder = "$env:LOCALAPPDATA\temp"
		$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
		$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
		$preBackupPath = Join-Path $backupFolder "PreChanges64_$timeStamp.reg"
		try
		{
			New-Variable -Name 'exe_preBackupPath64' -Value $preBackupPath -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'exe_preBackupPath64' -Value $preBackupPath -Scope Script
		}
		
		reg export "$regExportPath" "$preBackupPath" /y | Out-Null
		$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
		$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
		$preBackupPath = Join-Path $backupFolder "PreChanges32_$timeStamp.reg"
		try
		{
			New-Variable -Name 'exe_preBackupPath32' -Value $preBackupPath -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'exe_preBackupPath32' -Value $preBackupPath -Scope Script
		}
		reg export "$regExportPath" "$preBackupPath" /y | Out-Null
		$exe_test_done_button1CreateInstallScript.Enabled = $true
		$exe_gotobuildingblocksButton.Enabled = $true
		
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$exe_radiobuttonUninstallEXEPath_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_parsUnInstall_textbox1.Enabled = $true
	$exe_parsUnInstall_textbox1.Visible = $true
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
}

$exe_radiobuttonGebruikZelfdeEXEAlsB_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_parsUnInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exebestandUninstall = $exe_uninstall_exe_path_textbox2.text
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exebestandUninstall = $exe_openfiledialog1.SafeFileName
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $true
	$exe_labelVoorbeeldUninstall.Enabled = $true
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
	
	$argList2 = $exe_parsUnInstall_textbox1.text
	if ($exe_openfiledialog1.SafeFileName -like "*.exe")
	{
		
		$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
	}
}

$exe_labelVoorbeeldUninstall_Click = {
	#TODO: Place custom script here
	
}

$exe_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation.. You can Edit in Powershell ISE. And save that file if needed.', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$exe_addBuildingBlocksCSVButton.Enabled = $true
	}
	
	
	
}

$exe_maakScripting_button1_Click = {
	#TODO: Place custom script here
	
	$exe_UnlInstallParameters.Visible = $true
	$exe_UnlInstallParameters.Enabled = $true
	$exe_radiobuttonUninstallEXEPath.Visible = $true
	$exe_radiobuttonUninstallEXEPath.Enabled = $true
	$exe_install_test_button1.Enabled = $true
	$exe_install_test_button1.Visible = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Enabled = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Visible = $true
	$exe_radiobutton3.Enabled = $true
	$exe_radiobutton3.Visible = $true
	
	
	$exe_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 18:02
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$exeFile = "!!ExeFile!!"
$exeParameters = "!!ExeParams!!" ## Check EXE Params.. 
# Customer variables
$logDir = "!!LogDir!!"
$registerDetectionRoot = "!!RegisterDetectionRoot!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $exeFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Installation completed of $exeFile" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error executing $exeFile" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:









Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_installFile = $exe_installFile.Replace('"!!AppName!!"', $appnaam)
	$exe_installFile = $exe_installFile.Replace('!!LogDir!!', $logdir)
	$exe_installFile = $exe_installFile.Replace('!!RegisterDetectionRoot!!', $RegisterDetectionroot)
	$exe_installFile = $exe_installFile.Replace('!!Version!!', $versie)
	$exe_installFile = $exe_installFile.Replace('"!!ExeFile!!"', $EXEbestand)
	$exe_installFile = $exe_installFile.Replace('"!!ExeParams!!"', $EXEPARSInput)
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	try
	{
		$exe_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$exe_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	
	
}

$exe_uninstall_exe_path_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$exe_maak_intuneWIN_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$mkiapn = $exe_packagenaam_textbox1.text
	$versie = $exe_versie_textbox1.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$exepnaam\$exeversie\source\" -s "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -o "$outputDirectory\$exepnaam\$exeversie\output\" -q
	Rename-Item -Path "$outputDirectory\$exepnaam\$exeversie\output\install.intunewin" -NewName "$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin"
	$exe_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin")
	$exe_output_textbox1.AppendText("`r`n")
	
	$exe_output_textbox1.AppendText("Install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$exe_output_textbox1.AppendText("un-install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$exe_output_textbox1.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$mkiapn\"
	$regkeyApp
	$exe_output_textbox1.AppendText("$regkeyApp `r`n")
	$exe_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$exe_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: $Versie `r`n")
	$exe_output_textbox1.AppendText("Please reopen tool to make another EXE package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$exepnaam.intunewin"
			DisplayName   = $exepnaam
			Publisher	  = $config_customername
			AppVersion    = $exeversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$exepnaam\$exeversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$exepnaam\$exeversie\output\"
	$exe_output_textbox1.AppendText("Config.csv written to naar: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\config.csv")
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	$exe_output_textbox1.AppendText("  `r`n")
	$exe_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$exe_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $exe_buildingblockscsv_textbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$exepnaam\$exeversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$exepnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$exe_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$exe_output_textbox1.AppendText("$config_buildingblockspath\$exepnaam\BuildingBlocks.csv `r`n")
		$exe_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
	
}

$msi_buttonOpenMSIFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog1.ShowDialog()
	$msi_openmsi_label1.Text = $msi_openfiledialog1.SafeFileName
	$msi_openmsi_label1.Visible = $true;
	$msi_openfiledialog2.Reset()
	$msi_openfiledialog3.Reset()
	$msi_openmsp_label1.Text = ''
	$msi_openmsp_label1.Visible = $false
	$msi_openmsp_label1.Enabled = $false
	$msi_buttonOpenMSPFile.Enabled = $true
	$msi_buttonOpenMSPFile.Visible = $true
	$msi_openmst_label1.Text = ''
	$msi_buttonOpenMSTFile.Visible = $true
	$msi_buttonOpenMSTFile.Enabled = $true
	#$msi_reg_hklm_label5.Visible = $false
	#$msi_reg_hklm_label5.Enabled = $false
	
	
}

$msi_buttonOpenMSPFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog2.ShowDialog()
	$msi_openmsp_label1.Text = $msi_openfiledialog2.SafeFileName
	$msi_openmsp_label1.Visible = $true
	$msi_openmsp_label1.Enabled = $true
}


$msi_buttonOpenMSTFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog3.ShowDialog()
	$msi_openmst_label1.Text = $msi_openfiledialog3.SafeFileName
	$msi_openmst_label1.Visible = $true
	$msi_openmst_label1.Enabled = $true
}



$msi_openmsi_label1_Click = {
	#TODO: Place custom script here
	
}

$msi_buttonCreatePackageDirecto_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msipnaam = $msi_packagenaam_textbox1.text
	$msipnaam = $msipnaam -replace (" ", "")
	$msi_packagenaam_textbox1.text = $msipnaam
	$msiversie = $msi_versie_textbox1.text
	
	if ($msipnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msiversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\output"
			}
			$msi_output_textbox1.Text = "`nNew package direcotory created: `r`n"
			$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\source")
			$msi_output_textbox1.AppendText("`r`n")
			$msi_output_textbox1.AppendText("`nMSI file will now be copied`r`n")
			[string]$msi_org_path = $msi_openfiledialog1.FileNames
			
			
			
			try
			{
				Unblock-File -Path $msi_org_path -Confirm:$false
				function Get-MSIProductCode
				{
					### GPT o1-preview
					param (
						[Parameter(Mandatory = $true)]
						[string]$MSIPath
					)
					$installer = New-Object -ComObject WindowsInstaller.Installer
					$database = $installer.OpenDatabase($MSIPath, 0)
					$view = $database.OpenView("SELECT Value FROM Property WHERE Property='ProductCode'")
					$view.Execute()
					$record = $view.Fetch()
					if ($record -ne $null)
					{
						$productCode = $record.StringData(1)
						return $productCode
					}
					else
					{
						Write-Error "ProductCode niet gevonden in het MSI-bestand."
						return $null
					}
					$view.Close()
				}
				$productCode = Get-MSIProductCode -MSIPath $msi_org_path
				
				
				$MSINewname = $msi_openfiledialog1.FileName
				
				$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
				$MSINewname = $MSINewname.Replace(" ", "")
				$MSIbestand = "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname"
				
				
				
				#Write-Host $MSIbestand
				Copy-Item -Path $msi_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname" -ErrorAction Stop
				$msi_output_textbox1.AppendText("`nMSI file copy done `r`n")
				$msp = $msi_openmsp_label1.Text
				
				if ($msp -ne '')
				{
					[string]$msp_org_path = $msi_openfiledialog2.FileNames
					Unblock-File -Path $msp_org_path -Confirm:$false
					$MSPNewname = $msi_openfiledialog2.FileName
					$MSPNewname = $MSPNewname.Split("\")[$MSPNewname.Split("\").Count - 1]
					$MSPNewname = $MSPNewname.Replace(" ", "")
					Copy-Item -Path $msp_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSPNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMSP file copy done `r`n")
				}
				$mst = $msi_openmst_label1.Text
				if ($mst -ne '')
				{
					[string]$mst_org_path = $msi_openfiledialog3.FileNames
					Unblock-File -Path $mst_org_path -Confirm:$false
					$MSTNewname = $msi_openfiledialog3.FileName
					$MSTNewname = $MSTNewname.Split("\")[$MSTNewname.Split("\").Count - 1]
					$MSTNewname = $MSTNewname.Replace(" ", "")
					Copy-Item -Path $mst_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSTNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMST file copy done `r`n")
				}
				
				$msi_output_textbox1.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				$msi_panel1.Enabled = $true
				$msi_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			$appNaam = $msipnaam
			$versie = $msiversie
			#$msi_openfiledialog1.SafeFileName
			#klant variabelen
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			#Dyn vars
			$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
			$filenaamMSILog = $appNaam + $versie + "MSI"
			$filenaamMSIUninstallLog = $appNaam + $versie + "MSI" + "_uninstall"
			$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
			$logfileMSIUninstall = "$(Join-Path $logdir  "$filenaamMSIUninstallLog.txt")"
			
			if ($msp -ne '')
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname PATCH=$MSPNewname"
			}
			else
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname"
			}
			if ($mst -ne '')
			{
				$oldMSIInstallstring = $msi_install_par_textbox3.Text
				$msi_install_par_textbox3.Text = $oldMSIInstallstring + " TRANSFORMS=$MSTNewname"
				
			}
			
			
			$msi_uninstall_par_textbox1.Text = "msiexec /qn, /l*v $logfileMSIUninstall /x$productCode"
			$msi_OpenSourceDir_button1.Enabled = $true
			$msi_OpenSourceDir_button1.Visible = $true
			$msi_open_Orca_button1.Enabled = $true
			$msi_addDescription.Enabled = $true
			$msi_addDescription.Visible = $true
		}
	}
	
	
}

$labelInstallParametersadj_Click = {
	#TODO: Place custom script here
	
}

$msi_uninstall_par_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$msi_button1CreateInstallScript_Click = {
	#TODO: Place custom script here
	#'"' + $exe_openfiledialog1.SafeFileName + '"'
	
	$msi_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:53
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
	write-host $startPMSI
	$msilog = get-content $logfileMSI
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Script started i.cmd" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
		write-host ""
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green

	}
	
	if ($msiuninstallcode -eq $null) { $excode = 1 ; write-error "Can't find uninstall code in MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
    Else
    {
        write-host "Script started i.cmd" -ForegroundColor Green
        write-host "Possible uninstall command is:" -ForegroundColor Green
        write-host ""
        write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
        write-host ""
        Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
        write-host $logfileMSI -ForegroundColor Green
        $MSILOGS = get-content $logfileMSI 
        $MSILOGS
        Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
        $excode = 0
    }
   
	
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content $logfileMSI 
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue


    $excode = 1
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}

write-host "Possible uninstall command is:" -ForegroundColor Green
write-host ""
write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green
write-host ""

if (Test-Path 'hklm.reg') {
    Write-Host "hklm.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hklm.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_install_par_textbox3.Text + '"'
	
	$msi_installFile = $msi_installFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_installFile = $msi_installFile.Replace('!!logdir!!', $logdir)
	$msi_installFile = $msi_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_installFile = $msi_installFile.Replace('!!versie!!', $versie)
	$msi_installFile = $msi_installFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	#$msi_installFile = $msi_installFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_install_par_textbox3.Text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\i.cmd" -encoding ascii -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$msi_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`ni.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$msi_output_textbox1.AppendText("`nAfter succesvol installation you can see the uninstall string in Powershell_ISE `r`n")
		$msi_output_textbox1.AppendText("`nIf this is not working. Check Tab Tools for uninstall strings `r`n")
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	$msi_test_install_button1.Enabled = $true
	$msi_test_install_button1.Visible = $true
	
	
}

$msi_install_par_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$msi_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show("When you want to add Building Blocks to this package, test installation first, then use the '(Optional) Go to Building Blocks' button", 'Test install.ps1?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msi_buttonOptionalGoToBuilding.Enabled = $true
	}
}

$Tools_Uninstall_String_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_Output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_Syswow_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$buttonUninstallstringWowAA32Node_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Hier volgen alle uninstallString sort by datum WowAA32Node `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WowAA32Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$msi_button5CreateIntunewinFile_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msi_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$msi_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$msi_output_textbox1.AppendText("`r`n")
	
	$msi_output_textbox1.AppendText("Install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msi_output_textbox1.AppendText("un-install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msi_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$msi_output_textbox1.AppendText("$regkeyApp `r`n")
	$msi_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$msi_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$msi_output_textbox1.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$msi_output_textbox1.AppendText("Config.csv written to: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$msi_output_textbox1.AppendText("  `r`n")
	$msi_buttonUploadLogoPNG.Enabled = $true
	$msi_buttonUploadLogoPNG.Visible = $true
	$msi_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msi_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $MSI_buildigblocks_Package_InProgresstextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$msipnaam\$msiversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$msipnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$msi_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$msi_output_textbox1.AppendText("$config_buildingblockspath\$msipnaam\BuildingBlocks.csv `r`n")
		$msi_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
}

$msi_OpenSourceDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$msipnaam\$msiversie\source\"
}

$msi_button3CreateUninstallScri_Click = {
	#TODO: Place custom script here
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI_uninstall"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_uninstall_par_textbox1.Text + '"'
	
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_uninstall_par_textbox1.text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
		$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`nu.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
		
		
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
	}
	$msi_button4TestUninstallPowers.Enabled = $true
	$msi_button4TestUninstallPowers.Visible = $true
	$msi_button5CreateIntunewinFile.Enabled = $true
	$msi_button5CreateIntunewinFile.Visible = $true
	
	
}

$msi_button4TestUninstallPowers_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msi_addBuildingBlocksSystemContextbutton5CreateIntunewinFile.Enabled = $true;
	}
}

$Reset_button1_Click = {
	#TODO: Place custom script here
	Clear-Host
}

$config_tabpage1_Click = {
	#TODO: Place custom script here
	
}

$winget_upload_button1_Click = {
	#TODO: Place custom script here
	<#
	$token = Connect-MSIntuneGraph -TenantID "339ad6f1-ba98-4db6-bf71-0c140c9271bc" -Interactive
	$RegisterDetectionroot = "Intune_Customer"
	$appNaam = "Greenshot"
	$versie = 1
	$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
	$regkeyApp = "$regkeyRoot\$appNaam"
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	Add-IntuneWin32App -FilePath $IntuneWinFile `
					   -DisplayName $DisplayName `
					   -Description $DisplayName `
					   -Publisher $Publisher `
					   -AppVersion $AppVersion `
					   -Icon $IconCMD `
					   -InstallExperience "system" `
					   -RestartBehavior "suppress" `
					   -DetectionRule $DetectionRule `
					   -InstallCommandLine 'powershell -executionpolicy bypass -file install.ps1' `
					   -UninstallCommandLine 'powershell -executionpolicy bypass -file uninstall.ps1' -Verbose
	#>
}

$upload_LoadConfig_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	}
	else
	{
		
		
		$config_csv_openfiledialog1.ShowDialog() | Out-Null
		if ($config_csv_openfiledialog1.FileNames -notcontains 'config_csv_openfiledialog1')
		{
			$upload2_IntuneWinFile_textbox1.Text = $null;
			$upload2_DisplayName_textbox2.Text = $null;
			$upload2_Publisher_textbox1.Text = $null;
			$upload2_AppVersion_textbox1.Text = $null;
			$upload2_reglocation_textbox2.Text = $null;
			$upload2_regValue_textbox1.Text = $null;
			$upload2_installCMD_textbox1.Text = $null;
			$upload2_uninstallCMD_textbox1.Text = $null;
			$upload2_context_textbox1.Text = $null;
			
			$upload_panel2.Enabled = $false
			[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
			$upload_configLoaded_textbox3.Text = $config_csv_openfiledialog1.FileNames
			$ConfigCSVImport = Import-Csv $config_csv_path
			#Write-Host $ConfigCSVImport
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload_context_textbox1.Text = $context
			
			
			if (!(test-path "$filepath\Logo.png" -PathType Leaf))
			{
				[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
				$upload_logo_button2.Enabled = $true
				$upload_logo_button2.Visible = $true
				
			}
		}
	}
}

$upload_IntuneWinFile_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_DisplayName_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_Publisher_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_AppVersion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_reglocation_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_regValue_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_installCMD_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_upload_button1_Click = {
	#TODO: Place custom script here
	$uploadIntuneFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	22-8-2025 22:36
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	UploadIntune.ps1
	===========================================================================
#>
#Requires -RunAsAdministrator
$RequiredPSModules = get-content "C:\Program Files\IntunePrepTool\InstallReqPSModules.txt"
if ($RequiredPSModules -like 'false')
{
	write-error 'Missing required Powershell Modules'
	start-sleep 60
	exit
}

[string]$config_csv_path = '!!CONFIGCSV!!'
[string]$buildingblocks_csv_path = '!!BUILDINGBLOCKSCSV!!'
$dep = "!!DEPENDENCY!!"
$AvailableAllUsers = "!!AvailableAllUsers!!"
$RequiredAllDevices = "!!RequiredAllDevices!!"
$SetupLikeOldVersion = "!!SetupLikeOldVersion!!"
$TenantName = "!!TenantName!!"
Write-host "First we logon to the Microsoft Tenant"
Write-host "`r`n"
Write-host "`r`n"

try
{
	$load_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv" -ErrorAction Stop
}
catch
{
	Write-Error "Error loading csv file c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv"
}


foreach ($load in $load_import_csv)
{
	if ($load.customername -eq $tenantName)
	{
		
		if ($load.target -ne 'plain')
		{
			$checkCredLoad = Get-StoredCredential -Target $load.target -AsCredentialObject
			$tenantID = $checkCredLoad.TargetName
			$tenantID = $tenantID.Split("_")[1]
			$AppId = $checkCredLoad.UserName
			$Secret = $checkCredLoad.Password
		}
		else
		{
			$cust = import-csv "c:\users\$env:username\.IntunePrepTool\$tenantname.csv"
			$tenantID = $cust.tenantID
			$AppId = $cust.appId
			$Secret = $cust.clientsecret
			$customPrivacyURL = $cust.customPrivacyURL
			
		}
	}
}

try
{
	Connect-MSIntuneGraph -TenantID $tenantID -ClientID $appID -ClientSecret $secret -ErrorAction Stop
}
catch
{
	Write-Error "No Connection to tenant. Please check app registration!!"
	start-sleep 60
	exit
}
$ConfigCSVImport = Import-Csv $config_csv_path
$itwnf = $ConfigCSVImport.IntuneWinFile
$filepath = $config_csv_path.TrimEnd("config.csv")
$itwnffilepath = $filepath + $itwnf
$descriptionpath = $filepath + 'Description.txt'
if (Test-Path $descriptionpath)
{
	$description = Get-Content $descriptionpath
}
else
{
	$description = "The package has been uploaded using the IntunePrepTool."
}
$regKeyApp = $ConfigCSVImport.regLocation
$versie = $ConfigCSVImport.AppVersion
$regvalue = $ConfigCSVImport.RegValue
$dnam = $ConfigCSVImport.DisplayName
$publ = $ConfigCSVImport.Publisher
$icmd = $ConfigCSVImport.installCMD
$ucmd = $ConfigCSVImport.uninstallCMD
if ($ConfigCSVImport.context)
{
	$context = $ConfigCSVImport.context
}
else
{
	$context = 'system'
}
$logoaanwezig = $null;
try
{
	$logoaanwezig = get-childitem "$filepath\logo.png" -ErrorAction Stop
	$icon = New-IntuneWin32AppIcon -FilePath "$filepath\logo.png"
}
catch
{
	Write-Host "No Logo.PNG found in Output Directory" - ForegroundColor Green; Write-host "`r`n"; $logoaanwezig = $null;
}
$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName $regvalue -StringComparisonOperator equal -StringComparisonValue $versie
$RequirementRule = New-IntuneWin32AppRequirementRule -Architecture "All" -MinimumSupportedWindowsRelease "W10_20H2"
write-host "We will first check if there are any apps already available in Intune with the same DisplayName" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
$Win32AppEvtVorigeVersies = Get-IntuneWin32App -DisplayName $dnam
if ($Win32AppEvtVorigeVersies -ne $null)
{
	write-host "Already version(s) found " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$evtvversie = $Win32AppEvtVorigeVersies.DisplayVersion
	write-host $evtvversie
	$alversieAppAanwezig = $true;
	write-host "After uploading new version you can choose Superseedence in this script" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
}

else
{
	$alversieAppAanwezig = $false;
}

write-host "We will upload to Intune now" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
if ($logoaanwezig -eq $null)
{
	if ($customPrivacyURL -ne $null)
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -PrivacyURL $customPrivacyURL
	}
	else
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule
	}
	
}
else
{
	if ($customPrivacyURL -ne $null)
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -PrivacyURL $customPrivacyURL
	}
	else
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule
	}
}
Write-host "If all is good the app will now be available in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";

if ($SetupLikeOldVersion -eq $true)
{
	if ($alversieAppAanwezig -eq $false) { write-host "Because there where no older versions of this software in Intune you have to do the assingments in the Intune portal" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	else
	{
		
		foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
		{
			write-host "We will now try to setup assignments " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
			$assinmentVorigeVersie = get-IntuneWin32AppAssignment -id $vorigeversie.id
			$evtvversie = $vorigeversie.DisplayVersion
			
			if ($assinmentVorigeVersie -eq $null) { write-host "Older version: $evtvversie has no assignments" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
			else
			{
				write-host ""; Write-host "`r`n"; Write-host "`r`n"
				$response = read-host "Press q to do nothing, Any other key to setup assignments like: $evtvversie"
				$niksdoen = $response -eq "q"
				if ($niksdoen -eq $true) { write-host "Ok.. Then you have to setup the assignments in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host "Ok .. We will fix the assignments for you!" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
					Remove-IntuneWin32AppAssignment -ID $vorigeversie.ID -Confirm:$false
					try
					{
						Add-IntuneWin32AppAssignmentGroup -Intent $assinmentVorigeVersie.intent -Include -ID $Win32App.id -GroupID $assinmentVorigeVersie.Target.groupId -ErrorAction Stop
					}
					catch
					{
						Write-Host "Something went wrong. You will have to do this in Intune" -ForegroundColor Green
					}
				}
			}
		}
		
		foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
		{
			$response = read-host "Press q to do nothing, Any other key to setup Supersedence  "
			$niksdoen = $response -eq "q"
			if ($niksdoen -eq $true) { write-host "Ok.. We are doing nothing here" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
			else
			{
				write-host "Ok .. We will try to fix superseedence" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
				Write-host "We will fix superseedence for:" -ForegroundColor Green
				$vorigeversie.displayVersion
				
				$superseede = New-IntuneWin32AppSupersedence -ID $vorigeversie.id -SupersedenceType Replace
				$bestaandeSuperSedence = $null; $bestaandeSuperSedence = Get-IntuneWin32AppSupersedence -ID $vorigeversie.id
				if ($bestaandeSuperSedence -ne $null) { Remove-IntuneWin32AppSupersedence -ID $bestaandeSuperSedence -Confirm:$False }
				Add-IntuneWin32AppSupersedence -ID $Win32App.id -Supersedence $superseede -Confirm:$false
			}
		}
	}
}
if ($AvailableAllUsers -eq $true)
{
	write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	Add-IntuneWin32AppAssignmentAllUsers -ID $Win32App.Id -Intent available -Notification showAll
}


if ($RequiredAllDevices -eq $true)
{
	write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	Add-IntuneWin32AppAssignmentAllDevices -ID $Win32App.Id -Intent required -Notification hideAll
}
write-host 'Upload Finished!' -ForegroundColor Green
start-sleep 15

'@
	function Get-CheckedNodes
	{
		param (
			[ValidateNotNull()]
			[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
			[ValidateNotNull()]
			[System.Collections.ArrayList]$CheckedNodes)
		
		foreach ($Node in $NodeCollection)
		{
			if ($Node.Checked)
			{
				[void]$CheckedNodes.Add($Node)
			}
			Get-CheckedNodes $Node.Nodes $CheckedNodes
		}
	}
	$CheckedNodes = New-Object System.Collections.ArrayList
	Get-CheckedNodes $upload_treeview2.Nodes $CheckedNodes
	[string]$config_csv_path = $upload_configLoaded_textbox3.Text
	foreach ($node in $CheckedNodes)
	{
		
		if ($config_csv_path -notlike '*BuildingBlocks.csv*')
		{
			$depWin = $upload_dep_textbox1.Text
			$tenantName = $node.Name
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!CONFIGCSV!!', $config_csv_path)
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!TenantName!!', $TenantName)
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!DEPENDENCY!!', $depWin)
			if ($Upload_beschikbaar_all_users_checkbox1.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $false)
			}
			if ($upload_checkboxRequiredForAllDevice.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $false)
			}
			if ($upload_checkboxSetupAssignmentLikeP.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $false)
			}
			
			
			
			
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$tenant = $node.Name
			$uploadFile = $filepath + "\uploadIntune" + $tenant + ".ps1"
			$uploadIntuneFile | Out-File $uploadFile -Force
			
			if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				Start-Process -FilePath "powershell.exe" -ArgumentList "-NoProfile -File $uploadFile"
				#powershell -file $filepath\uploadIntune.ps1
				#Start-Sleep 1
				#PowershellISEOnTop
			}
		}
		else
		{
			if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				$tenantName = $node.Name
				$scriptPath = "C:\Program Files\IntunePrepTool\UploadToIntuneBuildingBlocksCSV.ps1"
				$args = "-NoProfile -File `"$scriptPath`" -buildingblocks_csv_path `"$config_csv_path`" -tenantname `"$tenantName`""
				
				if ($Upload_beschikbaar_all_users_checkbox1.Checked)
				{
					$args += " -AvailableAllUsers `"True`""
				}
				
				if ($upload_checkboxRequiredForAllDevice.Checked)
				{
					$args += " -RequiredAllDevices `"True`""
				}
				Write-Host $args
				Start-Process -FilePath "powershell.exe" -ArgumentList $args
				
			}
			
		}
		
		
	}
	
	
}

$upload_tenantURL_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_upload_logo_button1_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$fid = $config_packagefolder_textbox.text
	Copy-Item -Path $logo_org_path -Destination "$fid\$wid\$vid\Output\logo.png" -ErrorAction Stop
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
	
	
}

$msi_buttonUploadLogoPNG_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$msi_output_textbox1.AppendText("`r`n")
	$msi_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	
}

$exe_uploadlogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
}



$upload_dep_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}





$config_panel_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_tenanturl_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

#region Control Helper Functions
function Show-NotifyIcon
{
<#
	.SYNOPSIS
		Displays a NotifyIcon's balloon tip message in the taskbar's notification area.
	
	.DESCRIPTION
		Displays a NotifyIcon's a balloon tip message in the taskbar's notification area.
		
	.PARAMETER NotifyIcon
     	The NotifyIcon control that will be displayed.
	
	.PARAMETER BalloonTipText
     	Sets the text to display in the balloon tip.
	
	.PARAMETER BalloonTipTitle
		Sets the Title to display in the balloon tip.
	
	.PARAMETER BalloonTipIcon	
		The icon to display in the ballon tip.
	
	.PARAMETER Timeout	
		The time the ToolTip Balloon will remain visible in milliseconds. 
		Default: 0 - Uses windows default.
#>
	 param(
	  [Parameter(Mandatory = $true, Position = 0)]
	  [ValidateNotNull()]
	  [System.Windows.Forms.NotifyIcon]$NotifyIcon,
	  [Parameter(Mandatory = $true, Position = 1)]
	  [ValidateNotNullOrEmpty()]
	  [String]$BalloonTipText,
	  [Parameter(Position = 2)]
	  [String]$BalloonTipTitle = '',
	  [Parameter(Position = 3)]
	  [System.Windows.Forms.ToolTipIcon]$BalloonTipIcon = 'None',
	  [Parameter(Position = 4)]
	  [int]$Timeout = 0
 	)
	
	if($null -eq $NotifyIcon.Icon)
	{
		#Set a Default Icon otherwise the balloon will not show
		$NotifyIcon.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon([System.Windows.Forms.Application]::ExecutablePath)
	}
	
	$NotifyIcon.ShowBalloonTip($Timeout, $BalloonTipTitle, $BalloonTipText, $BalloonTipIcon)
}




<#
	.SYNOPSIS
		Sets the emulation of the WebBrowser control for the application.
	
	.DESCRIPTION
		Sets the emulation of the WebBrowser control for the application using the installed version of IE.
		This improves the WebBrowser control compatibility with newer html features.
	
	.PARAMETER ExecutableName
		The name of the executable E.g. PowerShellStudio.exe.
		Default Value: The running executable name.
	
	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation

	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation PowerShell.exe
#>
function Set-WebBrowserEmulation
{
	param
	(
		[ValidateNotNullOrEmpty()]
		[string]$ExecutableName = [System.IO.Path]::GetFileName([System.Diagnostics.Process]::GetCurrentProcess().MainModule.FileName)
	)
	
	#region Get IE Version
	$valueNames = 'svcVersion', 'svcUpdateVersion', 'Version', 'W2kVersion'
	
	$version = 0;
	for ($i = 0; $i -lt $valueNames.Length; $i++)
	{
		$objVal = [Microsoft.Win32.Registry]::GetValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer', $valueNames[$i], '0')
		$strVal = [System.Convert]::ToString($objVal)
		if ($strVal)
		{
			$iPos = $strVal.IndexOf('.')
			if ($iPos -gt 0)
			{
				$strVal = $strVal.Substring(0, $iPos)
			}
			
			$res = 0;
			if ([int]::TryParse($strVal, [ref]$res))
			{
				$version = [Math]::Max($version, $res)
			}
		}
	}
	
	if ($version -lt 7)
	{
		$version = 7000
	}
	else
	{
		$version = $version * 1000
	}
	#endregion
	
	[Microsoft.Win32.Registry]::SetValue('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION', $ExecutableName, $version)
}



function Update-ComboBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.
	
	.PARAMETER ComboBox
		The ComboBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ComboBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red" -Append
		Update-ComboBox $combobox1 "White" -Append
		Update-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Update-ComboBox $combobox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ComboBox]$ComboBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ComboBox.Items.Clear()
	}
	
	if ($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ComboBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ComboBox.Items.Add($obj)
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	if ($ValueMember)
	{
		$ComboBox.ValueMember = $ValueMember
	}
}



function Get-CheckedNode
{
<#
	.SYNOPSIS
		This function collects a list of checked nodes in a TreeView

	.DESCRIPTION
		This function collects a list of checked nodes in a TreeView

	.PARAMETER  $NodeCollection
		The collection of nodes to search

	.PARAMETER  $CheckedNodes
		The ArrayList that will contain the all the checked items
	
	.EXAMPLE
		$CheckedNodes = New-Object System.Collections.ArrayList
		Get-CheckedNode $treeview1.Nodes $CheckedNodes
		foreach($node in $CheckedNodes)
		{	
			Write-Host $node.Text
		}
#>
	param (
		[ValidateNotNull()]
		[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
		[ValidateNotNull()]
		[System.Collections.ArrayList]$CheckedNodes
	)
	
	foreach ($Node in $NodeCollection)
	{
		if ($Node.Checked)
		{
			[void]$CheckedNodes.Add($Node)
		}
		Get-CheckedNode $Node.Nodes $CheckedNodes
	}
}



function Update-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The DataGridView control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the DataGridView's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	.PARAMETER AutoSizeColumns
	    Resizes DataGridView control's columns after loading the items.
	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		$Item,
		[Parameter(Mandatory = $false)]
		[string]$DataMember,
		[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($null -eq $Item)
	{
		$DataGridView.DataSource = $null
	}
	elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
	{
		$DataGridView.DataSource = $Item.Tables[0]
	}
	elseif ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView])
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{
			$array.Add($Item)
		}
		$DataGridView.DataSource = $array
	}
	
	if ($AutoSizeColumns -ne 'None')
	{
		$DataGridView.AutoResizeColumns($AutoSizeColumns)
	}
	
	$DataGridView.ResumeLayout()
}



function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterCIMProperties
			This switch removes CIM properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param (
		$InputObject,
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterCIMProperties)
	
	if ($null -eq $Table)
	{
		$Table = New-Object System.Data.DataTable
	}
	
	if ($null -eq $InputObject)
	{
		$Table.Clear()
		return @( ,$Table)
	}
	
	if ($InputObject -is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
	{
		$Table = $InputObject.Tables[0]
	}
	else
	{
		if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()
			
			if ($null -eq $InputObject) { return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach ($item in $InputObject)
			{
				if ($null -ne $item)
				{
					$object = $item
					break
				}
			}
			
			if ($null -eq $object) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if (-not $FilterCIMProperties -or -not $prop.Name.StartsWith('__')) #filter out CIM properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if ($null -ne $prop.Value)
					{
						try { $type = $prop.Value.GetType() }
						catch { Out-Null }
					}
					
					if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
						[void]$table.Columns.Add($prop.Name, $type)
					}
					else #Type info not found
					{
						[void]$table.Columns.Add($prop.Name)
					}
				}
			}
			
			if ($object -is [System.Data.DataRow])
			{
				foreach ($item in $InputObject)
				{
					$Table.Rows.Add($item)
				}
				return @( ,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()
		}
		
		foreach ($item in $InputObject)
		{
			$row = $table.NewRow()
			
			if ($item)
			{
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if ($table.Columns.Contains($prop.Name))
					{
						$row.Item($prop.Name) = $prop.Value
					}
				}
			}
			[void]$table.Rows.Add($row)
		}
	}
	
	return @( ,$Table)
}



function Update-ListBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ListBox or CheckedListBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ListBox control.
	
	.PARAMETER ListBox
		The ListBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ListBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ListBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ListBox $ListBox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ListBox $listBox1 "Red" -Append
		Update-ListBox $listBox1 "White" -Append
		Update-ListBox $listBox1 "Blue" -Append
	
	.EXAMPLE
		Update-ListBox $listBox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ListBox]$ListBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ListBox.Items.Clear()
	}
	
	if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
	{
		$ListBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ListBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ListBox.Items.Add($obj)
		}
		$ListBox.EndUpdate()
	}
	else
	{
		$ListBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ListBox.DisplayMember = $DisplayMember
	}
	if ($ValueMember)
	{
		$ListBox.ValueMember = $ValueMember
	}
}


#endregion

$config_listbox_SelectedIndexChanged = {
	#TODO: Place custom script here
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
	}
	catch
	{
		#Error handling here
	}
	
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -eq $config_listbox.SelectedItem)
		{
			$config_customername_textbox.text = $cis.customername
			$config_logfoldertarger_textbox.text = $cis.logfoldertarget;
			$config_packagefolder_textbox.text = $cis.packagefolder;
			$config_download_folder_textbox3.Text = $cis.downloadpath
			$config_buildingblocks_textbox3.Text = $cis.buildingblockspath
			if ($cis.downloadpath -like 'Enter UNC or local path for the download Package folder. (Evergreen / Winget)')
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download folder was added to config. Please use this tool or edit "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" ', 'Please add Download folder') # Casting the method to [void] suppresses the output. 
			}
			
			try
			{
				New-Variable -Name 'config_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_customername' -Value $cis.customername -Scope Script
			}
			try
			{
				New-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
			}
			try
			{
				New-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script
			}
			try
			{
				New-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script
			}
			try
			{
				New-Variable -Name 'config_buildingblockspath' -Value $cis.buildingblockspath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_buildingblockspath' -Value $cis.buildingblockspath -Scope Script
			}
		
			$toolstripstatuslabel1.Text = "Selected Customer: $config_customername"
		}
	}
	
}



$config_new_button_Click = {
	#TODO: Place custom script here
	$config_customername_textbox.text = "Enter Customer name here"
	$config_logfoldertarger_textbox.text = "Enter log directory used by scripting on target; Example c:\ProgramData\customername\logs"
	$config_packagefolder_textbox.text = "Enter local path where packages & scripts will be stored; Example c:\sources\"
	$config_download_folder_textbox3.Text = "Enter UNC or local path for the download Package folder. (Evergreen / Winget)"
	$config_buildingblocks_textbox3.Text = "Enter local path where Building Blocks will be stored; Example c:\BuildingBlocks\"
}

$tools_winget_search_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $true
	$tools_datagridview1.Visible = $true
	$tools_Output_textbox1.Enabled = $false
	$tools_Output_textbox1.Visible = $false
	
	
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$tools_wsearchstring = $tools_search_winget_textbox.text
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			
			$tools_datagridview1.DataSource = $table;
		}
		
	}
	
}

$tools_show_winget_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	<#
	$winget_exe = Resolve-Path "\Microsoft.DesktopAppInstaller_1.19.10173.0_x64__8wekyb3d8bbwe\winget.exe"
	if ($winget_exe.count -gt 1)
	{
		$winget_exe = $winget_exe[-1].Path
	}
	
	if (!$winget_exe)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Install winget", 'No Winget found') # Casting the method to [void] suppresses the output. 
	}
	
	#>
	$tools_winget_show_string = $tools_show_winget.text
	$tools_winget_id = winget show $tools_winget_show_string --accept-source-agreements
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
}

$tools_show_winget_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_locale_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$winget_locale_label.Enabled = $true
		$winget_locale_label.Visible = $true
		$Winget_locale_textbox.Enabled = $true
		$Winget_locale_textbox.Visible = $true
	}
	else
	{
		$winget_locale_label.Enabled = $false
		$winget_locale_label.Visible = $false
		$Winget_locale_textbox.Enabled = $false
		$Winget_locale_textbox.Visible = $false
	}
}

$Winget_locale_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_version_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$winget_version_label1.Enabled = $true
		$winget_version_label1.Visible = $true
		$winget_version_textbox1.Enabled = $true
		$winget_version_textbox1.Visible = $true
	}
	else
	{
		$winget_version_label1.Enabled = $false
		$winget_version_label1.Visible = $false
		$winget_version_textbox1.Enabled = $false
		$winget_version_textbox1.Visible = $false
	}
}

$tools_versions_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_winget_show_versions_button_Click = {
	
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_winget_show_string = $tools_versions_winget_textbox.text
	$tools_winget_id = winget show $tools_winget_show_string --versions --accept-source-agreements
	
	
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
	
}

$exe_open_sourcedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$exepnaam\$exeversie\source"
}

$msi_labelPackageName_Click = {
	#TODO: Place custom script here
	
}


$tools_search_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_search_output_button1_Click = {
	#TODO: Place custom script here
	
}

$deP_label3_Click = {
	#TODO: Place custom script here
	
}

$tools_tabpage7_Click = {
	#TODO: Place custom script here
	
}

$upload_checkboxSetupAssignmentLikeP_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllDevice_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllUsers_CheckedChanged = {
	#TODO: Place custom script here
	
}

$Upload_beschikbaar_all_users_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$weblink_ico_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$shortcut_openfiledialog1.ShowDialog()
	[string]$ICO_org_path = $shortcut_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	Copy-Item -Path $ICO_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\$weblinkName.ico" -ErrorAction Stop
	
	$weblink_output_textbox1.AppendText("*.ICO now available in source directory `r`n")
	$weblink_ico_label1.text = $shortcut_openfiledialog1.SafeFileName
	$weblink_ico_label1.Visible = $true;
	$weblink_ico_label1.Enabled = $true;
	$weblink_logo_png_button1.Visible = $true
	$weblink_logo_png_button1.Enabled = $true
	$weblink_output_textbox1.AppendText("Now upload *.png file `r`n")
	
	
	
	
}

$weblink_create_intunewin_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\" -s "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -o "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\" -q
	Rename-Item -Path "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\install.intunewin" -NewName "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkPackageName.intunewin"
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\"
	$weblink_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkName.intunewin")
	$weblink_output_textbox1.AppendText("`r`n")
	
	$weblink_output_textbox1.AppendText("Install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$weblink_output_textbox1.AppendText("un-install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$weblink_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$weblinkPackageName\"
	$regkeyApp
	$weblink_output_textbox1.AppendText("$regkeyApp `r`n")
	$weblink_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$weblink_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: $weblinkVersion `r`n")
	$weblink_output_textbox1.AppendText("Please reopen tool to make another Weblink package `r`n")
	
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$weblinkPackageName.intunewin"
			DisplayName   = $weblinkPackageName
			Publisher	  = $config_customername
			AppVersion    = $weblinkVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\config.csv" -NoTypeInformation
	$weblink_output_textbox1.AppendText("Config.csv written to: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\\config.csv")
	$weblink_output_textbox1.AppendText("  `r`n")
	$weblink_output_textbox1.AppendText("Use config file to upload package to Intune. `r`n")
	
}

$config_delete_button1_Click = {
	#TODO: Place custom script here
	
	$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$config_customerinfo = $null;
	Remove-Item "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -Confirm:$false
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -ne $config_listbox.SelectedItem)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername    = $cis.customername
					logfoldertarget = $cis.logfoldertarget
					packagefolder   = $cis.packagefolder
					downloadpath    = $cis.downloadpath
					buildingblockspath = $cis.buildingblockspath
				})
		}
		
		
	}
	
	
	
	
	
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation
	$config_listbox.Items.Clear()
	
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$weblink_logo_png_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblink_logo_openfiledialog1.ShowDialog()
	[string]$weblinkLogo_org_path = $weblink_logo_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	Copy-Item -Path $weblinkLogo_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\output\logo.png" -ErrorAction Stop
	$weblink_output_textbox1.AppendText("Logo.PNG now available in Output directory `r`n")
	$weblink_png_label1.text = $weblink_logo_openfiledialog1.SafeFileName
	$weblink_png_label1.Enabled = $true
	$weblink_png_label1.Visible = $true
	$weblink_create_scripts_button1.Enabled = $true
	$weblink_create_scripts_button1.Visible = $true
	$weblink_output_textbox1.AppendText("Click Create scripts to create install.ps1 and uninstall.ps1 `r`n")
}

$weblink_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$weblink_create_scripts_button1_Click = {
	#TODO: Place custom script here
	$weblink_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}


#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will now copy ICO file"
	Copy-Item "$Name.ico" "$logdir\ico\$Name.ico" -confirm:$false
	Write-Host "Script will now create extra folder in startmenu (when needed)"
  if (!(Test-Path -Path $location))
{
	
	New-Item -ItemType Directory -Path $location
}

	Write-Host "Script will now create shortcut"
	fCreateShortcut -TargetFile $browser -shortcutName $Name -ShortcutArguments $URL -icon "$logdir\ico\$Name.ico" -programmenu $location
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	$weblink_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Gebruik: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType Dword
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType Dword
	}
}
function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}




#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will remove ICO file and Lnk file"
	Remove-Item $logdir\ico\$Name.ico -confirm:$false
	Remove-Item $location\$Name.lnk -confirm:$false
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkICOFile = "$weblinkName.ico"
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_installFile = $weblink_installFile.Replace("!!packagename!!", $weblinkPackageName)
	$weblink_installFile = $weblink_installFile.Replace("!!Name!!", $weblinkName)
	$weblink_installFile = $weblink_installFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_installFile = $weblink_installFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_installFile = $weblink_installFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_installFile = $weblink_installFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_installFile = $weblink_installFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_installFile = $weblink_installFile.Replace("!!logdir!!", $logdir)
	$weblink_installFile = $weblink_installFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!packagename", $weblinkPackageName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Name!!", $weblinkName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!logdir!!", $logdir)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_installFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$weblink_uninstallFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1" -force
	$weblink_output_textbox1.AppendText("Install.ps1 and uninstall.ps1 created `r`n")
	$weblink_output_textbox1.AppendText("You can now test install and uninstall `r`n")
	$weblink_output_textbox1.AppendText("You can save changes in script if needed `r`n")
	$weblink_output_textbox1.AppendText("Then create Intunewin file`r`n")
	$weblink_test_install_button1.Visible = $true
	$weblink_test_install_button1.Enabled = $true
	$weblink_test_uninstall_button1.Visible = $true
	$weblink_test_uninstall_button1.Enabled = $true
	$weblink_create_intunewin_button1.Visible = $true
	$weblink_create_intunewin_button1.Enabled = $true
	
}



$weblink_create_packagedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$weblinkName = $weblink_packagename.Text
	$weblinkName = $weblinkName -replace (" ", "")
	$weblink_packagename.Text = $weblinkName
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"
	}
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"
	}
	$weblink_output_textbox1.Text = "`nNew package direcotory created: `r`n"
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkName\$weblinkVersion\")
	$weblink_output_textbox1.AppendText(" `r`n")
	$weblink_output_textbox1.AppendText("Now Upload *.ICO file `r`n")
	$weblink_ico_button1.Enabled = $true
	$weblink_ico_button1.Visible = $true
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_browser_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_location_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_url_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_Name_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$weblink_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$helpbutton1_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://github.com/rink-turksma/IntunePrepTool'
}

$winget_displayname_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_create_scripts_button1_Click = {
	#TODO: Place custom script here
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$version = $versie_textbox2.Text
		if ($version -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			$wid = $winget_WingetID_textbox1.text
			$DisplayName = $winget_displayname_textbox1.text
			$fid = $config_packagefolder
			if ($winget_locale_checkbox1.Checked -eq $true)
			{
				$wlo = $Winget_locale_textbox.text
				
			}
			else { $wlo = $null; }
			if ($winget_version_checkbox.Checked -eq $true)
			{
				$wve = $winget_version_textbox1.text
			}
			else { $wve = $null; }
			$WinGetID = $wid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			$outputDirectory = $fid
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	21-4-2025 20:44
 	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	Winget_install_uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

# Variables will be provided from IntunePrepTool
$WinGetID = "!!WinGetID!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$version = "!!version!!"
$locale = "!!locale!!"
$localeSelected = "!!localeSelected!!"
$versionWinget = "!!versionWinget!!"
$versionWingetSelected = "!!versionSelected!!"
$includeWingetRequirment = "!!includeWingetRequirment!!"
#Dyn vars
$regApp1 = $DisplayName
$logfile = $(Join-Path $logdir  "$DisplayName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null;
#Creates logdirectory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Create registry application key.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Start Powershell functions
function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution.
	### Ultimately, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $True
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functies
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}



#Start Transcript.  Will be saved under  $logdir.
Start-Transcript -Path $logfile
$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($ResolveWingetPath)
{
	$WingetPath = $ResolveWingetPath[-1].Path
	$wingetexe = $ResolveWingetPath
}
if (Test-path $WingetPath -ErrorAction SilentlyContinue)
{
	
	Write-Host "We are now checking the version of Winget"
	$wingetOption = 1
	$versionW = & $wingetexe --version
	Write-Host $versionW
}
else
{
	Write-Host "We are now checking the version of Winget"
	$wingetOption = 2
	$versionW = winget --version
	write-host $versionW
}


if ($versionW -notlike 'v*')
{
	Write-Host "Winget Version does not match.. installing now"
	[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
	$msixUrl = "https://github.com/microsoft/winget-cli/releases/download/v1.11.430/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
	$msixPath = "$($env:TEMP)\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
	(New-Object System.Net.WebClient).DownloadFile($msixUrl, $msixPath)
	
	try
	{
		Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
		Write-Host "Winget installation completed successfully."
	}
	catch
	{
		if ($_.Exception.Message -match "Microsoft.VCLibs.140.00.UWPDesktop")
		{
			Write-Host "Now downloading: Missing dependency 'Microsoft.VCLibs.140.00.UWPDesktop'."
			[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
			$dependencyURL = 'https://github.com/microsoft/winget-cli/releases/download/v1.11.430/DesktopAppInstaller_Dependencies.zip'
			$dependencyPath = "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
			(New-Object System.Net.WebClient).DownloadFile($dependencyURL, $dependencyPath)
			unblock-file "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
			Expand-Archive -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip" -DestinationPath "$($env:TEMP)\DesktopAppInstaller_Dependencies"
			write-host "Now installing dependency"
			try
			{
				Add-AppxPackage -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies\x64\Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64.appx" -ErrorAction Stop
				write-host "Installing depedency done"
			}
			catch
			{
				Write-host "Installing depedency failed"
				Write-Host "An unexpected error occurred: $($_.Exception.Message)"
			}
			try
			{
				write-host "Now trying to install Winget again"
				Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
				write-host "Install winget done"
			}
			catch
			{
				Write-Host "An unexpected error occurred: $($_.Exception.Message)"
			}
		}
		else
		{
			Write-Host "An unexpected error occurred: $($_.Exception.Message)"
		}
	}
	$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
	if ($ResolveWingetPath)
	{
		$WingetPath = $ResolveWingetPath[-1].Path
	}
	$wingetexe = $ResolveWingetPath
	
	if (Test-path $wingetexe)
	{
		
		Write-Host "We are now checking the version of Winget"
		$wingetOption = 1
		$versionW = & $wingetexe --version
		Write-Host $versionW
	}
	else
	{
		Write-Host "We are now checking the version of Winget"
		$wingetOption = 2
		$versionW = winget --version
		write-host $versionW
	}
}
else
{
	write-host "Winget already active"
}


try
{
	if ($wingetOption -eq 1)
	{
		$install = "!!WingetCommand!!"
		if ($install -like "!!doe*")
		{
			if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
			{
				& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine
				
			}
			if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
			{
				& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
				
			}
			if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
			{
				
				& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget
				
			}
			
			if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
			{
				& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
			}
			if (Test-Path 'BuildingBlocks\System')
			{
				$originalLocation = Get-Location
				Write-Host "BuildBlocks folder detected"
				
				$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
				foreach ($bb in $allBuildingBlocks)
				{
					$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
					
					if (Test-Path $bbScriptLocation -PathType Leaf)
					{
						Write-Host "Now running Building Blocks Script $bbScriptLocation"
						& $bbScriptLocation
						Set-Location $originalLocation
					}
				}
			}
			
			
		}
		else
		{
			& $wingetexe uninstall --id $WinGetID -h
			if (Test-Path 'BuildingBlocks\System')
			{
				$originalLocation = Get-Location
				Write-Host "BuildBlocks folder detected"
				
				$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
				foreach ($bb in $allBuildingBlocks)
				{
					$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
					
					if (Test-Path $bbScriptLocation -PathType Leaf)
					{
						Write-Host "Now running Building Blocks Script $bbScriptLocation"
						& $bbScriptLocation
						Set-Location $originalLocation
					}
				}
			}
		}
	}
	else
	{
		$install = "!!WingetCommand!!"
		if ($install -like "!!doe*")
		{
			if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
			{
				winget -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine
				
			}
			if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
			{
				winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
				
			}
			if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
			{
				
				winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget
				
			}
			
			if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
			{
				winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
			}
			if (Test-Path 'BuildingBlocks\System')
			{
				$originalLocation = Get-Location
				Write-Host "BuildBlocks folder detected"
				
				$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
				foreach ($bb in $allBuildingBlocks)
				{
					$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
					
					if (Test-Path $bbScriptLocation -PathType Leaf)
					{
						Write-Host "Now running Building Blocks Script $bbScriptLocation"
						& $bbScriptLocation
						Set-Location $originalLocation
					}
				}
			}
			
		}
		else
		{
			winget uninstall --id $WinGetID -h
			if (Test-Path 'BuildingBlocks\System')
			{
				$originalLocation = Get-Location
				Write-Host "BuildBlocks folder detected"
				
				$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
				foreach ($bb in $allBuildingBlocks)
				{
					$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
					
					if (Test-Path $bbScriptLocation -PathType Leaf)
					{
						Write-Host "Now running Building Blocks Script $bbScriptLocation"
						& $bbScriptLocation
						Set-Location $originalLocation
					}
				}
			}
		}
	}
}
catch
{
	
}

if ($install -like "!!doe*")
{
	try
	{
		#Searches for startmenu items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
		
	}
	try
	{
		#Searches for Desktop items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
	
}
#### Place extra actions here:







Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

if ($excode -eq 1) { $warning = 'Error'; }
else
{
	$warning = 'Information'; if ($install -like "!!doe*") { fDetectionInRegistry -succes $true }
	else
	{
		remove-item $regkeyApp
	}
}
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }



'@
			$installfile = $installfile.Replace('!!WinGetID!!', $WinGetID)
			$installfile = $installfile.Replace('!!DisplayName!!', $DisplayName)
			$installfile = $installfile.Replace('!!logdir!!', $logdir)
			$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$installfile = $installfile.Replace('!!version!!', $version)
			if ($wlo -ne $null)
			{
				$installfile = $installfile.Replace('!!locale!!', $wlo)
				$installfile = $installfile.Replace("!!localeSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!localeSelected!!", $false) }
			if ($wve -ne $null)
			{
				$installfile = $installfile.Replace('!!versionWinget!!', $wve)
				$installfile = $installfile.Replace("!!versionSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!versionSelected!!", $false) }
			$installfile = $installfile.Replace('!!includeWingetRequirment!!', $includeWingetRequirment)
			
			
			
			
			$installfile = $installfile.Replace('!!WingetCommand!!', "!!doeinstall!!")
			$installFile | Out-File "$outputDirectory\$wingetID\$version\source\install.ps1" -Force
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$wingetID\$version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
			$installFile | Out-File "$outputDirectory\$wingetID\$version\source\uninstall.ps1" -Force
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$version\source\install.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$wingetID\$version\source\uninstall.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("You can test using Powershell ISE (button in GUI) or start the creation of intunewinfile`r`n")
			$winget_test_install_button1.Enabled = $true
			$winget_test_install_button1.Visible = $true
			$winget_uninstall_test_button.Enabled = $true
			$winget_uninstall_test_button.Visible = $true
			$winget_maakPackage_button1.Enabled = $true
			$winget_maakPackage_button1.Visible = $true
			$winget_final_panel7.Enabled = $true
		}
	}
	
}

$winget_test_install_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		$voorIntall = Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs"
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	$winget_gotobuildingBlocks_buttonTestInstallPowershel.Enabled = $true
}

$winget_uninstall_test_button_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		
		powershell_ise -file "$config_packagefolder\$wingetid\$wingetversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	$winget_addBuildingBlocksCSVbuttonOptionalAddBuildingB.Enabled = $true
	
}

$winget_show_version_button1_Click = {
	#TODO: Place custom script here
	$winget_show_string = $winget_WingetID_textbox1.text
	$winget_show_versions = winget show $winget_show_string --versions --accept-source-agreements
	
	
	$winget_output_textbox3.Text = "Search results: `r`n"
	foreach ($twi in $winget_show_versions)
	{
		
		$winget_output_textbox3.AppendText("$twi `r`n")
	}
}

$wsearch_s_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$wsearch_s_button1_Click = {
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$wsearchstring = $wsearch_s_textbox1.text
	$wsearch__winget_search_output = winget search $wsearchstring --accept-source-agreements
	
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			## - Display custom data created:
			$wsearch_datagridview1.DataSource = $table;
			
			
			
			
			
			
			
		}
		
	}
	
	
	
	
}


Write-Host $wsearch_datagridview1
$wsearch_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$cunfig_folder_pacakaging_button1_Click = {
	#TODO: Place custom script here
	if ($config_packagefolder_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_packagefolder_textbox.Text = $config_packagefolder_folderbrowsermoderndialog1.SelectedPath
	}
}

$config_logfolder_target_button1_Click = {
	#TODO: Place custom script here
	if ($config_logfolder_target_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_logfoldertarger_textbox.Text = $config_logfolder_target_folderbrowsermoderndialog1.SelectedPath
	}
}

$tools_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$tools_search_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_csv_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$upload_logo_button2_Click = {
	#TODO: Place custom script here
	$upload_logo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $upload_logo_openfiledialog1.FileNames
	
	[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	
	$itwnf = $ConfigCSVImport.IntuneWinFile
	$filepath = $config_csv_path.TrimEnd("config.csv")
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$filepath\logo.png"
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	
}

$timer1_Tick = {
	#TODO: Place custom script here
	
}

$weblink_logo_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$msi_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_Empty_Scheduled_Task_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Basic template: Creates install.ps1 and uninstall.ps1. With detection method in registry for Intune. And logging to the in Config defined log target"
}

$powershell_scheduledtask_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Template scheduled task: Creates install.ps1 that creates scheduled task to run Powershell script. Uninstall.ps1 cleans up the scheduled task"
}

$powershell_package_name_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package Name (String)"
}

$powershell_package_version_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package Version (String)"
}

$powershell_create_package_dir_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Creates package directory based on the chosen package folder (Config) and Package Name & Version"
}

$powershell_open_package_directory_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Open Package\source directory; Here you can place additional files when needed."
}


$config_listbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Select a customer / tenant"
}

$config_customername_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Customer name"
}

$config_logfoldertarger_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Log folder target. Location is used for Powershell transcript logging used by the packages; Also used for MSIEXEC logging when using an MSI source"
}

$config_packagefolder_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package folder. Must be a local folder. For example: when you create a package with Package Name: 'IntunePrepTool' with Package Version '1.0.3.5', and your package folder is c:\sources\gotomars. The folder created for this package = c:\sources\gotomars\IntunePrepTool\1.0.3.5\"
}

$config_tenanturl_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Tenant url is used for the upload function"
}

$helpbutton1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Opens https://github.com/rink-turksma/IntunePrepTool in Edge; If you need more information."
}

$config_delete_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Deletes selected customer. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_new_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click here to create new customer. Click save when done. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_save_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Save to append new customer to list. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_check_updates_button1_Click = {
	#TODO: Place custom script here
	$config_check_updates = @'
winget upgrade rink-turksma.IntunePrepTool
'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetupdate.ps1" -PathType Leaf))
		{
			$config_check_updates | Out-File "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$config_check_updates_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click to open Powershell ISE; Run script to upgrade IntunePrepTool using Winget; When you get the message: 'No applicable upgrade found.' You're already up to date. "
}

$winget_WingetID_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Exact Winget ID here; You can search for the Winget ID using Tabpage Tools"
}

$winget_checkurl_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Shows download URL in Popup window for chosen WingetID"
}

$winget_show_version_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Shows available versions for chosen WingetID; Output in textbox on the right side"
}

$toolstripstatuslabel1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_package_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_displayname_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package name (string)"
}

$versie_textbox2_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package version (string)"
}

$winget_locale_checkbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "'Winget Show' (Also available in tabpage Tools) can be used to find out if the chosen package is available in other languages. Check if you want to specify Locale. Like 'en-US' ; "
}

$global_selected_customer_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$config_listbox_SelectedValueChanged = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text + $config_listbox.SelectedItem
}

$winget_version_checkbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Check checkbox to select specify version. When you don't the latest version is used."
}

$winget_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When youre test and edit the installation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_uninstall_test_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When youre test and edit the uninstallation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_maakPackage_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create Intunewin file; don't forget to upload logo after creating Intunewinfile if you wan't to use the upload option."
}

$msi_buttonOpenMSIFile_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Open *.msi file to use for this package."
}

$msi_packagenaam_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package name (string)."
}

$msi_versie_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package version (string)."
}

$msi_buttonCreatePackageDirecto_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "After selecting MSI, Package name and package version, click Create package directory; The MSI file will be copied to the generated to the package directory"
}

$msi_OpenSourceDir_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click Open source directory to open the source directory for your package.You can add extra files when needed."
}

$msi_install_par_textbox3_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "MSIEXEC install parameters here; after creating package directory, a basic install string is already visible. Edit when needed. Leave the logging options as is. "
}

$msi_button1CreateInstallScript_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click create Install script to create the install.ps1 and i.cmd file; install.ps1 will provide detection method and logging; i.cmd is just the above filled install parameters in as batch file;  "
}

$msi_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click Test install to test your installation. Powershell_ISE will read the MSIEXEC log file and will show you a possible uninstall string. That you can use for uninstall script. Also when shorcuts are created the install.ps1 will give you the option to remove it."
}

$msi_uninstall_par_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Paste the suggested uninstall string from the install.ps1 here. Then click create uninstall script"
}

$msi_button3CreateUninstallScri_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create uninstall script"
}

$msi_button4TestUninstallPowers_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Test uninstall using Powershell_ISE; You can edit the uninstall.ps1 directly. If you need to change the u.cmd file. Please click Open source directory and edit. "
}

$msi_button5CreateIntunewinFile_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create intunewin package. This can take a while, depending on the size of your package. Application (STA) will not respond during creation of Intunewin"
}

$msi_buttonUploadLogoPNG_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When you plan to use Upload function. Please chose PNG file first. Used in Company portal"
}

$winget_remediations_createscripts_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Upload not yet available for Remediations.. For now use the Intune Admin Portal")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Please reopen IntunePrepTool to create more Remediations scripts")
				
				
			}
		}
		
		
	}
	
	
	
	
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
	
	
	
}

$configToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $true
	$config_tabpage.Visible = $true
	$config_tabpage.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$wingetToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_winget_tabcontrol2.Enabled = $true
	$package_winget_tabcontrol2.Visible = $true
	$package_winget_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}
$scheduledTaskToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'Fill'
	$package_ScheduledTask_tabcontrol2.Enabled = $true
	$package_ScheduledTask_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}


$mSIXToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$MSIX_tabcontrol1.Dock = 'Fill'
	$MSIX_tabcontrol1.Enabled = $true
	$MSIX_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$mSIToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $true
	$package_msi_tabcontrol2.Visible = $true
	$package_msi_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$eXEToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $true
	$package_exe_tabcontrol2.Visible = $true
	$package_exe_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$main_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$wingetUpdateToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Dock = 'Fill'
	$Remediations_winget_tabcontrol2.Enabled = $true
	$Remediations_winget_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$weblinkToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Dock = 'Fill'
	$package_weblink_tabcontrol2.Visible = $true
	$package_weblink_tabcontrol2.Enabled = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$intunewinToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Dock = 'Fill'
	$upload_intunewin_tabcontrol2.Enabled = $true
	$upload_intunewin_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$wingetSearchShowVersionToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Enabled = $true
	$tools_winget_searchtabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$findUninstallStringsToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'Fill'
	$tools_uninstallstring_tabcontrol1.Enabled = $true
	$tools_uninstallstring_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromWingetToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $true
	$download_tabcontrol1.Visible = $true
	$download_tabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromMSStoreUsingMSStoreURLToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $true
	$download_MSSTore_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Dock = 'Fill'
	
}


$powershellToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $true
	$Powershell.Visible = $true
	$Powershell.Dock = 'Fill'
	
	
}
$updateMSIOrEXEPackageToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $true
	$updatepackage_msi_tabcontrol1.Visible = $true
	$updatepackage_msi_tabcontrol1.Dock = 'Fill'
	
}

$updateEXEPackageToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $true
	$updatepackage_exe_tabcontrol1.Visible = $true
	$updatepackage_exe_tabcontrol1.Dock = 'Fill'
	
}

$chocolateyFindToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}
$chocolateyFindToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$chocolateyToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}




$fileWizzardToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'

	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}






$Weblink_intunewin_tabpage6_Click = {
	#TODO: Place custom script here
	
}

$weblink_packagename_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$remediations_winget_maxversion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_remediations_maxversion_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	
}

$remediate_winget_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_wingetid_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$remadiations_winget_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$remediations_winget_upload_button1_Click = {
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				
				
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				
				
				
				$encoding = [System.Text.Encoding]::UTF8
				$bytes = $encoding.GetBytes($remediate_detectFile)
				$Encoded_remediate_detectFile = [Convert]::ToBase64String($bytes)
				$Bytes2 = $encoding.GetBytes($remediate_remediateFile)
				$Encoded_remediate_remediateFile = [Convert]::ToBase64String($Bytes2)
				$UploadRemediationsFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	6/5/2023 3:38 PM
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	upload.ps1
	===========================================================================
	.DESCRIPTION
		Part of IntunePrepTool
		https://github.com/rink-turksma/IntunePrepTool
		Upload Remediations to Intune
#>
	Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
	else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
	$displayName = "!!displayName!!"
	$publisher = "!!publisher!!"
	$detectionScriptContent = '!!detectionScriptContent!!'
	$remediationScriptContent = '!!remediationScriptContent!!'
	$tenantID = "!!tenantid!!"
	$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547"; $RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	$MsalToken = Get-MsalToken -TenantId $tenantID -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	$body = @"
{"displayName":"$displayName","description":"Uploaded by IntunePrepTool","publisher":"$publisher","runAs32Bit":false,"runAsAccount":"system","enforceSignatureCheck":false,"detectionScriptContent":"$detectionScriptContent","remediationScriptContent":"$remediationScriptContent","roleScopeTagIds":["0"]}
"@
	$uri = "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts"
	$createdPolicy = Invoke-RestMethod -Uri $uri -Method POST -Body $body -Headers @{ Authorization = $MsalToken.CreateAuthorizationHeader() } -ContentType 'application/json'
	Write-Host "Remediationa policy created successfully with ID: $($createdPolicy.id)" -ForegroundColor Green
	Write-Host "Please assign and schedule with MS Intune Admin console" -ForegroundColor Green
	
'@
				$displayName = $winget_remediations_name_textbox1.Text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!publisher!!", $config_customername)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!displayName!!", $displayName)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!detectionScriptContent!!", $Encoded_remediate_detectFile)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!remediationScriptContent!!", $Encoded_remediate_remediateFile)
				$tenatURL = $upload_tenantURL_textbox.text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!tenantid!!", $tenatURL)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"
				}
				$UploadRemediationsFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1" -Force
				$remadiations_winget_textbox2.AppendText("Created Upload.ps1")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("After uploading; Please go to Intune Management Portal and assign devices or users. And add a schedule")
				
				if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE now?', 'upload.ps1 created', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
				{
					
					
					
					powershell_ise -file "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
			}
		}
	}
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
}

$remediations_winget_open_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
	$remediate_winget_version = $remediate_winget_version_textbox1.Text
	Invoke-Item "$config_packagefolder\$winget_remediations_name\$remediate_winget_version"
}

$powershell_scheduledtask_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	if ($powershell_scheduledtask_radiobutton.Checked -eq $true)
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $true
		$package_scheduled_task_WingetID_textbox.Visible = $true
		$package_scheduled_task_WingetID_label3.Enabled = $true
		$package_scheduled_task_WingetID_label3.Visible = $true
		#$package_ScheduledTask_create_scripts_button1.Enabled = $true
		#$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	else
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $false
		$package_scheduled_task_WingetID_textbox.Visible = $false
		$package_scheduled_task_WingetID_label3.Enabled = $false
		$package_scheduled_task_WingetID_label3.Visible = $false
		
	}
}

$powershell_Empty_Scheduled_Task_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	#$package_ScheduledTask_create_scripts_button1.Enabled = $true
	#$package_ScheduledTask_create_scripts_button1.Visible = $true
}



$package_scheduledtasK_option_weekly_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $true
		$package_scheduledtask_weekly_day_combobox1.Visible = $true
		$package_scheduledtask_weekly_time_combobox1.Enabled = $true
		$package_scheduledtask_weekly_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $true
		
	}
	else
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $false
		$package_scheduledtask_weekly_day_combobox1.Visible = $false
		$package_scheduledtask_weekly_time_combobox1.Enabled = $false
		$package_scheduledtask_weekly_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $false
		
	}
}

$package_scheduledtask_weekly_day_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$datetimepicker1_ValueChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_winget_max_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduled_Task_maxVersion_label4_Click = {
	#TODO: Place custom script here
	
}

$powershell_create_package_dir_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		if ($powershell_package_name_textbox1.Text -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package name textbox', 'Select Package Name')
		}
		else
		{
			if ($powershell_package_version_textbox1.Text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package version textbox', 'Select Package Version')
			}
			else
			{
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
				$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
				$package_scheduledTask_name = $powershell_package_name_textbox1.Text
				$package_scheduledTask_name = $package_scheduledTask_name -replace (" ", "")
				$powershell_package_name_textbox1.Text = $package_scheduledTask_name
				$package_scheduledTask_version = $powershell_package_version_textbox1.text
				
				
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"
				}
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"
				}
				$package_ScheduledTask_output_textbox1.Text = "`nNew package direcotory created: `r`n"
				$package_ScheduledTask_output_textbox1.AppendText("$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$powershell_open_package_directory_button1.Enabled = $true
				$powershell_open_package_directory_button1.Visible = $true
				$package_scheduledtask_system_panel5.Enabled = $true
				$package_scheduledtask_system_panel5.Visible = $true
				#$package_ScheduledTask_create_scripts_button1.Enabled = $true
				#$package_ScheduledTask_create_scripts_button1.Visible = $true
				$scheduledtask_buttonOpenSourceDirectory.Enabled = $true
				$scheduledtask_buttonOpenSourceDirectory.Visible = $true
				
				
				
			}
		}
	}
}

$powershell_package_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_open_package_directory_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	Invoke-Item "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\"
}

$package_ScheduledTask_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_ScheduledTask_create_scripts_button1_Click = {
	#TODO: Place custom script here
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	if ($package_scheduledTaskWarning -eq $true)
	{
		[void][System.Windows.Forms.MessageBox]::Show('For user context select logon or on schedule first; For system context. Select at startup or on schedule option first', 'Select option first')
	}
	else
	{
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$package_scheduledTask_name = $powershell_package_name_textbox1.Text
		$package_scheduledTask_version = $powershell_package_version_textbox1.text
		#$package_scheduledtask_system_panel3.Visible = $true
		#$package_scheduledtask_system_panel3.Enabled = $true
		
		
		
		$ScheduledTaskFile = @'
<#Place code here#>











'@
		$logdir = "$config_logfoldertarget\scheduledTasks"
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!ps1name!!", "scheduledTask_$package_scheduledTask_name.ps1")
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_name!!", $package_scheduledTask_name)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_version!!", $package_scheduledTask_version)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!logdir!!", $logdir)
		$ScheduledTaskFile | Out-File  "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1" -Force -Confirm:$false -ErrorAction SilentlyContinue
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$package_ScheduledTask_output_textbox1.AppendText("Template script to be scheduled created")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Please add your Powershell code between 'Place your Powershell code here' and 'End of your Powershell script'")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Save when done")
		
		$package_scheduledTask_Edit_script_button1.Enabled = $true
		$package_scheduledTask_Edit_script_button1.Visible = $true
		$package_scheduledtasK_option_startup_checkbox1.Enabled = $true
		$package_scheduledtasK_option_startup_checkbox1.Visible = $true
		$package_scheduledtasK_option_weekly_checkbox1.Enabled = $true
		$package_scheduledtasK_option_weekly_checkbox1.Visible = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Enabled = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Visible = $true
	}
	
}



$package_scheduledTask_Edit_script_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Powershell_ISE will open now. Please place powershell code between "Place your Powershell code here" and "End of your Powershell script"; Save when done', 'Powershell_ISE') # Casting the method to [void] suppresses the output. 
	
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	
	
	
}

$package_scheduledtasK_option_startup_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_createIntunewin_scripts_button1_Click = {
	#TODO: Place custom script here
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	
	
	$package_scheduledTask_Edit_script_test_install_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_install_button1.Visible = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Enabled = $true
	
	
	$ScheduledTaskInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	6-10-2024 17:54
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$systemContext = "!!systemContext!!"
$onSchedule = "!!onSchedule!!"
$StartupTask = "!!StartupTask!!"
$logonTask = "!!LogonTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!"
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$DailyTask = "!!DailyTask!!"
$DailyTaskHour = "!!DailyTaskHour!!"
$DailyTaskAMPM = "!!DailyTaskAMPM!!"

$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $version) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
if (test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force }
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
copy-item $psFile -Destination "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force

#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
# BEGIN: 3d5f4a6gch7
#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
$Acl = Get-Acl "$logdir\scheduledTasks"
$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators", "Modify", "Allow")
$System = New-Object System.Security.Principal.NTAccount("SYSTEM")
$Ar2 = New-Object System.Security.AccessControl.FileSystemAccessRule($System, "Modify", "Allow")
$Acl.SetAccessRule($Ar)
$Acl.SetAccessRule($Ar2)
Set-Acl "$logdir\scheduledTasks" $Acl
# END: 3d5f4a6gch7

try
{
	
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	# Creates the scheduled task
	
	
	$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -executionpolicy bypass -Command `"& '$logdir\scheduledTasks\scheduledTask_$appName.ps1'`""
	if ($logonTask -eq $true)
	{
		$trigger0 = New-ScheduledTaskTrigger -AtLogOn
	}
	else
	{
		$trigger0 = $null
	}
	
	if ($StartupTask -eq $true)
	{
		$trigger1 = New-ScheduledTaskTrigger -AtStartup -RandomDelay 00:00:30
	}
	else
	{
		$trigger1 = $null
	}
	if ($WeeklyTask -eq $true)
	{
		$trigger2 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $WeeklyTaskDay -At $WeeklyTaskHour$WeeklyTaskAMPM
	}
	else
	{
		$trigger2 = $null
	}
	if ($DailyTask -eq $true)
	{
		$trigger3 = New-ScheduledTaskTrigger -Daily -At $DailyTaskHour$DailyTaskAMPM
	}
	else
	{
		$trigger3 = $null
	}
	$triggers = @()
	if ($trigger0 -ne $null)
	{
		$triggers += $trigger0
	}
	if ($trigger1 -ne $null)
	{
		$triggers += $trigger1
	}
	if ($trigger2 -ne $null)
	{
		$triggers += $trigger2
	}
	if ($trigger3 -ne $null)
	{
		$triggers += $trigger3
	}
	
	if ($systemContext -eq $true)
	{
		$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	}
	else
	{
		$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -RunLevel Limited
	}
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	Register-ScheduledTask -Action $action -Trigger $triggers -Principal $principal -TaskName $appName -Settings $settings -Description "Scheduled Task for $appName" -Force -ErrorAction Stop
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	
	$excode = 0;
	
}
catch
{
	write-host "Error creating scheduled task" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error'; }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	
	$ScheduledTaskUnInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the deletion of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will delete the powershell script used by the task" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 


try
{
	# Script deletes the scheduled task here
	write-host "Script will delete the scheduled task" -ForegroundColor Green
	Unregister-ScheduledTask -TaskName $appName -Confirm:$false -ErrorAction Stop
	write-host "Scheduled Task deleted" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error with deleting scheduled task" -ForegroundColor Yellow
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
remove-item $regKeyApp -Confirm:$false -force }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$RegisterDetectionroot = "Intune_" + $config_customername
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Weekly or at startup', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				Write-Host "Eerste stap"
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			Write-Host "Check"
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $true)
			
			if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $false)
			}
			
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			Write-Host "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
			
		}
		
		
		
		
	}
	
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Select At logon or at schedule', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $true)
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $false)
			}
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
		}
	}
	
}

$windowsFirewallToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$config_InstallRequriedPSmodules_Click = {
	#TODO: Place custom script here
	$config_install_required_ps_modules = @'

<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	17-5-2024 15:24
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	InstallRequiredPowershellModules.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$problemPSModule = $null;;
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = $null;
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = $null;
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = $null
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if ($problemPSModule -eq 1)
{
	#Nuget installation
	$nugetUrl = "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
	$nugetInstallPath = "$env:ProgramFiles\NuGet"
	if (-not (Test-Path -Path $nugetInstallPath))
	{
		New-Item -ItemType Directory -Path $nugetInstallPath -Force
	}
	$nugetExePath = Join-Path -Path $nugetInstallPath -ChildPath "nuget.exe"
	Invoke-WebRequest -Uri $nugetUrl -OutFile $nugetExePath
	if (Test-Path -Path $nugetExePath)
	{
		Write-Host "NuGet has been installed successfully at $nugetExePath"
	}
	else
	{
		Write-Host "NuGet installation failed"
	}
	$path = [Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
	if ($path -notlike "*$nugetInstallPath*")
	{
		[Environment]::SetEnvironmentVariable("Path", "$path;$nugetInstallPath", [System.EnvironmentVariableTarget]::Machine)
		Write-Host "NuGet has been added to the system PATH"
	}
	else
	{
		Write-Host "NuGet is already in the system PATH"
	}
	& $nugetExePath | Select-String "NuGet Version"
	
	
	Get-PackageProvider -Name Nuget -Force
	
	#Installation Powershell Modules
	Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name IntuneWin32App)
	{
		$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
		
		if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
		{
			Write-Host "IntuneWin32App 1.4.4 already installed"
		}
		else
		{
			Write-Host "Required Version not found.. Now installing"
			Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Authentication 2.27.0 already installed"
		}
		else
		{
			Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Applications 2.27.0 already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name CredentialManager)
	{
		$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
		{
			Write-Host "CredentialManager 2.0.0 Powershell module already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Identity.SignIns 2.27.0 Powershell Module already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	"true" | Out-File 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Force -Confirm:$false
	
}
else
{
	write-host "Powershell Modules already installed!"
	"true" | Out-File 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Force -Confirm:$false
}


'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -PathType Leaf))
		{
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -Confirm:$false -Force
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$downloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$wingetToolStripMenuItem1_Click = {
	#TODO: Place custom script here
	
}

$config_download_folder_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_downloadFolderBrowse_Click = {
	#TODO: Place custom script here
	if ($config_download_folderbrowsermoderndialog2.ShowDialog() -eq 'OK')
	{
		$config_download_folder_textbox3.Text = $config_download_folderbrowsermoderndialog2.SelectedPath
	}
}

$download_winget_tab_Click = {
	#TODO: Place custom script here
	
}

$download_winget_search_button1_Click = {
	
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
	
	
}

$download_winget_search_textbox5_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$download_winget_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_version_listbox1.Items.Clear()
	
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	
	
	foreach ($wsearch_55 in $downloadwingetsearchversionselected)
	{
		
		
		if (($wsearch_55 -notlike "Found*") -and ($wsearch_55 -notlike "*-*") -and ($wsearch_55 -notlike "*Version*") -and ($wsearch_55 -notlike $null) -and ($wsearch_55 -notlike "* *"))
		{
			
			$download_winget_version_listbox1.Items.Add($wsearch_55)
			
			
		}
		
	}
	
	
	
	
}

$download_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	#Write-Host $download_datagridview1.SelectedRows.Item.ToString()
}

$download_winget_version_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_download_and_add_button1.Visible = $true
	$download_winget_download_and_add_button1.Enabled = $true
}

$download_winget_download_and_add_button1_Click = {
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	$download_winget_explorer_button1.Enabled = $true
	$download_winget_explorer_button1.Visible = $true
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	if (!(Test-Path -Path $download_winget_path))
	{
		
		New-Item -ItemType Directory -Path $download_winget_path
	}
	#$downloadWingetToLib = winget download --download-directory $download_winget_path --id $winget_download_selected_id --accept-package-agreements --accept-source-agreements
	
	#$download_winget_output_textbox3.Text = $downloadWingetToLib
	#$config_downloadpath
	#Write-Host $download_winget_version_listbox1.SelectedItem
	$download_winget_selectedversion = $download_winget_version_listbox1.SelectedItem
	$download_winget_package = @'
winget download --download-directory '!!@download_winget_path@!!' --id !!@winget_download_selected_id@!! --accept-package-agreements --accept-source-agreements --version !!@download_winget_selectedversion@!!
'@
	$download_winget_package = $download_winget_package.Replace("!!@winget_download_selected_id@!!", $winget_download_selected_id)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_selectedversion@!!", $download_winget_selectedversion)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_path@!!", $download_winget_path)
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -PathType Leaf))
		{
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -Confirm:$false -Force
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		
		powershell_ise 'C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1'
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}


$download_winget_explorer_button1_Click = {
	#TODO: Place custom script here
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	explorer $download_winget_path
}

$config_help_button1_Click = {
	#TODO: Place custom script here
	
}

$config_exit_help_button1_Click = {
	#TODO: Place custom script here
	
}

$exe_maak_uninstall_script_button1_Click = {
	#TODO: Place custom script here
	$exe_maak_intuneWIN_button1.Enabled = $true
	$exe_maak_intuneWIN_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	
	$exe_uninstallFile = @'
<#	
    .NOTES
    ===========================================================================
     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
     Created on:   	21-5-2023 18:04
     Created by:   	Rink Turksma
     Organization: 	
     Filename:     	uninstall.ps1
    ===========================================================================
    .DESCRIPTION
        Parameters will be filled by IntunePrepTool.
#>
#App Parameters
$appName = "!!AppName!!"
$version = "!!version!!"
$exeFile = "!!EXEFile!!"
$exeParameters = "!!EXEPARMS!!" ##Check EXE PARAMETERS.. 
#Customer variables
$logDir = "!!logdir!!"
$registerDetectionRoot = "!!RegisterDetectionroot!!"
#Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
#Create log directory in programdata if it does not exist.
if (!(Test-Path -Path $logDir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
    New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application Key in the Registry Root.
if (!(Test-Path -Path $regkeyApp))
{
    New-Item $regkeyApp -ItemType Key -Force | out-null
}



function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution..
	### Eventually you will have, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  
#The code you provided is a comment in PowerShell. It indicates that the following code block is related to a transcript that will be saved in a text file under the $logdir directory and will also be available in the event viewer.
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $EXEFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Uninstall completed" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
    write-host "Error executing $EXEbestand" -ForegroundColor Yellow
	Write-Host "Uinstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:





<#----Below is the end of the installation script---#>
#Now the Transcript logging is started
Stop-Transcript
#After this command, the log is automatically saved in the $logdir location
#Here is a way to split the log so that we only have the last run.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
    $lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try / catch block in the execution, we set $excode to 0 or 1
# Based on this, the Log in the Event viewer is set to Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful application message or an unsuccessful one.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$MSIPARSInput = '"' + $exe_msiexecuninstall.Text + '"'
		
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
		
		try
		{
			$exepnaam = $exe_packagenaam_textbox1.text
			$exeversie = $exe_versie_textbox1.text
			$outputDirectory = $config_packagefolder
			$jjmsii = $exe_msiexecuninstall.text
			
			$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
			$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
			$exe_output_textbox1.AppendText("`nu.cmd created `r`n")
			$exe_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
			
			
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
		}
		
		
	}
	else
	{
		
		if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
		{
			$EXEbestand = $exe_uninstall_exe_path_textbox2.Text
			
		}
		else
		{
			$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		}
		
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		#$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$EXEPARSInput = $exe_parsUnInstall_textbox1.Text
		
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!AppName!!"', $appnaam)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!logdir!!', $logdir)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!version!!', $versie)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEFile!!"', $EXEbestand)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEPARMS!!"', $EXEPARSInput)
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		try
		{
			$exe_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUbinstall.ps1 NOT created `r`n")
		}
	}
}

$exe_radiobutton3_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_msiexecuninstall_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_search_button1_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_uninstallstring_search_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$buttonSearch32Bit_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}




$package_scheduledTask_Edit_script_test_install_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $powershell_package_name_textbox1.Text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$package_ScheduledTask_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$package_ScheduledTask_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$package_ScheduledTask_output_textbox1.AppendText("`r`n")
	
	$package_ScheduledTask_output_textbox1.AppendText("Install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("un-install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$package_ScheduledTask_output_textbox1.AppendText("$regkeyApp `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Please reopen tool to make another Intunewin package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$package_ScheduledTask_output_textbox1.AppendText("Config.csv written to: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$package_ScheduledTask_output_textbox1.AppendText("  `r`n")
	$package_scheduledTask_Edit_script_UploadLogo_button1.Enabled = $true
	$package_scheduledTask_Edit_script_UploadLogo_button1.Visible = $true
	$package_ScheduledTask_output_textbox1.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
}

$package_scheduledTask_Edit_script_UploadLogo_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$exepnaam = $powershell_package_name_textbox1.text
	$exeversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$exe_output_textbox1.AppendText("`r`n")
	$exe_output_textbox1.AppendText("Logo.PNG now available in Output Directory`r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if ([System.Windows.Forms.MessageBox]::Show("Click yes to open the upload screen. Then load the $outputDirectory\$exepnaam\$exeversie\output\config.csv file there", 'Upload Now?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$package_ScheduledTask_tabcontrol2.Enabled = $false
		$package_ScheduledTask_tabcontrol2.Visible = $false
		
		
		$upload_intunewin_tabcontrol2.Enabled = $true
		$upload_intunewin_tabcontrol2.Visible = $true
		$upload_intunewin_tabcontrol2.Dock = 'Fill'
	}
	
}

$reloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}


$reopenIntunePrepToolToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	& "C:\Program Files\IntunePrepTool\IntunePrepTool.exe"
'@
	if (Test-Path "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1")
	{
		powershell.exe -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
	else
	{
		$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1" -Confirm:$false -Force
		Start-Sleep 1
		powershell -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
}

$buttonUser_folder_showInfo_Click = {
	#TODO: Place custom script here
	#$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547";
	#$RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	#$MsalToken = Get-MsalToken -TenantId 'CSNTestRink.onmicrosoft.com' -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	#$webbrowser1
}

$package_scheduledtask_usercontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		#$package_scheduledTask_systemcontext.Checked = $false
		
		$package_scheduledTask_systemcontext.Enabled = $true
		$package_scheduledTask_systemcontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $true
		$package_scheduledtask_user_panel4.Visible = $true
		$package_scheduledtask_system_panel3.Enabled = $false
		$package_scheduledtask_system_panel3.Visible = $false
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
	}
	
}

$Package_scheduledtask_User_atlogon_checkbox_logon_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledTask_systemcontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		#$package_scheduledtask_usercontext.Checked = $false
		$package_scheduledtask_usercontext.Enabled = $true
		$package_scheduledtask_usercontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $false
		$package_scheduledtask_user_panel4.Visible = $false
		$package_scheduledtask_system_panel3.Enabled = $true
		$package_scheduledtask_system_panel3.Visible = $true
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	
}

$package_scheduledtask_system_panel3_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$package_scheduledtasK_user_schedule_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
		
	}
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false)
	{
		if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
}

$package_scheduledtasK_system_onschedule_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
	}
	if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
	{
		if ($package_scheduledtasK_user_schedule_checkbox.checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
	
	
}

$config_app_refresh_button1_Click = {
	#TODO: Place custom script here
	
}

$config_treeview3_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$customPrivacyURL = $custinfo.customPrivacyURL
				$config_tenant_info_CustomPrivacyURL_textbox3.Text = $customPrivacyURL
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
}

$addTenantToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $false
	$config_tenant_info_panel4.Visible = $false
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
	
	
	
	
}

$config_tenant_add_menustrip2_ItemClicked = [System.Windows.Forms.ToolStripItemClickedEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$config_app_regg_add_tenant_button2_Click = {
	#TODO: Place custom script here
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
}

$treeview2_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$config_tenant_add_button2_Click = {
	#TODO: Place custom script here
	
	$tenantName = $config_tenant_name_textbox3.Text
	$tenantName  = $tenantName -replace (" ", "")
	
	$appRegName = $config_tenant_appRegName_textbox3.Text
	$appRegName = $appRegName -replace (" ", "")
	if ($config_tenant_checkboxYes.Checked -eq $true)
	{
		$customPrivacyURL = $config_tenant_customprivacy_textbox3.text
	}
	else
	{
		$customPrivacyURL = $null
	}
	
	Set-Location $PSScriptRoot
	
	if ([System.Windows.Forms.MessageBox]::Show('Please logon to the tenant with Global Admin rights. App registration will be added. Please wait a few seconds!', 'Logon to tenant', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		if ($config_add_Tenant_radiobutton1.Checked -eq $true)
		{
			& "C:\Program Files\IntunePrepTool\AddAppReg.exe" -appRegName $appRegName -customername $tenantName
		}
		if ($config_add_Tenant_radiobutton2.Checked -eq $true)
		{
			& "C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe" -appRegName $appRegName -customername $tenantName -customPrivacyURL $customPrivacyURL
		}
		if (($config_add_Tenant_radiobutton2.Checked -eq $false) -and ($config_add_Tenant_radiobutton1.Checked -eq $false))
		{
			([System.Windows.Forms.MessageBox]::Show('Please select Windows Credential Manager or Plain Text mode', 'Please select savingmode first', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		}
		refreshTenants
		refreshTenantsUpload
		
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('All Done.', 'Customer added') # Casting the method to [void] suppresses the output. 
		
		
	}
	
	
	
}

$config_tenant_name_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_tenant_appRegName_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$tenanturl_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduledtasK_option_Daily_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $true
		$package_scheduledtask_daily_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $true
	}
	else
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $false
		$package_scheduledtask_daily_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $false
	}
	
	
	
	
}

$package_scheduledtask_daily_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$infoToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
	
	
	
}

$labelTenantName_Click = {
	#TODO: Place custom script here
	
}



$removeToolStripMenuItem_Click = {
	
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$config_tenant_info_secret_show_button2_Click = {
	#TODO: Place custom script here
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_secret_textbox3.Text = $checkCred.Password
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_secret_textbox3.Text = $custinfo.clientsecret
			}
		}
		
	}
}


$msix_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	if ($msixpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msixversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\output"
			}
			$msix_output_textbox3.Text = "`nNew package direcotory created: `r`n"
			$msix_output_textbox3.AppendText("$outputDirectory\$msixpnaam\$msixversie\source")
			$msix_output_textbox3.AppendText("`r`n")
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
				$msix_buttonOpenSourceDirectory.Enabled = $true
				$msix_buttonOpenSourceDirectory.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			
			
			
			
		}
	}
}

$msix_packagename_textbox3_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # 
}

$msix_packageVersion_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_download_winget_MSIX_bundle_Click = {
	#TODO: Place custom script here
	$config_install_required_winget= @'
# Resolve Winget path
$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($ResolveWingetPath) {
    $WingetPath = $ResolveWingetPath[-1].Path
}
$wingetexe = $ResolveWingetPath

# Check Winget version
if (Test-path $wingetexe) {
    Write-Host "We are now checking the version of Winget"
    $wingetOption = 1
    $version = & $wingetexe --version
    Write-Host $version
} else {
    Write-Host "We are now checking the version of Winget"
    $wingetOption = 2
    $version = winget --version
    Write-Host $version
}

# Install Winget if needed
if ($version -notlike 'v1.11.430') {
    Write-Host "Winget Version does not match.. installing now"
    [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
    $msixUrl  = "https://github.com/microsoft/winget-cli/releases/download/v1.11.430/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    $msixPath = "$($env:TEMP)\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    (New-Object System.Net.WebClient).DownloadFile($msixUrl, $msixPath)

    try {
        Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
        Write-Host "Winget installation completed successfully."
    } catch {
        if ($_.Exception.Message -match "Microsoft.VCLibs.140.00.UWPDesktop") {
            Write-Host "Now downloading: Missing dependency 'Microsoft.VCLibs.140.00.UWPDesktop'."
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            $dependencyURL = 'https://github.com/microsoft/winget-cli/releases/download/v1.11.430/DesktopAppInstaller_Dependencies.zip'
            $dependencyPath =  "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
            (New-Object System.Net.WebClient).DownloadFile($dependencyURL, $dependencyPath)
            unblock-file "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
            Expand-Archive -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip" -DestinationPath "$($env:TEMP)\DesktopAppInstaller_Dependencies"
            write-host "Now installing dependency"
            try {
            Add-AppxPackage -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies\x64\Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64.appx" -ErrorAction Stop
            write-host "Installing depedency done"
            }
            catch {
            Write-host "Installing depedency failed"
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
            }
            try {
            write-host "Now trying to install Winget again"
            Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
            write-host "Install winget done" 
            }
            catch {
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
            }
        } else {
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
        }
    }

    # Re-check Winget version after attempted install
    $ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
    if ($ResolveWingetPath) {
        $WingetPath = $ResolveWingetPath[-1].Path
    }
    $wingetexe = $ResolveWingetPath

    if (Test-path $wingetexe) {
        Write-Host "Re-checking Winget version..."
        $version = & $wingetexe --version
        Write-Host $version
    } else {
        Write-Host "Winget executable could not be found after installation attempt."
    }
} else {
    Write-Host "Winget is up to date."
}


'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installWinget.ps1" -PathType Leaf))
		{
			$config_install_required_winget | Out-File "C:\Program Files\IntunePrepTool\installWinget.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installWinget.ps1" -Confirm:$false -Force
			$config_install_required_winget | Out-File "C:\Program Files\IntunePrepTool\installWinget.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installWinget.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
	
	
	
	
	
	#Start-Process -FilePath "C:\Program Files\IntunePrepTool\MicrosoftDesktopApp.exe" -WindowStyle Normal
}

$MSIX_open_MSIX_button2_Click = {
	#TODO: Place custom script here
	$MSIX_openfiledialog1.ShowDialog()
	$msix_label4.Text = $msix_openfiledialog1.SafeFileName
	$msix_label4.Visible = $true;
	
}

$MSIX_CreateScripts_button2_Click = {
	
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		write-host "Package installed!"
		$excode = 0
	}
	else
	{
      	$MSIXName = $MSIXFile.Replace(".msixbundle", "")
        $PackageFullName = (Get-AppxPackage | where { $_.PackageFamilyName -like "*$MSIXName*" } | Select PackageFullName).PackageFullName
		Remove-AppxPackage -Package $PackageFullName -AllUsers -ErrorAction Stop
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}

if ($install -like "!!doe*")
{
	try
	{
		# Searches for start menu items created in the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startmenuItems)
		{
			Write-Host "`r`n"
			Write-Host "A start menu *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$startmenuI`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	} catch {
		Write-Host "Error looking for *.lnk files in start menu" -ForegroundColor Yellow
	}

	try {
		# Searches for Desktop items created in the last 10 minutes
		$desktopItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($desktopItem in $desktopItems) {
			Write-Host "`r`n"
			Write-Host "A Desktop *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$desktopItem`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	}
	catch
	{
		Write-Host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
		Write-Host "`r`n"
		Write-Host "Latest installed PackageFullName is:" -ForegroundColor Yellow
		$lastInstalledPackage = Get-AppxPackage | Sort-Object { $_.InstallDate } -Descending | Select-Object -Last 1
        #$lastInstalledPackage | Format-List
        $packageFullName = $lastInstalledPackage.PackageFullName
		Write-Host "$packageFullName" -ForegroundColor Green


}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -Force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$msixpnaam\$msixversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	#$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	#$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test install using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_install_button.Enabled = $true
	$MSIX_test_install_button.Visible = $true
	#$MSIX_test_uninstall_button.Enabled = $true
	#$MSIX_test_uninstall_button.Visible = $true
	#$MSIX_Create_Package.Enabled = $true
	#$MSIX_Create_Package.Visible = $true
	$MSIX_packageFullName_textbox3.Enabled = $true
	$MSIX_packageFullName_textbox3.Visible = $true
	$MSIX_create_uninstall_Script_button2.Enabled = $true
	$MSIX_create_uninstall_Script_button2.Visible = $true
	$msix_fullPackageName_label5.Enabled = $true
	$msix_fullPackageName_label5.Visible = $true
	
	
	
	
}

$msix_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	Invoke-Item "$config_packagefolder\$msixpnaam\$msixversie\source\"
}

$MSIX_test_install_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msix_GotoBuildingBlocks_Button.Enabled = $true
	}
}

$MSIX_test_uninstall_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msix_addBuildingBlokcsCSV_buttonOptionalAddBuildingB.Enabled = $true
	}
}

$MSIX_create_uninstall_Script_button2_Click = {
	#TODO: Place custom script here
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$PackageFullName = "!!PackageFullName!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		$excode = 0
	}
	else
	{
		Get-AppxProvisionedPackage -Online | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxProvisionedPackage -Online -ErrorAction Stop
		Get-AppxPackage -AllUsers | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxPackage -AllUsers -ErrorAction Stop
		write-host "Uninstall of $PackageFullName completed" -ForegroundColor Green
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$packageFullName = $MSIX_packageFullName_textbox3.Text
	$installfile = $installfile.Replace('!!PackageFullName!!', $packageFullName)
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test uninstall using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_uninstall_button.Enabled = $true
	$MSIX_test_uninstall_button.Visible = $true
	$MSIX_Create_Package.Enabled = $true
	$MSIX_Create_Package.Visible = $true
}

$download_winget_Search_store_Button_Click = {
	#TODO: Place custom script here
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
}

$Download_MSSTORE_download_button_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_MSStore_path = "$config_downloadpath\MSStore"
	$MSDownloadLink = $Download_MSSTORE_textbox3.Text
	$MSDownloadLink = $MSDownloadLink.Replace(" ", "")
	if (!(Test-Path -Path $download_MSStore_path))
	{
		
		New-Item -ItemType Directory -Path $download_MSStore_path
	}
	$download_MSSTore_package = @'
# Using: https://github.com/maxbakhub/winposh/blob/main/WindowsDesktopManagement/Download-AppxPackage.ps1
# Found on:
# https://woshub.com/how-to-download-appx-installation-file-for-any-windows-store-app/

function Download-AppxPackage {
[CmdletBinding()]
param (
  [string]$Uri,
  [string]$Path = "."
)
   
  process {
    $Path = (Resolve-Path $Path).Path
    #Get Urls to download
    $WebResponse = Invoke-WebRequest -UseBasicParsing -Method 'POST' -Uri 'https://store.rg-adguard.net/api/GetFiles' -Body "type=url&url=$Uri&ring=Retail" -ContentType 'application/x-www-form-urlencoded'
    $LinksMatch = $WebResponse.Links | where {$_ -like '*.appx*' -or $_ -like '*.appxbundle*' -or $_ -like '*.msix*' -or $_ -like '*.msixbundle*'} | where {$_ -like '*_neutral_*' -or $_ -like "*_"+$env:PROCESSOR_ARCHITECTURE.Replace("AMD","X").Replace("IA","X")+"_*"} | Select-String -Pattern '(?<=a href=").+(?=" r)'
    $DownloadLinks = $LinksMatch.matches.value 

    function Resolve-NameConflict{
    #Accepts Path to a FILE and changes it so there are no name conflicts
    param(
    [string]$Path
    )
        $newPath = $Path
        if(Test-Path $Path){
            $i = 0;
            $item = (Get-Item $Path)
            while(Test-Path $newPath){
                $i += 1;
                $newPath = Join-Path $item.DirectoryName ($item.BaseName+"($i)"+$item.Extension)
            }
        }
        return $newPath
    }
    #Download Urls
    foreach($url in $DownloadLinks){
        $FileRequest = Invoke-WebRequest -Uri $url -UseBasicParsing #-Method Head
        $FileName = ($FileRequest.Headers["Content-Disposition"] | Select-String -Pattern  '(?<=filename=).+').matches.value
        $FilePath = Join-Path $Path $FileName; $FilePath = Resolve-NameConflict($FilePath)
        [System.IO.File]::WriteAllBytes($FilePath, $FileRequest.content)
        echo $FilePath
    }
  }
}

Download-AppxPackage "!!MSStoreLink!!" "!!DLPath!!"
'@
	
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!MSStoreLink!!", "$MSDownloadLink")
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!DLPath!!", "$download_MSStore_path")
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -PathType Leaf))
		{
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -Confirm:$false -Force
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		
		powershell_ise "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		PowershellISEOnTop
	}
	
}


$MSIX_TIP_button2_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://store.rg-adguard.net/'
}

$MSIX_Create_Package_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msix_output_textbox3.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$msixpnaam\$msixversie\source\" -s "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -o "$config_packagefolder\$msixpnaam\$msixversie\output\" -q
	Rename-Item -Path "$config_packagefolder\$msixpnaam\$msixversie\output\install.intunewin" -NewName "$config_packagefolder\$msixpnaam\$msixversie\output\$msixpnaam.intunewin"
	$msix_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msipnaam\$msixversie\output\$msixpnaam.intunewin")
	$msix_output_textbox3.AppendText("`r`n")
	
	$msix_output_textbox3.AppendText("Install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msix_output_textbox3.AppendText("un-install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msix_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msixpnaam\"
	$regkeyApp
	$msix_output_textbox3.AppendText("$regkeyApp `r`n")
	$msix_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$msix_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: $msixversie `r`n")
	$msix_output_textbox3.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$msixpnaam.intunewin"
			DisplayName   = $msixpnaam
			Publisher	  = $config_customername
			AppVersion    = $msixversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$msixpnaam\$msixversie\output\"
	$msix_output_textbox3.AppendText("Config.csv written to: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\output\config.csv")
	$msix_output_textbox3.AppendText("  `r`n")
	$MSIX_UploadLogo_button.Enabled = $true
	$MSIX_UploadLogo_button.Visible = $true
	$msix_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$msix_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $msix_buildingblocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$msixpnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$exe_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$exe_output_textbox1.AppendText("$config_buildingblockspath\$msixpnaam\BuildingBlocks.csv `r`n")
		$exe_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
}

$MSIX_UploadLogo_button_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$msixpnaam\$msixversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$powershell_open_install_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_install_OpenFIledialog1.ShowDialog()
	$powershell_install_Script_label5.Text = $Powershell_install_OpenFIledialog1.SafeFileName
	$powershell_install_Script_label5.Visible = $true;
	
	
}

$powershell_open_uninstall_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_uninstall_OpenFIledialog1.ShowDialog()
	$powershell_uninstall_Script_label5.Text = $Powershell_uninstall_OpenFIledialog1.SafeFileName
	$powershell_uninstall_Script_label5.Visible = $true;
}

$powershell_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellpnaam = $powershellpnaam -replace (" ", "")
	$powershell_packagename_textbox.text = $powershellpnaam
	$powershellversie = $powershell_packageversion_textbox.Text
	
	if ($powershellpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($powershellversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
			}
			$powershell_output_textbox5.Text = "`nNew package direcotory created: `r`n"
			$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("Now select Powershell script for install and uninstall first")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("when needed, Add extra files in Package directory by using the 'Open: Source Directory' button")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_panel4.Enabled = $true
			$powershell_panel4.Visible = $true
			$powershell_opensource_button2.Enabled = $true
			$powershell_opensource_button2.Visible = $true
			<#
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			#>
			
			
			
		}
	}
}

$powershell_generateNEWPS_ps_button2_Click = {
	#TODO: Place custom script here
	if (($powershell_install_Script_label5.text -like "label5") -or ($powershell_uninstall_Script_label5.text -like "label5"))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Use button to select script', 'Please select install and / or uninstall source script first!')
	}
	else
	{
		if (($powershell_radiobutton2.Checked -eq $false) -and ($powershell_radiobutton1.Checked -eq $false))
		{
			[void][System.Windows.Forms.MessageBox]::Show('Select user or system context first', 'Please select user or system context first')
		}
		else
		{
			
			$powershell_output_textbox5.AppendText("`Generating install and uninstall powershell scripts...`r`n")
			
			$powershelll_user_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1  }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
			$powershelll_user_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1  }
else { remove-item $regkeyApp; exit 0 }
'@
			
if ($powershell_radiobutton2.Checked -eq $true)
	{
	$powershelll_installFile = $powershelll_user_installFile
	$powershell_uninstallFile = $powershelll_user_uninstallFile
	}
	if ($powershell_radiobutton1.Checked -eq $true) {
	$powershelll_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
			$powershell_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
				
			}
			
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
			$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
			$powershellpnaam = $powershell_packagename_textbox.text
			$powershellversie = $powershell_packageversion_textbox.Text
			$fid = $config_packagefolder; $outputDirectory = $fid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			[string]$powershell_install_org_path = $Powershell_install_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_install_org_path -Confirm:$false
			$powershellInputInstall = Get-Content -Path $powershell_install_org_path
			#Write-Host $powershellInputInstall
		
			$powershelll_installFile = $powershelll_installFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershelll_installFile = $powershelll_installFile.Replace('!!logdir!!', $logdir)
			$powershelll_installFile = $powershelll_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershelll_installFile = $powershelll_installFile.Replace('!!versie!!', $powershellversie)
			$powershelll_installFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			$powershelll_installFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			foreach ($line in $powershelll_installFile)
			{
				if ($line -like "#PowershellInstallStart*")
				{
					
					foreach ($inputLine in $powershellInputInstall)
					{
						
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
				}
				
				
			}
				
			
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$powershellpnaam\$powershellversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			
			
			
			
			
			
			[string]$powershell_uninstall_org_path = $Powershell_uninstall_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_UNinstall_org_path -Confirm:$false
			$powershellInputUNInstall = Get-Content -Path $powershell_UNinstall_org_path
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!logdir!!', $logdir)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!versie!!', $powershellversie)
			$powershell_uninstallFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			$powershell_uninstallFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			foreach ($line in $powershell_uninstallFile)
			{
				if ($line -like '#PowershellUninstallStart*')
				{
					
					foreach ($inputLine in $powershellInputUNInstall)
					{
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
				}
				
				
			}
			$powershell_output_textbox5.AppendText("`New install.ps1 and uninstall.ps1 created!`r`n")
			$powershell_output_textbox5.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
			$Powershell_testUnInstall_button2.Enabled = $true
			$Powershell_testUnInstall_button2.Visible = $true
			$Powershell_testInstall_button2.Enabled = $true
			$Powershell_testInstall_button2.Visible = $true
			$Powershell_CreateIntuneWIn_button2.Enabled = $true
			$Powershell_CreateIntuneWIn_button2.Visible = $true
			
		}
	}

}

$powershell_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	Invoke-Item "$config_packagefolder\$powershellpnaam\$powershellversie\source\"
}

$powershell_install_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_uninstall_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_packagename_textbox_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$Powershell_testInstall_button2_Click = {
	#TODO: Place custom script here
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$usercontext = 'In User context'
		$sysemcontext = $null;
		
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$usercontext = 'in Sytem context'
		$sysemcontext = 'Testing Sytem context as Elevated user;'
	}
	if ([System.Windows.Forms.MessageBox]::Show("Please test your script. After editing. Please use the save button in Powershell_ISE", "Openening Powershell_ISE in $32or64", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.Text
		$powershellversie = $powershell_packageversion_textbox.Text
		$installScript = Join-Path -Path $config_packagefolder -ChildPath "$powershellpnaam\$powershellversie\source\install.ps1"
		$ise32Path = "$env:windir\SysWOW64\WindowsPowerShell\v1.0\PowerShell_ISE.exe"
		$ise64Path = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe"
		if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
		{
				Start-Process -FilePath $ise32Path -ArgumentList $installScript
		}
		else
		{
				Start-Process -FilePath $ise64Path -ArgumentList $installScript
		}
		PowershellISEOnTop
		
	}
}

$Powershell_testUnInstall_button2_Click = {
	#TODO: Place custom script here
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$usercontext = 'In User context'
		$sysemcontext = $null;
		
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$usercontext = 'in Sytem context'
		$sysemcontext = 'Testing Sytem context as Elevated user;'
	}
	if ([System.Windows.Forms.MessageBox]::Show("Please test your script. After editing. Please use the save button in Powershell_ISE", "Openening Powershell_ISE in $32or64", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.Text
		$powershellversie = $powershell_packageversion_textbox.Text
		$installScript = Join-Path -Path $config_packagefolder -ChildPath "$powershellpnaam\$powershellversie\source\uninstall.ps1"
		$ise32Path = "$env:windir\SysWOW64\WindowsPowerShell\v1.0\PowerShell_ISE.exe"
		$ise64Path = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe"
		if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
		{
				Start-Process -FilePath $ise32Path -ArgumentList $installScript
		}
		else
		{
				Start-Process -FilePath $ise64Path -ArgumentList $installScript
		}
		PowershellISEOnTop
		
	}
}

$Powershell_CreateIntuneWIn_button2_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$powershell_output_textbox5.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$powershellpnaam\$powershellversie\source\" -s "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -o "$outputDirectory\$powershellpnaam\$powershellversie\output\" -q
	Rename-Item -Path "$outputDirectory\$powershellpnaam\$powershellversie\output\install.intunewin" -NewName "$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin"
	$powershell_output_textbox5.AppendText("`nIntunewin file created: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin")
	$powershell_output_textbox5.AppendText("`r`n")
	
	$powershell_output_textbox5.AppendText("Install command is: `r`n")
	if ($32or64 -like "32 Bit Mode")
	{
		$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
		$powershell_output_textbox5.AppendText("un-install command is: `r`n")
		$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
		$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	}
	else
	{
		$powershell_output_textbox5.AppendText("%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1 `r`n")
		$powershell_output_textbox5.AppendText("un-install command is: `r`n")
		$powershell_output_textbox5.AppendText("%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file uninstall.ps1 `r`n")
		$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	}
	
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		if ($32or64 -like "32 Bit Mode")
		{
			$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		}
		else
		{
			$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\$RegisterDetectionroot\"
		}
		
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	$powershell_output_textbox5.AppendText("$regkeyApp `r`n")
	$powershell_output_textbox5.AppendText("Detection Method is: 'String Comparison' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: 'Version' `r`n")
	$powershell_output_textbox5.AppendText("Detection Operator is: 'Equals' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: $powershellversie `r`n")
	$powershell_output_textbox5.AppendText("Please reopen tool to make another Powershell package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
		[string]$context
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$context = 'user'
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$context = 'system'
	}
	$IntuneWinPackageConfig = $null;
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $true)
	{
		$icmd = '%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1'
		$ucmd = 'SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1'
	}
	else
	{
		$icmd = "powershell -executionpolicy bypass -file install.ps1"
		$ucmd = "powershell -executionpolicy bypass -file uninstall.ps1"
	}
	
	
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$powershellpnaam.intunewin"
			DisplayName   = $powershellpnaam
			Publisher	  = $config_customername
			AppVersion    = $powershellversie;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = $icmd
			uninstallCMD  = $ucmd
			context		  = $context
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$powershellpnaam\$powershellversie\output\"
	$powershell_output_textbox5.AppendText("Config.csv written to: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv")
	$powershell_output_textbox5.AppendText("  `r`n")
	$Powershell_upload_logo_button.Enabled = $true
	$Powershell_upload_logo_button.Visible = $true
	$powershell_output_textbox5.AppendText("When needed upload Logo to upload *.png file. `r`n")
	$powershell_output_textbox5.AppendText("Then use this config.csv in the upload tab to upload package to Intune. `r`n")
}

$Powershell_upload_logo_button_Click = {
	#TODO: Place custom script here
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$powershellpnaam\$powershellversie\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	
	
	$powershell_output_textbox5.AppendText("`r`n")
	$powershell_output_textbox5.AppendText("Logo.PNG now available in Output Directory`r`n")
}


$updatepackage_msi_open_config_button1_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$updatepackage_msi_appname_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appname_new_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appversion_textbox3.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$updatepackage_msi_appcustomer_textbox3.Text = $updatepackage_customername
	$updatepackage_msi_panel5.Enabled = $true
	$updatepackage_msi_panel5.Visible = $true
	$updatepackage_msi_panel4.Visible = $true
	$updatepackage_msi_panel4.Enabled = $true
}

$updatepackage_msi_label5_Click = {
	#TODO: Place custom script here
	
}

$labelAppName_Click = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_Yes_radiobutton1_CheckedChanged = {
	#TODO: Place custom script here
	if ($updatepackage_msi_Yes_radiobutton1.Checked -eq $true)
	{
		$updatepackage_msi_panel6.Enabled = $true
		$updatepackage_msi_panel6.Visible = $true
	}
	else
	{
		$updatepackage_msi_panel6.Enabled = $false
		$updatepackage_msi_panel6.Visible = $false
	}
}

$updatepackage_msi_clone_button_Click = {
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($updatepackage_msi_change_customer_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($updatepackage_msi_appversion_new_textbox3.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $updatepackage_msi_change_customer_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$updatepackage_msi_appname_new_textbox3.text = $powershellpnaam
		$powershellversie = $updatepackage_msi_appversion_new_textbox3.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_msi_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_msi_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_msi_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$versie  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_msi_output_textbox4.AppendText("config.csv creation done; Please open new package source dir and change MSI file and other source files; Step 3")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("Replace MSI file for newer version with a. MSI file with the same name or b. change the Install parameters below")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
	}
	
}


$updatepackage_msi_appname_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_appversion_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_panel5_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$updatepackage_msi_installParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_open_source_dir_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	
}

$updatepackage_msi_testinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Add-Type -AssemblyName PresentationFramework
	$imagePath = "C:\Program Files\IntunePrepTool\update_package_msi_copy_uninstallstring.png"
	$window = New-Object system.windows.window
	$window.Title = "IntunePrepTool MSI uninstall command help"
	$window.Width = 603
	$window.Height = 700
	$window.WindowStartupLocation = 'CenterScreen'
	$dockPanel = New-Object System.Windows.Controls.DockPanel
	$image = New-Object System.Windows.Controls.Image
	$image.Source = [System.Windows.Media.Imaging.BitmapImage]::new([Uri]::new($imagePath))
	$image.Stretch = "Fill"
	$button = New-Object System.Windows.Controls.Button
	$button.Content = "Understood, open PowerShell_ISE now"
	$button.Width = 250
	$button.HorizontalAlignment = "Center"
	$button.VerticalAlignment = "Bottom"
	$button.Add_Click({
			powershell_ise -file "$newpackage_sourcepath\install.ps1"
			$window.Close() # Close the window after opening PowerShell ISE
		})
	[System.Windows.Controls.DockPanel]::SetDock($button, [System.Windows.Controls.Dock]::Bottom)
	$dockPanel.Children.Add($button)
	$dockPanel.Children.Add($image)
	$window.Content = $dockPanel
	$window.ShowDialog()
	
	
	$updatepackage_msi_panel66.Enabled = $true
}

$updatepackage_msi_saveinstallparemeters_button_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_testinstall_button1.Enabled = $true
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_installParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\i.cmd" -encoding ascii -Force -ErrorAction Stop
}

$updatepackage_msi_testuninstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_uninstallParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\u.cmd" -encoding ascii -Force -ErrorAction Stop
	$updatepackage_msi_testuinstall_button1.Enabled = $true
}

$updatepackage_msi_uninstallParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_testuinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
	$updatepackage_msi_panel67.Enabled = $true
}

$updatepackage_msi_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_msi_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_msi_output_textbox4.AppendText("`r`n")
	
	$updatepackage_msi_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
	
}



$exe_open_Azure_OpenAI_Example_button1_Click = {
	#TODO: Place custom script here
	
	if (!(Test-Path "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"))
	{
		[void][System.Windows.Forms.MessageBox]::Show("Go to config tab to configure Azure AI OpenAI Deployment", 'Please setup Azure AI Config first')
	}
	else
	{
		$OpenAICSV = Import-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"
		
		
		$exe_appDname = $exe_packagenaam_textbox1.Text
		$EXEName = $exe_openfiledialog1.SafeFileName
		$apiKey = $OpenAICSV.Key
		$endpoint = $OpenAICSV.endpointURL
		$deployname = $OpenAICSV.deploymentName
		$uri = $endpoint + "openai/deployments/" + $deployname + "/chat/completions?api-version=2024-02-15-preview"
		$body = @"
{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Show example of silent install parameters for $exe_appDname EXE file: $EXEName"
        }
      ]
    }
  ],
  "temperature": 0.4,
  "top_p": 0.95,
  "max_tokens": 800
}
"@
		
		
		$headers = @{
			"Content-Type" = "application/json"
			"api-key"	   = $apiKey
		}
		try
		{
			$request = Invoke-RestMethod -Method POST -Uri $uri -ContentType "application/json" -Body $body -Headers $headers -ErrorAction Stop
			$text = $request.choices.message.content
			$startPattern = '```sh'
			$endPattern = '```'
			$start = $text.IndexOf($startPattern) + $startPattern.Length
			$end = $text.IndexOf($endPattern, $start)
			
			
			if ($start -ge 0 -and $end -gt $start)
			{
				$command = $text.Substring($start, $end - $start).Trim()
				
				$commandParts = $command -split " "
				$commandWithoutExe = $commandParts[1 .. ($commandParts.Length - 1)] -join " "
				
				$exe_parsInstall_textbox1.Text = "`"$commandWithoutExe`""
				$text = $text -replace '```sh', ""
				$text = $text -replace '`', ""
				$exe_richtextbox3.Text = $text
				$exe_panel5.Enabled = $true
				$exe_panel5.Visible = $true
				$exe_open_Azure_OpenAI_Example_button1.Text = "Retry Azure OpenAI"
				
			}
			
		}
		catch
		{
			
			if ($_.Exception.Message -like 'The remote server returned an error: (429) Too Many Requests.')
			{
				
				[void][System.Windows.Forms.MessageBox]::Show('Please wait 30 seconds before trying again', '(429) Too Many Requests.')
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show("($_.Exception.Message)", 'Error message')
			}
		}
	}
}

$config_openAI_save_button2_Click = {
	#TODO: Place custom script here
	class openAIAzure {
		[string]$key
		[string]$endpointURL
		[string]$deploymentName
		
	}
	$openAIAzure = $null;
	$openAIAzure += @([openAIAzure]@{
			key		       = $config_openAI_textbox6.Text
			endpointURL    = $config_openAI_textbox7.Text
			deploymentName = $config_openAI_textbox8.Text
			
		})
	
	$openAIAzure | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv" -NoTypeInformation -Force
	[void][System.Windows.Forms.MessageBox]::Show('U can use the Azure OpenAI button in the tool now', 'CSV file with config written to  c:\users\$env:USERNAME\.IntunePrepTool\')
	
}


$config_openAI_help_Click = {
	#TODO: Place custom script here
	Invoke-Item "C:\Program Files\IntunePrepTool\IntunePrepTool-AzureOpenAI-setup-Screenshots.pdf"

}




$config_openAI_textbox8_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox7_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox6_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_radiobutton2_CheckedChanged={
	#TODO: Place custom script here
	
}

$updatePackageIntunewinToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$updatepackage_exe_open_config_button1_Click={
	#TODO: Place custom script here
	$update_exe_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$update_exe_appname_old_textbox5.Text = $ConfigCSVImport.DisplayName
	$update_exe_new_appname_textbox7.Text = $ConfigCSVImport.DisplayName
	$update_exe_appversion_old_textbox4.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$update_exe_customer_old_textbox3.Text = $updatepackage_customername
	$updatepackage_EXE_panel6.Enabled = $true
	$updatepackage_EXE_panel6.Visible = $true
	$update_exe_panel4.Visible = $true
	$update_exe_panel4.Enabled = $true
}

$update_exe_buttonStep2CloneToNewDirec_Click={
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($update_exe_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($update_exe_new_appversion_textbox6.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $update_exe_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $update_exe_new_appname_textbox7.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$update_exe_new_appname_textbox7.text = $powershellpnaam
		$powershellversie = $update_exe_new_appversion_textbox6.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_exe_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_exe_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $update_exe_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_exe_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appName =*') -or ($lni -like '$version  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$appName =*') -or ($lni -like 'Versie =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("Replace EXE file for newer version with a. EXE file with the same name or b. change the Install parameters below")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		<#
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		#>
		$update_exe_panel6.Enabled = $true
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		foreach ($lni2 in $installparameters)
		{
			if ($lni2 -like '$exeParameters =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exeparameters2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exeparameters2 = $null
				}
				$exeparameters2 = $exeparameters2 -replace "^ ", ""
				$exeparameters2 = $exeparameters2.split("#")[0]
				$update_exe_installPar_textbox3.Text = $exeparameters2
			}
			if ($lni2 -like '$exeFile =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exefilename2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exefilename2 = $null
				}
				$exefilename2 = $exefilename2 -replace "^ ", ""
				
				$update_exe_Exefilename_textbox3.Text = $exefilename2
			}
			
		}

	
		$IsThisLineThereInUninstall = $old_uninstallps1 | ForEach-Object {
			if ($_ -match 'Please see u\.cmd for MSI parameters used by this script')
			{
				$_.Trim() 
			}
		} | Where-Object { $_ }
		if ($IsThisLineThereInUninstall)
		{
			Write-Host "De regel is aanwezig: $IsThisLineThereInUninstall"
			$update_exe_uninstall_panel6.Enabled = $false
			$update_exe_uninstall_panel6.Visible = $false
			$update_Exe_Uninstall_MSI_panel6.Enabled = $true
			$update_Exe_Uninstall_MSI_panel6.Visible = $true
			$update_exe_msi_uninstallcommandsOld = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\u.cmd"
			$udpdate_exe_msi_uninstall_textbox4.Text = $update_exe_msi_uninstallcommandsOld
			[void][System.Windows.Forms.MessageBox]::Show('See Find Uninstall String in the tools menu to search for new uninstall productcode and change the uninstall parameters after testing installation', 'Change uninstall string')
			
		}
		else
		{
			$oldInstallExeFilename = $old_installps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeFilename = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeParameters = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeParameters\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			#Write-Host "Old Install EXE Filename: $oldInstallExeFilename"
			#Write-Host "Old Uninstall EXE Filename: $oldUnInstallExeFilename"
			if ($oldInstallExeFilename -like $oldUnInstallExeFilename)
			{
				#Write-Host "Same EXE as install: $oldUnInstallExeFilename)"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
			Else
			{
				#Write-Host "Uninstall EXE path is $oldUnInstallExeFilename"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
		}
		
		
		
	}
}

$update_exe_buttonStep3OpenSourceDirec_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	$update_exe_buttonStep4SaveInstallPara.Enabled = $true
}

$update_exe_buttonStep4SaveInstallPara_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$installparameters = Get-Content "$newpackage_sourcepath\install.ps1"
	Remove-Item "$newpackage_sourcepath\install.ps1"
	foreach ($lni2 in $installparameters)
	{
		if (($lni2 -like '$exeParameters =*') -or ($lni2 -like '$exeFile =*'))
		{
			
			
			if ($lni2 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_installPar_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
			if ($lni2 -like '$exeFile =*')
			{
				
				'$exeFile = ' + $update_exe_Exefilename_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
		}
		else
		{
			$lni2 | Out-File "$newpackage_sourcepath\install.ps1" -Append
		}
		
	}
	$update_exe_buttonStep5TestAndEditInst.Enabled = $true
}

$update_exe_buttonStep5TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\install.ps1"
	
}

$buttonStep7TestAndEditUnin_Click={
	#TODO: Place custom script here
	
}

$update_exe_uninstall_msi_save_button3_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$udpdate_exe_msi_uninstall_textbox4.Text | Out-File "$newpackage_sourcepath\u.cmd" -Force
	$update_exe_uninstall_MSI_Test_button2.Enabled = $true
}

$update_exe_uninstall_MSI_Test_button2_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$buttonStep6SaveUninstallPa_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$uninstall_exe_uninstall = Get-Content "$newpackage_sourcepath\uninstall.ps1"
	Remove-Item "$newpackage_sourcepath\uninstall.ps1" -Confirm:$false -Force
	foreach ($lni5 in $uninstall_exe_uninstall)
	{
		if (($lni5 -like '$exeFile =*') -or ($lni5 -like '$exeParameters =*'))
		{
			if ($lni5 -like '$exeFile =*')
			{
				'$exeFile = ' + $update_exe_filetpathUninstall_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
			if ($lni5 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_uninstall_parameters_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
		}
		else
		{
			$lni5 | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			
		}
		
	}
	$update_exe_testuninstall_exe_buttonStep7TestAndEditInst.Enabled = $true
	
}

$update_exe_testuninstall_exe_buttonStep7TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$update_exe_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $update_exe_new_appname_textbox7.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_exe_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_exe_output_textbox4.AppendText("`r`n")
	
	$updatepackage_exe_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
}


$tools_choco_search_button2_Click={
	#TODO: Place custom script here
	
	
	function chocoSearch
	{
		param (
			[Parameter(Mandatory = $true)]
			[string]$name,
			[bool]$approvedOnly = $false
		)
		
		$chocoSearch = choco find $name --order-by-popularity
		if ($chocoSearch.Count -gt 2)
		{
			$chocoSearch = $chocoSearch[1 .. ($chocoSearch.Count - 2)]
		}
		
		$results = @()
		
		foreach ($ch in $chocoSearch)
		{
			$splitLine = $ch.Split(" ", 3, [System.StringSplitOptions]::RemoveEmptyEntries)
			if ($splitLine.Count -lt 2)
			{
				continue
			}
			
			$currentName = $splitLine[0]
			$currentVersion = $splitLine[1]
			$remaining = ""
			if ($splitLine.Count -eq 3)
			{
				$remaining = $splitLine[2]
			}
			if ($ch -match 'found|know|Learn')
			{
				continue
			}
			$isApproved = ($remaining -match '\[Approved\]')
			if ($approvedOnly -and -not $isApproved)
			{
				continue
			}
			$obj = [pscustomobject]@{
				Name	 = $currentName
				Version  = $currentVersion
				Approved = $isApproved
			}
			
			$results += $obj
		}
		
		return $results
	}
	$sChoco = $tools_choco_search_textbox3.Text
	
	
	if ($tools_choco_checkbox1.Checked -eq $true)
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $true
	}
	else
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $false
	}
	try
	{
		New-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script
	}
	

	$tools_choco_treeview2.BeginUpdate()
	$tools_choco_treeview2.Refresh()
	$tools_choco_treeview2.Nodes.Clear()
	#$tools_choco_treeview2.CheckBoxes = $true
	$Root = $tools_choco_treeview2.Nodes.Add("Choco Packages")
	foreach ($p in $chocoOutput)
	{
		#$upload_treeview2.Nodes.Add($tenantCSV.customername)
		$node = $Root.Nodes.Add($p.Name)
		
		$node.ContextMenuStrip = $tools_choco_contextmenustrip1
		#$node.Tag = $tenantCSV.target
		$node.Name = $p.Name
		
		
	}
	$Root.Expand()
	$tools_choco_treeview2.EndUpdate()
}

$config_tenants_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}



$tools_choco_contextmenustrip1_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$choco_toolstripmenuitem1_Click= {
	#TODO: Place custom script here
	

}
$tools_choco_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$chocoAll = Get-Variable -Name 'chocoOutput2' -Scope Script -ValueOnly
	$tools_choco_details_richtextbox1.text = ""
	
	foreach ($ch1 in $chocoAll)
	{
		if ($ch1.Name -eq $tools_choco_treeview2.SelectedNode.Name)
		{
			$tools_choco_panel6.Enabled = $true
			$tools_choco_selected_label6.Enabled = $true
			$tools_choco_selected_label6.Visible = $true
			$tools_choco_selected_label6.Text = $ch1.Name
			$chocoDetails = choco find $ch1.Name --exact --detail
			foreach ($ch2 in $chocoDetails)
			{
				$tools_choco_details_richtextbox1.AppendText("`r`n")
				$tools_choco_details_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}



$tools_choco_createdir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $tools_choco_displayname_textbox3.text
	$exeversie = $tools_choco_appversion_textbox3.text
	$exepnaam = $exepnaam -replace (" ", "")
	$tools_choco_displayname_textbox3.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$tools_choco_output_textbox3.Text = "`nNew package directory created: `r`n"
			$tools_choco_output_textbox3.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$tools_choco_output_textbox3.AppendText("`r`n")
			$tools_choco_panel7.Enabled = $true
			$tools_choco_open_PackageDir_button2.Enabled = $true
			$tools_choco_buttonOpenPackageDirectory.Enabled = $true
			$tools_choco_buttonOpenPackageDirectory.Visible = $true
		}
	}
}
$tools_choco_displayname_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_appversion_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_createscriots_button2_Click={
	#TODO: Place custom script here
	$choco_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:19
	 Created by:   	Rink Turksma
	 Organization: 	https://githhub.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"
$paramsChoco = "!!paramsChocho!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
if (!(test-path -Path "$env:programdata\chocolatey"))
	{
		write-host "Installing Chocolatey"
		[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
	}


write-host "Now installing: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green
try
{
	write-host "Choco installation started" -ForegroundColor Green
	if ($paramsChoco -eq 'false')
	{
		choco install $chocoName --exact --yes --force
	}
	else
	{
		choco install $chocoName --exact --params $paramsChoco --yes --force
	}
	write-host "Installation success" -ForegroundColor Green
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	write-host "Now creating weekly scheduled task to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek Monday -At 10:00
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}

if ($startupUpdateTask -eq 'true')
{
	write-host "Now creating scheduled task at startup to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -AtStartup
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}


try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	fDetectionInRegistry -succes $true
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	$choco_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:25
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
write-host "Now uninstalling: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green




try
{
	write-host "Choco uninstallation started" -ForegroundColor Green
	choco uninstall $chocoName --exact --yes --force
	write-host "UnInstallation success" -ForegroundColor Green
}
catch
{
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}
if ($startupUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
	
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000)
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	remove-item $regkeyApp
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$RegisterDetectionroot = "Intune_" + $config_customername
	$appVersion = $tools_choco_appversion_textbox3.text
	$appName = '"' + $tools_choco_displayname_textbox3.text + '"'
	$appName2 = $tools_choco_displayname_textbox3.text
	$chocoName = $tools_choco_selected_label6.Text
	
	$choco_installFile  = $choco_installFile.Replace('"!!AppName!!"', $appName)
	$choco_installFile  = $choco_installFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_installFile  = $choco_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_installFile  = $choco_installFile.Replace('!!version!!', $appVersion)
	$choco_installFile = $choco_installFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true' 
	$choco_installFile = $choco_installFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true) { $paramschoco = $tools_choco_parammstextbox3.Text; $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', $paramschoco) }
	else { $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', 'false') }
	try
	{
		$choco_installFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$appName2\$appVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	$choco_uninstallFile = $choco_uninstallFile.Replace('"!!AppName!!"', $appName)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!version!!', $appVersion)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true'
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	try
	{
		$choco_uninstallFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\uninstall.ps1" -Force -ErrorAction Stop
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
		$tools_choco_panel11.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 NOT created `r`n")
	}
}

$tools_choco_open_PackageDir_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$AppVersion = $tools_choco_appversion_textbox3.text
	Invoke-Item "$config_packagefolder\$appName\$appVersion\"
}

$tools_choco_testinstall_button2_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$appName = $tools_choco_displayname_textbox3.text
		$appVersion = $tools_choco_appversion_textbox3.text
		powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$tools_choco_testUNinstall_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	$tools_choco_addBuildingBlocksCSVButton.Enabled = $true
}

$config_download_Choco_MSIX_bundle_Click={
	#TODO: Place custom script here
	
	$config_install_required_chocolatey = @'
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$picturebox1_Click={
	#TODO: Place custom script here
	
}

$tools_choco_AddParams_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true)
	{
		$tools_choco_parammstextbox3.Enabled = $true
		$tools_choco_parammstextbox3.Visible = $true
	}
	else
	{
		$tools_choco_parammstextbox3.Enabled = $false
		$tools_choco_parammstextbox3.Visible = $false
	}
}

$tools_choco_create_intunewin_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$appName\$appVersion\source\" -s "$config_packagefolder\$appName\$appVersion\source\install.ps1" -o "$config_packagefolder\$appName\$appVersion\output\" -q
	Rename-Item -Path "$config_packagefolder\$appName\$appVersion\output\install.intunewin" -NewName "$config_packagefolder\$appName\$appVersion\output\$appName.intunewin"
	$tools_choco_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\$appName.intunewin")
	$tools_choco_output_textbox3.AppendText("`r`n")
	
	$tools_choco_output_textbox3.AppendText("Install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("un-install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$appName\"
	$regkeyApp
	$tools_choco_output_textbox3.AppendText("$regkeyApp `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: $appVersion `r`n")
	$tools_choco_output_textbox3.AppendText("Please reopen tool to make another Chocolatey package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$appName.intunewin"
			DisplayName   = $appName
			Publisher	  = $config_customername
			AppVersion    = $appVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$appName\$appVersion\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$appName\$appVersion\output\"
	$tools_choco_output_textbox3.AppendText("Config.csv written to naar: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\config.csv")
	$tools_choco_output_textbox3.AppendText("  `r`n")
	$tools_choco_output_textbox3.AppendText("Firt use Upload Logo to upload *.png file. `r`n")
	$tools_choco_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $choco_buildingBlocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$config_packagefolder\$appName\$appVersion\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appName\BuildingBlocks.csv" -force -NoTypeInformation
		$tools_choco_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$tools_choco_output_textbox3.AppendText("$config_buildingblockspath\$appName\BuildingBlocks.csv `r`n")
		$tools_choco_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
}

$tools_choco__upload_logo_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$UploadLogo_openfiledialog1.ShowDialog()
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	
	$filesize = Get-Item -Path $logo_org_path
	$oneMB = 1MB
	if ($filesize.Length -le $oneMB)
	{
		Copy-Item -Path $logo_org_path -Destination "$config_packagefolder\$appName\$appVersion\output\logo.png" -ErrorAction Stop
	}
	else
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select PNG smaller than 1 MB', 'The file size is larger than 1 MB.')
	}
	$tools_choco_output_textbox3.AppendText("`r`n")
	$tools_choco_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}

$winget_search_button2_Click={
	$downloadWingetSearchText = $winget_search_textbox3.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$winget_output_textbox3.Text = $null
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	$winget_search_treeview2.BeginUpdate()
	$winget_search_treeview2.Refresh()
	$winget_search_treeview2.Nodes.Clear()
	$Root = $winget_search_treeview2.Nodes.Add("Winget Packages")
	$wingetOutp1 = @()
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$wingetOutp2 = $row_download_winget | Select ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$wingetOutp1 += [PSCustomObject]@{ ID = $wingetOutp2 }
				$node = $Root.Nodes.Add($download_winget_listboxInput)
				$node.Name = $wingetOutp2
			}
			$table_download_winget.AcceptChanges();	
			
		}
		
	}
	$Root.Expand()
	$winget_search_treeview2.EndUpdate()
	try
	{
		New-Variable -Name 'wingetOutput' -Value $wingetOutp1 -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'wingetOutput' -Value $wingetOutp1 -Scope Script
	}
	
	
}

$winget_search_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$wingetAll = Get-Variable -Name 'wingetOutput' -Scope Script -ValueOnly
	$winget_show_info_richtextbox1.text = $null;
	foreach ($ch1 in $wingetAll.ID)
	{
		if ($ch1 -eq $winget_search_treeview2.SelectedNode.Name)
		{
			#$tools_choco_panel6.Enabled = $true
			#$tools_choco_selected_label6.Enabled = $true
			#$tools_choco_selected_label6.Visible = $true
			#$tools_choco_selected_label6.Text = $ch1.Name
			#$winget_settings_panel7.Enabled = $true;
			$winget_selected_panel7.Enabled = $true
			$winget_createPackageDIR_panel7.Enabled = $true
			$wingetDetails = winget show --id $ch1
			$ch1 = $ch1.Replace('"','')
			$winget_WingetID_textbox1.Text = $ch1
			foreach ($ch2 in $wingetDetails)
			{
				$winget_show_info_richtextbox1.AppendText("`r`n")
				$winget_show_info_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}

$winget_CreatePackageDir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$version = $versie_textbox2.Text
		if ($version -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			
			
			$WinGetID = $winget_WingetID_textbox1.text
			
			$DisplayName = $winget_displayname_textbox1.text
		
			if (!(Test-Path -Path "$config_packagefolder\$WinGetID\$version\source"))
			{
				
				New-Item -ItemType Directory -Path "$config_packagefolder\$WinGetID\$version\source"
			}
			if (!(Test-Path -Path "$config_packagefoldery\$WinGetID\$version\output"))
			{
				
				New-Item -ItemType Directory -Path "$config_packagefolder\$wingetID\$version\output"
			}
			$winget_open_package_dir_button3.Enabled = $true
			$winget_settings_panel7.Enabled = $true
			$winget_buttonAddCustomDescription.Enabled = $true
			$winget_buttonAddCustomDescription.Visible = $true
			
		}
	}
}
$winget_open_package_dir_button3_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$version = $versie_textbox2.Text
	$WinGetID = $winget_WingetID_textbox1.text
	Invoke-Item "$config_packagefolder\$WinGetID\$version"
}

$checkbox1_CheckedChanged={
	#TODO: Place custom script here
	
}

$radiobutton64Bit_CheckedChanged={
	#TODO: Place custom script here
	
}

$config_version_label1_Click={
	#TODO: Place custom script here
	
}

$config_install_sandbox_buttonInstallSanboxPowersh_Click={
	#TODO: Place custom script here
	$config_install_required_chocolatey = @'
Enable-WindowsOptionalFeature -FeatureName "Containers-DisposableClientVM" -All -Online
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installSandbox.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey | Out-File "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installSandbox.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey | Out-File "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$config_add_Tenant_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}



$registryToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}


$capture_registry_loadTreeview_button2_Click={
	#TODO: Place custom script here

		

	
	
}

$Registry_capture_panel7_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$capture_registry_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	#Source https://www.sapien.com/forums/viewtopic.php?t=11679
	if ($_.Node.Nodes.Count -eq 0)
	{
		foreach ($keyName in ($_.Node.Tag.GetSubkeyNames()))
		{
			Try
			{
				$regKey = $_.Node.Tag.OpenSubKey($keyName)
				$n = New-Object System.Windows.Forms.TreeNode
				$n.Name = $regKey.PsPath
				$n.Text = $keyName
				$n.Tag = $regKey
				$_.Node.Nodes.Add($n)
			}
			Catch
			{
				Write-Host $_
			}
		}
	}

}

$registry_capture_tabpage5_Click={
	#TODO: Place custom script here
	
}

$Registry_Capture_Step2_CreateBackup_button2_Click = {
	if ($registry_name_textbox3.Text -notlike $null)
	{
		
		$node = $capture_registry_treeview2.SelectedNode
		$nodeTexts = @()
		while ($node)
		{
			$nodeTexts += $node.Text
			$node = $node.Parent
		}
		$reversedNodeTexts = @()
		for ($i = $nodeTexts.Count - 1; $i -ge 0; $i--)
		{
			$reversedNodeTexts += $nodeTexts[$i]
		}
		$rootHive = ""
		$allNodesString = $rootHive + ($reversedNodeTexts -join "\")
		
		$RegistryCaptureScript = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	22-3-2025 20:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	regcompare.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$regexportpath = "!!regexportpath!!"
$backupFolder = "!!backupFolder!!"
if (!(Test-Path $backupFolder))
{
	New-Item -Path $backupFolder -ItemType Directory | Out-Null
}
$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$preBackupPath = Join-Path $backupFolder "PreChanges_$timeStamp.reg"
$postBackupPath = Join-Path $backupFolder "PostChanges_$timeStamp.reg"
$DiffRegName = "!!DiffRegName!!"
$diffPath = Join-Path $backupFolder "$DiffRegName`_$timeStamp.reg"

Write-Host "Exporting registry from: $regExportPath"  
Write-Host "Creating first registry backup (pre-changes)..."  
reg export "$regExportPath" "$preBackupPath" /y | Out-Null
Write-Host "  Pre-changes backup saved to: $preBackupPath`n"
Write-Host "Make any desired changes to your registry/application now." -ForegroundColor Green
Write-Host "Press ENTER when finished..." -ForegroundColor Green
Read-Host
Write-Host "`nCreating second registry backup (post-changes)..."  
reg export "$regExportPath" "$postBackupPath" /y | Out-Null
Write-Host "  Post-changes backup saved to: $postBackupPath`n"  
Write-Host "Now comparing backups to find differences..."  

function Compare-RegFiles
{
	param (
		[string]$OldRegPath,
		[string]$NewRegPath,
		[string]$DiffOutPath
	)
	
	$oldLines = [System.IO.File]::ReadAllLines($OldRegPath)
	$newLines = [System.IO.File]::ReadAllLines($NewRegPath)
	$oldHashSet = [System.Collections.Generic.HashSet[string]]::new($oldLines)
	$differences = New-Object System.Collections.Specialized.OrderedDictionary
	$currentKey = $null
	foreach ($line in $newLines)
	{
		if ($line -match '^\[\S+\]$')
		{
			$currentKey = $line
			continue
		}
		if ($line -match '^\S+=' -and $currentKey)
		{
			if (-not $oldHashSet.Contains($line))
			{
				if (-not $differences.Contains($currentKey))
				{
					$differences[$currentKey] = [System.Collections.Generic.List[string]]::new()
				}
				$differences[$currentKey].Add($line)
			}
		}
	}
	if ($differences.Count -gt 0)
	{
		Set-Content -Path $DiffOutPath -Value "Windows Registry Editor Version 5.00`r`n"
		foreach ($key in $differences.Keys)
		{
			Add-Content -Path $DiffOutPath -Value "`r`n$key"
			foreach ($val in $differences[$key])
			{
				Add-Content -Path $DiffOutPath -Value $val
			}
		}
		Write-Host "Differences found! Saved to: $DiffOutPath" -ForegroundColor Green
		$DiffOutPath | out-file "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt" -force
	}
	else
	{
		Write-Host "No differences detected."  
		if (Test-Path $DiffOutPath)
		{
			Remove-Item $DiffOutPath -ErrorAction SilentlyContinue
		}
	}
}

Compare-RegFiles -OldRegPath $preBackupPath `
				 -NewRegPath $postBackupPath `
				 -DiffOutPath $diffPath


Write-Host "`nRemoving the two backup files..."  
Remove-Item -Path $preBackupPath -ErrorAction SilentlyContinue
Remove-Item -Path $postBackupPath -ErrorAction SilentlyContinue

Write-Host "`nAll done. Please close this Powershell_ISE window and continue in the IntunePrepTool"


'@
		if (Get-Process -Name "powershell_ise" -ErrorAction SilentlyContinue)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please close any existing Powershell_ISE windows, When done.. Start again', 'Please close existing Powershell_ISE windows')
		}
		else
		{
			
			if ($registry_name_textbox3.text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please select Name first, When done.. Start again', 'Please select Name first')
			}
			else
			{
				if ($Registry_HKLM_radiobutton1.Checked -eq $true)
				{
					$regName = "HKLM_"
				}
				if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
				{
					$regName = "HKCU_"
				}
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!regexportpath!!", $allNodesString)
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$BackupLocation = $config_packagefolder + '\' + "0_BuildingBlocks\Registry"
				$BackupLocation = $BackupLocation -replace ("\\", "\")
				$regName2 = $regName + $registry_name_textbox3.text
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!DiffRegName!!", $regName2)
				
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!backupFolder!!", $BackupLocation)
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!DiffRegName!!", $regName2)
				
				
				
				if (!(Test-Path "C:\Program Files\IntunePrepTool\regcompare.ps1" -PathType Leaf))
				{
					$RegistryCaptureScript | Out-File "C:\Program Files\IntunePrepTool\regcompare.ps1"
					powershell_ise -file "C:\Program Files\IntunePrepTool\regcompare.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
				else
				{
					try
					{
						Remove-Item "C:\Program Files\IntunePrepTool\regcompare.ps1" -Confirm:$false -ErrorAction Stop
						$RegistryCaptureScript | Out-File "C:\Program Files\IntunePrepTool\regcompare.ps1"
						powershell_ise -file "C:\Program Files\IntunePrepTool\regcompare.ps1"
						Start-Sleep 1
						PowershellISEOnTop
					}
					catch
					{
						[void][System.Windows.Forms.MessageBox]::Show('When done.. Start again', 'Please close existing Powershell_ISE windows')
					}
					
					
				}
			}
		}
	}
	else
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Enter name and start again please', 'Please enter Name first')
	}
	
	
	
}



$Registry_load_button2_Click={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$capture_registry_treeview2.Refresh()
		$capture_registry_treeview2.Nodes.Clear()
		$capture_registry_treeview2.Refresh()
		if ($Registry_HKLM_radiobutton1.Checked -eq $true)
		{
			$regKey = Get-Item HKLM:\ -ErrorAction SilentlyContinue
		}
		if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
		{
			$regKey = Get-Item HKCU:\
		}
		
		$n = New-Object System.Windows.Forms.TreeNode
		$n.Name = $regKey.PsPath
		$n.Text = $regKey.Name
		$n.Tag = $regKey
		$capture_registry_treeview2.Nodes.Add($n)
		
		
	
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$toolstripstatuslabel1.Text = "Selected Customer: $config_customername"
	}
	
}

$registry_capture_label5_Click={
	#TODO: Place custom script here
	
}

$registry_name_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$registry_button2_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Please remove all irrelevant items and then click Save in Notepad.', 'Edit .reg file in Notepad')
	$regfile = Get-Content "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt"
	notepad $regfile
	
}

$buttonStep6AddBuildingBloc_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$BackupLocation = $config_packagefolder + '\' + "1_BuildingBlocksPackages\Registry"
	$BackupLocation = $BackupLocation -replace ("\\", "\")
	$regfile = Get-Content "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt"
	
	if ($Registry_HKLM_radiobutton1.Checked -eq $true)
	{
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if([System.Windows.Forms.MessageBox]::Show('In this case, a separate package is not needed. You can also add the created .reg file to your existing MSI, MSIX, or EXE package. Do you want to continue creating a separate package?', 'HKLM selected',[System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
			$systemoruser = "system"
			$regName = "HKLM_"
			$registry_output_textbox3.Text = "Creating Building Block Package in the System context"
			$registry_output_textbox3.AppendText("  `r`n")
			$BuildingBlockRegistrySystem = @'
if (Test-Path 'hklm.reg') {
    Write-Host "hklm.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hklm.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}

'@
			$BackupLocation = $BackupLocation + "\system\"
			$regName2 = $regName + $registry_name_textbox3.text
			$BackupLocation = $BackupLocation + $regName2
			if (!(Test-Path $backupLocation))
			{
				New-Item -Path $backupLocation -ItemType Directory -Force | Out-Null
				$registry_output_textbox3.AppendText("$backupLocation created")
				$registry_output_textbox3.AppendText("  `r`n")
			}
			else
			{
				$registry_output_textbox3.AppendText("$backupLocation already exists")
				$registry_output_textbox3.AppendText("  `r`n")
			}
			$BuildingBlockRegistrySystem | Out-File "$BackupLocation\BuildingBlock.ps1"
			$registry_output_textbox3.AppendText("BuildingBlock.ps1 created")
			$registry_output_textbox3.AppendText("  `r`n")
			Copy-Item $regfile "$backupLocation\hklm.reg"
			$registry_output_textbox3.AppendText("hklm.reg created")
			$registry_output_textbox3.AppendText("  `r`n")
			$registry_output_textbox3.AppendText("You can use this Building Block with other Building Blocks by selecting the System Context when creating the Intunewin file using the 'Building Blocks → Intunewin' function.")
			$registry_buidingblocksfiledir_textbox3.Text = $BackupLocation
			
		}
	}
	if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
	{
		$systemoruser = "user"
		$regName = "HKCU_"
		$registry_output_textbox3.Text = "Creating Building Block Package in the User context"
		$registry_output_textbox3.AppendText("  `r`n")
		$BuildingBlockRegistryUser = @'
if (Test-Path 'hkcu.reg') {
    Write-Host "hkcu.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hkcu.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
'@
		$BackupLocation = $BackupLocation + "\User\"
		$regName2 = $regName + $registry_name_textbox3.text
		$BackupLocation = $BackupLocation + $regName2
		if (!(Test-Path $backupLocation))
		{
			New-Item -Path $backupLocation -ItemType Directory -Force | Out-Null
			$registry_output_textbox3.AppendText("$backupLocation created")
			$registry_output_textbox3.AppendText("  `r`n")
		}
		else
		{
			$registry_output_textbox3.AppendText("$backupLocation already exists")
			$registry_output_textbox3.AppendText("  `r`n")
		}
		$BuildingBlockRegistryUser | Out-File "$BackupLocation\BuildingBlock.ps1"
		$registry_output_textbox3.AppendText("BuildingBlock.ps1 created")
		$registry_output_textbox3.AppendText("  `r`n")
		Copy-Item $regfile "$BackupLocation\hkcu.reg"
		$registry_output_textbox3.AppendText("hkcu.reg created")
		$registry_output_textbox3.AppendText("  `r`n")
		$registry_output_textbox3.AppendText("You can use this Building Block with other Building Blocks by selecting the User Context when creating the Intunewin file using the 'Building Blocks → Intunewin' function.")
		#$registry_buidingblocksfiledir_textbox3.Text = $BackupLocation
		
		
	}
	
	

	
	
	
	
}

$msi_addBuildBlock_regHKLM_Click={
	#TODO: Place custom script here
	<#
	$msi_add_HKLM_openfiledialog1.ShowDialog()
	$msi_reg_hklm_label5.Text = $msi_add_HKLM_openfiledialog1.SafeFileName
	$msi_reg_hklm_label5.Visible = $true
	$msi_reg_hklm_label5.Enabled = $true
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$paname = $msi_packagenaam_textbox1.text
	$paversion = $msi_versie_textbox1.text
	$selectedpadir = "$config_packagefolder\$paname\$paversion\source"
	$msi_output_textbox1.AppendText("`n.reg file will now be copied`r`n")
	[string]$msi_reg_hklm_org_path = $msi_add_HKLM_openfiledialog1.FileNames
	Copy-Item -Path $msi_reg_hklm_org_path -Destination "$selectedpadir\hklm.reg"
	$msi_output_textbox1.AppendText("`n.reg file copy done to HKLM.reg `r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("There`'s no need to recreate your install.ps1 script when already created. The created install.ps1 already checks for a file named 'hklm.reg' and imports it when available.", 'HKLM.reg file added') # Casting the method to [void] suppresses the output. 
	#>
}

$buttonOptionalOpenRegedit_Click={
	#TODO: Place custom script here
	regedit
}

$capture_registry_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$node = $capture_registry_treeview2.SelectedNode
	$nodeTexts = @()
	while ($node)
	{
		$nodeTexts += $node.Text
		$node = $node.Parent
	}
	$reversedNodeTexts = @()
	for ($i = $nodeTexts.Count - 1; $i -ge 0; $i--)
	{
		$reversedNodeTexts += $nodeTexts[$i]
	}
	$rootHive = ""
	$allNodesString = $rootHive + ($reversedNodeTexts -join "\")
	$registry_selected_textbox3.Text = $allNodesString
}

$Registry_OpenBuildingBLockLocationbutton2_Click={
	#TODO: Place custom script here
	explorer $registry_buidingblocksfiledir_textbox3.Text
}

$file_loadFolder_button2_Click={
	#TODO: Place custom script here
	$file_folderbrowsermoderndialog2.ShowDialog()
	$file_selected_source_folder_textbox3.Text = $file_folderbrowsermoderndialog2.SelectedPath
	$file_folder_destination_textbox3.Text = $file_folderbrowsermoderndialog2.SelectedPath
}

$hscrollbar1_Scroll=[System.Windows.Forms.ScrollEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ScrollEventArgs]
	#TODO: Place custom script here
	
}

$addFolderToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-BuildingBlocksFilesAndFolders_psf) -eq 'OK')
	{
		
	}
	
	<#
	$file_folder_panel8.Enabled = $true
	$file_folder_panel8.Visible = $true
	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
#>
	}

$file_folder_cancel_buttonAdd_Click={
	#TODO: Place custom script here
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false

}

$file_folder_add_button2_Click={
	#TODO: Place custom script here
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false
	
	if ($file_folder_skip_checkbox1.Checked -eq $true) {
		$file_folder_SKIP = $true
	}
	if ($file_folder_skip_checkbox1.Checked -eq $FALSE)
	{
		$file_folder_SKIP = $false
	}
	
	if ($file_folder_overwrite_checkbox1.Checked -eq $true)
	{
		$file_folder_overwrite = $true
	}
	if ($file_folder_overwrite_checkbox1.Checked -eq $FALSE)
	{
		$file_folder_overwrite = $false
	}
	
	
	$row = $table.NewRow();
	$row["Sort"] = 'folder';
	$row["Source"] = $file_selected_source_folder_textbox3.text;
	$row["Destination"] = $file_folder_destination_textbox3.Text;
	$row["Skip"] = $file_folder_SKIP;
	$row["Overwrite"] = $file_folder_overwrite;
	$table.Rows.Add($row);
	
	## - Save changes to the table:
	$table.AcceptChanges();
	## - Display custom data created:
	#$files_folders_datagridview1.DataSource = $table;
	
	
}

$config_tenant_info_secret_delete_button2_Click={
	#TODO: Place custom script here
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$file_file_cancel_buttonAdd_Click={
	#TODO: Place custom script here
	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
}

$addFileToolStripMenuItem_Click={
	#TODO: Place custom script here
	$file_file_panel8.Enabled = $true
	$file_file_panel8.Visible = $true
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false
}

$file_loadFile_button2_Click={
	#TODO: Place custom script here
	$file_file_openfiledialog1.ShowDialog()
	$file_selected_source_file_textbox3.Text = $file_file_openfiledialog1.FileNames
	$file_file_destination_textbox3.Text = $file_file_openfiledialog1.FileNames
}

$file_file_add_button2_Click={
	#TODO: Place custom script here
	if ($file_file_skip_checkbox1.Checked -eq $true)
	{
		$file_file_SKIP = $true
	}
	if ($file_file_skip_checkbox1.Checked -eq $FALSE)
	{
		$file_file_SKIP = $false
	}
	
	if ($file_file_overwrite_checkbox1.Checked -eq $true)
	{
		$file_file_overwrite = $true
	}
	if ($file_file_overwrite_checkbox1.Checked -eq $FALSE)
	{
		$file_file_overwrite = $false
	}
	
	
	$row = $table.NewRow();
	$row["Sort"] = 'file';
	$row["Source"] = $file_selected_source_file_textbox3.text;
	$row["Destination"] = $file_file_destination_textbox3.Text;
	$row["Skip"] = $file_file_SKIP ;
	$row["Overwrite"] = $file_file_overwrite;
	$table.Rows.Add($row);
	
	## - Save changes to the table:
	$table.AcceptChanges();

	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
}

$showCompleteToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-ChildForm_psf) -eq 'OK')
	{
		
	}
}

$addRegistryToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-BuildingBlocksRegistry_psf) -eq 'OK')
	{
		
	}
}

$file_folder_tablelayoutpanel1_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$toolstripstatuslabel1_Click={
	#TODO: Place custom script here
	
}

$statusbar1_PanelClick=[System.Windows.Forms.StatusBarPanelClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.StatusBarPanelClickEventArgs]
	#TODO: Place custom script here
	
}

$user_folder_context_system_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}

$BuildingBlocks_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$building_blocks_show_Refresh_button1_Click={
	#TODO: Place custom script here
	
}

$buttonAddFileOrFolder_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage5
	if ((Show-BuildingBlocksFilesAndFolders_psf) -eq 'OK')
	{
		
	}
}

$buildingblocks_buttonAddRegistryCapture_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage6
	if ((Show-BuildingBlocksRegistry_psf) -eq 'OK')
	{
		
	}
}

$buildingBlocks_clear_button1_Click={
	#TODO: Place custom script here
	$BuildingBlocksTable.Clear()
	$BuildingBlocks_datagridview1.DataSource = $BuildingBlocksTable;
	$BuildingBlocksTable2.Clear()
	$BuildingBlocks_datagridview2.DataSource = $BuildingBlocksTable2;
	$BuildingBlocksTable3.Clear()
	$BuildingBlocks_datagridview3.DataSource = $BuildingBlocksTable3;
	
	#$buildingBlocks_panel85.Enabled = $false;
	$bb_usePackageInProgress_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $true
	$bb_usePackageInProgress_radiobutton1.Enabled = $true
	$buildingblocks_Name_textbox4.Text = $null
	$buildingblocks_version_textbox3.Text = $null
}

$tablelayoutpanel9_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$buildingblocks_add_Shortcuts_button1_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage7
	if ((Show-BuildingBlocksShortcut_psf) -eq 'OK')
	{
		
	}
}

$buttonBuild_Click={
	#TODO: Place custom script here
	if ($buildingblocks_Name_textbox4.Text -like $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Select name and try again please!", 'Please select a name for Building Blocks first') # Casting the method to [void] suppresses the output.
	}
	else
	{
		class IntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
			[string]$context
		}
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
		if ($config_buildingblockspath -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please add Building Blocks location for your customer in the Start / Config menu first", 'Building Blocks location missing!')
		}
		else
		{
			$BBAppName = $buildingblocks_Name_textbox4.Text
			if (Test-Path "$config_buildingblockspath\$BBAppName")
			{
				[void][System.Windows.Forms.MessageBox]::Show("Please remove $config_buildingblockspath\$BBAppName before you can continue", 'Location Already exists')
			}
			else
			{
				$bbSystemContext = $false
				$bbUserContext = $false
				$newNameBuildingBlocks = $buildingblocks_Name_textbox4.Text
				$newNameBuildingBlocks = $newNameBuildingBlocks -replace (' ', '')
				$buildingblocks_Name_textbox4.Text = $newNameBuildingBlocks
				$buildingblocks_output_textbox5.Text = "Building Block Name: $newNameBuildingBlocks"
				$buildingblocks_output_textbox5.AppendText("  `r`n")
				$BuildingBlocksSystemLocation = $config_buildingblockspath + '\' + $newNameBuildingBlocks + "\System"
				$BuildingBlocksSystemLocation = $BuildingBlocksSystemLocation -replace ("\\", "\")
				$BuildingBlocksUserLocation = $config_buildingblockspath + '\' + $newNameBuildingBlocks + "\User" + "\BuildingBlocksData"
				$BuildingBlocksUserLocation = $BuildingBlocksUserLocation -replace ("\\", "\")
				$buildingBlockFolder = $config_buildingblockspath + '\' + $newNameBuildingBlocks
				$buildingBlockFolder = $buildingBlockFolder -replace ("\\", "\")
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show("IntunePrepTool may temporarily become unresponsive while creating the building blocks.", 'Please wait while the building block(s) are being created.') # Casting the method to [void] suppresses the output.
				$is = 1;
				$iu = 1;
				
				
				
				if ($BuildingBlocksTable -notlike $null)
				{
					
					foreach ($r in $BuildingBlocksTable)
					{
						$BuildingBlocksFilesAndFolders = @'
$sort = "!!sort!!"
$source = "!!source!!"
$destination = "!!destination!!"
$skip = "!!skip!!"
$overwrite = "!!overwrite!!"
#Replace when needed
$destination = $destination -replace("%USERPROFILE%", $env:USERPROFILE)
$destination = $destination -replace("%APPDATA%", $env:APPDATA)
$destination = $destination -replace("%LOCALAPPDATA%", $env:LOCALAPPDATA)
Set-Location $PSScriptRoot

if (($skip -eq $true) -and ($overwrite -eq $true))
{
	Write-Host "Overwrite takes precedence over skip."
	$skip = $false
}

if (($skip -eq $false) -and ($overwrite -eq $false))
{
	Write-Host "No Skip or Overwrite selected; Overwrite takes precedence over skip."
	$overwrite = $true
}

if ($overwrite -eq $true)
{
	if ($sort -like 'folder')
	{
		if (-not (Test-Path $destination))
		{
			New-Item -ItemType Directory -Path $destination | Out-Null
		}
		Get-ChildItem -Path "Data" -Recurse | ForEach-Object {
			$targetPath = Join-Path $destination $_.FullName.Substring((Get-Item "Data").FullName.Length)
			
			if ($_.PSIsContainer)
			{
				if (-not (Test-Path $targetPath))
				{
					New-Item -ItemType Directory -Path $targetPath | Out-Null
				}
			}
			else
			{
				try
				{
					Copy-Item $_.FullName -Destination $targetPath -Force -ErrorAction Stop
					$fn = $_.FullName
					Write-Host "Copy from $fn to  $targetPath done!"
				}
				catch
				{
					$fn = $_.FullName
					Write-Error "Copy from $fn to  $targetPath failed!"
				}
				
			}
		}
	}
	
	if ($sort -like 'file')
	{
		$parentfolder = Split-Path $destination -Parent
		if (-not (Test-Path $parentfolder))
		{
			New-Item -ItemType Directory -Path $parentfolder | Out-Null
		}
		try
		{
			Copy-Item $source -Destination $destination -Force -ErrorAction Stop
			Write-Host "Copy from $source to  $destination done!"
		}
		catch
		{
			Write-Error "Copy from $source to  $destination failed!"
		}
		
	}
}

if ($skip -eq $true)
{
	if ($sort -like 'folder')
	{
		if (-not (Test-Path $destination))
		{
			New-Item -ItemType Directory -Path $destination | Out-Null
		}
		Get-ChildItem -Path "Data" -Recurse | ForEach-Object {
			$targetPath = Join-Path $destination $_.FullName.Substring((Get-Item "Data").FullName.Length)
			
			if ($_.PSIsContainer)
			{
				if (-not (Test-Path $targetPath))
				{
					New-Item -ItemType Directory -Path $targetPath | Out-Null
				}
			}
			else
			{
				if (-not (Test-Path $targetPath))
				{
					try
					{
						Copy-Item $_.FullName -Destination $targetPath -ErrorAction Stop
						$fn = $_.FullName
						Write-Host "Copy from $fn to $targetPath done!"
					}
					catch
					{
						Write-Error "Copy from $fn to $targetPath failed!"
					}
					
				}
			}
		}
	}
	
	if ($sort -like 'file')
	{
		$parentfolder = Split-Path $destination -Parent
		if (-not (Test-Path $parentfolder))
		{
			New-Item -ItemType Directory -Path $parentfolder | Out-Null
		}
		if (-not (Test-Path $destination))
		{
			try
			{
				Copy-Item $source -Destination $destination -ErrorAction Stop
				Write-Host "Copy from $source to $destination done!"
			}
			catch
			{
				Write-Host "Copy from $source to $destination failed!"
			}
			
		}
	}
}
'@
						$BuildingBlocksFilesAndFoldersUninstall = @'
$sort = "!!sort!!"
$destination = "!!destination!!"
#Replace when needed
$destination = $destination -replace("%USERPROFILE%", $env:USERPROFILE)
$destination = $destination -replace("%APPDATA%", $env:APPDATA)
$destination = $destination -replace("%LOCALAPPDATA%", $env:LOCALAPPDATA)
Set-Location $PSScriptRoot
if ($sort -like 'folder') {
remove-item $destination -recurse -confirm:$false -force
}
if ($sort -like 'file') {
remove-item $destination -confirm:$false -force
}
write-host "Uninstall file or folder action done!"
'@
						
						if ($r["Context"] -like 'system')
						{
							$bbSystemContext = $true
							$buildingblocks_output_textbox5.AppendText('File or folder actions in the system context will now be added.')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\data"
							$BuildingBlocksISLocation = $BuildingBlocksISLocation -replace ("\\", "\")
							
							if (!(test-Path $BuildingBlocksISLocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksISLocation
							}
							$sourceIs = $($r["Source"])
							$sourceIs = $sourceIs -replace ("\\", "\")
							$sort = $r["Sort"]
							$source = $r["Source"]
							if ($sort -like 'file')
							{
								$newsourcevar = $source.Split('\')[-1]
								$newsourcevar = "Data\$newsourcevar"
							}
							if ($sort -like 'folder')
							{
								$newsourcevar = "Data\*"
								
							}
							$buildingblocks_output_textbox5.AppendText("Data is being copied to the Building Blocks location.`r`n")
							if ($sort -like 'file')
							{
								$sourcefilename = $sourceIs.Split('\')[-1]
								$dest = $BuildingBlocksISLocation + "\$sourcefilename"
								Copy-Item $sourceIs -Destination $dest
							}
							if ($sort -like 'folder')
							{
								Write-Host "Copy $sourceIs to $BuildingBlocksISLocation"
								Copy-Item "$sourceIs\*" -Destination "$BuildingBlocksISLocation" -Recurse -Container
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!source!!", $newsourcevar)
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!skip!!", $r["Skip"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!overwrite!!", $r["Overwrite"])
							$instfile = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\i.ps1"
							
							$BuildingBlocksFilesAndFolders | Out-File $instfile -force
							if ($r["Uninstall"] -like $true)
							{
								$uninstfile = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\u.ps1"
								$BuildingBlocksFilesAndFoldersUninstall | Out-File $uninstfile -force
							}
							
							$is = $is + 1
						}
						if ($r["Context"] -like 'user')
						{
							$bbUserContext = $true;
							$buildingblocks_output_textbox5.AppendText('File or folder actions in the user context will now be added.')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							$BuildingBlocksIULocation = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\data"
							if (!(test-Path $BuildingBlocksIULocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksIULocation
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$sourceIu = $($r["Source"])
							$sort = $r["Sort"]
							$source = $r["Source"]
							if ($sort -like 'file')
							{
								$newsourcevar = $source.Split('\')[-1]
								$newsourcevar = "Data\$newsourcevar"
							}
							if ($sort -like 'folder')
							{
								$newsourcevar = "Data\*"
								
							}
							$buildingblocks_output_textbox5.AppendText("Data is being copied to the Building Blocks location.`r`n")
							
							if ($sort -like 'file')
							{
								$sourcefilename = $sourceIu.Split('\')[-1]
								$dest = $BuildingBlocksIULocation + "\$sourcefilename"
								Copy-Item $sourceIu -Destination $dest
							}
							if ($sort -like 'folder')
							{
								Copy-Item "$sourceIU\*" -Destination $BuildingBlocksIULocation -Recurse
								
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!source!!", $newsourcevar)
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!skip!!", $r["Skip"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!overwrite!!", $r["Overwrite"])
							$instfile = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\i.ps1"
							$BuildingBlocksFilesAndFolders | Out-File $instfile -force
							if ($r["Uninstall"] -like $true)
							{
								$uninstfile = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\u.ps1"
								$BuildingBlocksFilesAndFoldersUninstall | Out-File $uninstfile -force
							}
							
							
							$iu = $iu + 1
						}
						
					}
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No file or folder activity detected.")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				if ($BuildingBlocksTable3 -notlike $null)
				{
					foreach ($r3 in $BuildingBlocksTable3)
					{
						
						$BuildingBlockRegistryScript = @'
Set-Location $PSScriptRoot
$regfilename = "!!regfilename!!"
if (Test-Path $regfilename) {
    $output = reg import $regfilename /reg:64 2>&1
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Registry Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Registry Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
'@
						$is = 1;
						$iu = 1;
						if ($r3["Context"] -like 'system')
						{
							$bbSystemContext = $true
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\Registry$is"
							$sourceReg = $($r3["Source"])
							if (!(test-Path $BuildingBlocksISLocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksISLocation
							}
							$buildingblocks_output_textbox5.AppendText('Registry file is now being copied to Building Block Location')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							try
							{
								Copy-Item $sourceReg -Destination "$BuildingBlocksISLocation\hklm.reg" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks done!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks failed!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$BuildingBlockRegistryScript = $BuildingBlockRegistryScript -replace ("!!regfilename!!", 'hklm.reg')
							try
							{
								$BuildingBlockRegistryScript | Out-File "$BuildingBlocksISLocation\i.ps1" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("i.ps1 created!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("failed to create i.ps1")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							
							$is = $is + 1
						}
						if ($r3["Context"] -like 'user')
						{
							$bbUserContext = $true
							$BuildingBlocksIULocation = $BuildingBlocksUserLocation + "\Registry$iu"
							$sourceReg = $($r3["Source"])
							if (!(test-Path $BuildingBlocksIULocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksIULocation
							}
							try
							{
								Copy-Item $sourceReg -Destination "$BuildingBlocksIULocation\hkcu.reg" -force
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks done!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks failed!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$BuildingBlockRegistryScript = $BuildingBlockRegistryScript -replace ("!!regfilename!!", 'hkcu.reg')
							try
							{
								$BuildingBlockRegistryScript | Out-File "$BuildingBlocksIULocation\i.ps1" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("i.ps1 created!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("failed to create i.ps1")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$iu = $iu + 1
						}
						
						
						
						
					}
					$buildingblocks_output_textbox5.AppendText("Registry done")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No Registry actions found")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				if ($BuildingBlocksTable2 -ne $Null)
				{
					$i = 1;
					foreach ($r2 in $BuildingBlocksTable2)
					{
						$BuildingBlockShortcutScript = @'	
$Context = "!!context!!"
$Name = "!!name!!"
$TargetLocation = "!!targetlocation!!"
$Arguments = "!!arguments!!"
$ICOFile = "!!icofile!!" ; $ICOFile = $ICOFile + ".ico"
$Subfolder = "!!subfolder!!"
$Desktop = "!!desktop!!"
$StartMenu = "!!startmenu!!"

Set-Location $PSScriptRoot
if ($Context -like 'user') {
    $folderPath = Join-Path $env:AppData "IntunePrepTool\ICONS"
    if (-not (Test-Path $folderPath)) {
        New-Item -ItemType Directory -Path $folderPath -Force | Out-Null
    }
    $destinationFile = Join-Path $folderPath (Split-Path $ICOFile -Leaf)
    Copy-Item -Path $ICOFile -Destination $destinationFile -Force
}
elseif ($Context -like 'system') {
    $folderPath = Join-Path $env:ProgramData "IntunePrepTool\ICONS"
    if (-not (Test-Path $folderPath)) {
        New-Item -ItemType Directory -Path $folderPath -Force | Out-Null
    }
    $destinationFile = Join-Path $folderPath (Split-Path $ICOFile -Leaf)
    Copy-Item -Path $ICOFile -Destination $destinationFile -Force
}


function fCreateShortcut
{
    <#
    .SYNOPSIS
    Creates a shortcut in the Desktop and/or Start Menu, for user or system context.

    .PARAMETER TargetFile
    The path to the executable or file the shortcut should point to.

    .PARAMETER ShortcutName
    The name of the shortcut (without .lnk extension).

    .PARAMETER Icon
    (Optional) Path to the icon file.

    .PARAMETER ShortcutArguments
    (Optional) Arguments to pass to the target.

    .PARAMETER Location
    One or more of 'Desktop' and/or 'StartMenu'.

    .PARAMETER Scope
    'User' or 'System' (default is 'User').

    .PARAMETER Subfolder
    (Optional) Subfolder within the Desktop or Start Menu path.
    #>
	
	param (
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[Parameter(Mandatory = $true)]
		[string]$ShortcutName,
		[string]$Icon = "",
		[string]$ShortcutArguments = "",
		[Parameter(Mandatory = $true)]
		[ValidateSet("Desktop", "StartMenu")]
		[string[]]$Location,
		[ValidateSet("User", "System")]
		[string]$Scope = "User",
		[string]$Subfolder = ""
	)
	
	$WorkingDir = Split-Path -Path $TargetFile -Parent
	
	foreach ($loc in $Location)
	{
		switch ($Scope)
		{
			'User' {
				$BasePath = switch ($loc)
				{
					'Desktop'   { [Environment]::GetFolderPath("Desktop") }
					'StartMenu' { [Environment]::GetFolderPath("StartMenu") }
				}
			}
			'System' {
				$BasePath = switch ($loc)
				{
					'Desktop'   { "$env:PUBLIC\Desktop" }
					'StartMenu' { "$env:ProgramData\Microsoft\Windows\Start Menu\Programs" }
				}
			}
		}
		
		$FullPath = if ($Subfolder)
		{
			Join-Path -Path $BasePath -ChildPath $Subfolder
		}
		else
		{
			$BasePath
		}
		if (-not (Test-Path $FullPath))
		{
			New-Item -Path $FullPath -ItemType Directory -Force | Out-Null
		}
		$ShortcutPath = Join-Path -Path $FullPath -ChildPath "$ShortcutName.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutPath)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.WorkingDirectory = $WorkingDir
		if ($Icon)
		{
			$Shortcut.IconLocation = $Icon
		}
		if ($ShortcutArguments)
		{
			$Shortcut.Arguments = $ShortcutArguments
		}
		$Shortcut.Save()
	}
}

if ($Desktop -like 'true') {
    fCreateShortcut -TargetFile $TargetLocation `
                    -Scope $Context `
                    -ShortcutName $Name `
                    -Location Desktop `
                    -Icon $destinationFile `
                    -ShortcutArguments $Arguments `
                    -Subfolder $Subfolder
Write-Host "Shortcut created successfully in: Desktop"
}

if ($StartMenu -like 'true') {
    fCreateShortcut -TargetFile $TargetLocation `
                    -Scope $Context `
                    -ShortcutName $Name `
                    -Location StartMenu `
                    -Icon $destinationFile `
                    -ShortcutArguments $Arguments

}
Write-Host "Shortcut created successfully in: Startmenu"
'@
						$BuildingBlockUninstallShortcutScript = @'	
$Context = "!!context!!"
$Name = "!!name!!"
$TargetLocation = "!!targetlocation!!"
$Arguments = "!!arguments!!"
$ICOFile = "!!icofile!!" ; $ICOFile = $ICOFile + ".ico"
$Subfolder = "!!subfolder!!"
$Desktop = "!!desktop!!"
$StartMenu = "!!startmenu!!"

Set-Location $PSScriptRoot

$Locations = @()
if ($Desktop)   { $Locations += 'Desktop' }
if ($StartMenu) { $Locations += 'StartMenu' }

foreach ($loc in $Locations)
{
    switch ($Context) {
        'User' {
            $BasePath = switch ($loc) {
                'Desktop'   { [Environment]::GetFolderPath('Desktop') }
                'StartMenu' { [Environment]::GetFolderPath('StartMenu') }
            }
        }
        'System' {
            $BasePath = switch ($loc) {
                'Desktop'   { Join-Path $env:Public 'Desktop' }
                'StartMenu' { Join-Path $env:ProgramData 'Microsoft\Windows\Start Menu\Programs' }
            }
        }
    }
    $FullPath = if ($Subfolder) {
        Join-Path -Path $BasePath -ChildPath $Subfolder
    }
    else {
        $BasePath
    }
    $ShortcutPath = Join-Path -Path $FullPath -ChildPath ("$Name.lnk")
    if (Test-Path $ShortcutPath) {
        Remove-Item $ShortcutPath -Force
        Write-Host "Removed shortcut: $ShortcutPath"
    }
    if ((Test-Path $FullPath) -and !(Get-ChildItem -Path $FullPath -Force)) {
        Remove-Item $FullPath -Force
        Write-Host "Removed empty folder: $FullPath"
    }
}
if ($ICOFile)
{
    if ($Context -like 'user') {
        $iconFolderPath = Join-Path $env:AppData ".IntunePrepTool\ICONS"
    }
    elseif ($Context -like 'system') {
        $iconFolderPath = Join-Path $env:ProgramData ".IntunePrepTool\ICONS"
    }
    $destinationFile = Join-Path $iconFolderPath (Split-Path $ICOFile -Leaf)
    if (Test-Path $destinationFile) {
        Remove-Item $destinationFile -Force
        Write-Host "Removed icon: $destinationFile"
    }
}

Write-Host "`nUninstall script completed."
'@
						
						
						
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!context!!", $r2["Context"])
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!context!!", $r2["Context"])
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!name!!", $($r2["Name"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!name!!", $($r2["Name"]))
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!targetlocation!!", $($r2["Target location"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!targetlocation!!", $($r2["Target location"]))
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!arguments!!", $($r2["Arguments"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!arguments!!", $($r2["Arguments"]))
						
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!subfolder!!", $($r2["Subfolder"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!subfolder!!", $($r2["Subfolder"]))
						if ($r2["Desktop"] -like 'true')
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!desktop!!", $true)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!desktop!!", $true)
						}
						else
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!desktop!!", $false)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!desktop!!", $false)
						}
						if ($r2["Startmenu"] -like 'true')
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!startmenu!!", $true)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!startmenu!!", $true)
						}
						else
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!startmenu!!", $false)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!startmenu!!", $false)
						}
						if ($r2["Context"] -like 'system')
						{
							$bbSystemContext = $true;
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\BuildingBlocksData" + "\shortcut$i"
						}
						if ($r2["Context"] -like 'user')
						{
							$bbUserContext = $true;
							$BuildingBlocksISLocation = $BuildingBlocksUserLocation + "\shortcut$i"
						}
						
						
						if (!(test-Path $BuildingBlocksISLocation))
						{
							New-Item -ItemType Directory -Path $BuildingBlocksISLocation
						}
						$icoName = -join (
							(97 .. 122) |
							Get-Random -Count 6 |
							ForEach-Object { [char]$_ }
						)
						$icoName = 'shortcut-' + $icoName
						$buildingblocks_output_textbox5.AppendText("Shortcut actions found!")
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						Copy-Item $($r2["ICO File"]) "$BuildingBlocksISLocation\$icoName.ico" -Force
						$buildingblocks_output_textbox5.AppendText('The ICO file (shortcut) is now being copied to the Building Block location.')
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!icofile!!", $icoName)
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!icofile!!", $icoName)
						$buildingblocks_output_textbox5.AppendText('Scripts (shortcuts) are now being copied to the Building Block location.')
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						$BuildingBlockShortcutScript | Out-File "$BuildingBlocksISLocation\i.ps1" -Force
						$BuildingBlockUninstallShortcutScript | Out-File "$BuildingBlocksISLocation\u.ps1" -Force
						$buildingblocks_output_textbox5.AppendText("done!")
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						
						
						
						
						$i = $i + 1
					}
					
					
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No Shortcut actions found")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				
				
				$buildingblocks_output_textbox5.AppendText("Building Blocks created: $buildingBlockFolder")
				$buildingblocks_output_textbox5.AppendText("  `r`n")
				#$buildingBlocks_panel85.Enabled = $true;
				if ($bbUserContext -like $true)
				{
					$userContext_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!" ; $version = $version + "user"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextInstall_$appname$version.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 

	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\i.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
		
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1 }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
					$userContext_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!" ; $version = $version + "user"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextUninstall_$appname$version.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
	
	
}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1 }
else { remove-item $regkeyApp; exit 0 }
'@
					$buildingblocks_output_textbox5.AppendText("`Generating install and uninstall powershell scripts for the User Context Package...`r`n")
					$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
					$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
					$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
					$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
					$appname = $buildingblocks_Name_textbox4.text
					$appversion = $buildingblocks_version_textbox3.Text
					$RegisterDetectionroot = "Intune_" + $config_customername
					$userContext_installFile = $userContext_installFile.Replace('!!AppName!!', "$appname")
					$userContext_installFile = $userContext_installFile.Replace('!!logdir!!', $config_logfoldertarget)
					$userContext_installFile = $userContext_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
					$userContext_installFile = $userContext_installFile.Replace('!!version!!', $appversion)
					$userContext_installFile | Out-File "$config_buildingblockspath\$appname\User\install.ps1" -Force
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!AppName!!', "$appname")
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!version!!', $appversion)
					$userContext_uninstallFile | Out-File "$config_buildingblockspath\$appname\User\uninstall.ps1" -Force
					$buildingblocks_output_textbox5.AppendText("`install.ps1 and uninstall.ps1 created! `r`n")
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show(
						'The IntunePrepTool will not respond until packaging is complete. Large packages may take several minutes. Please wait.',
						'Creating User Context Package'
					) # Casting the method to [void] suppresses the output. 
					if (!(Test-Path "$config_buildingblockspath\$appname\output-UserContext\"))
					{
						mkdir "$config_buildingblockspath\$appname\output-UserContext\" -Force
					}
					
					
					& .\IntuneWinAppUtil.exe -c "$config_buildingblockspath\$appname\User\" -s "$config_buildingblockspath\$appname\User\install.ps1" -o "$config_buildingblockspath\$appname\output-UserContext\" -q
					Rename-Item -Path "$config_buildingblockspath\$appname\output-UserContext\install.intunewin" -NewName "$config_buildingblockspath\$appname\output-UserContext\$appname.intunewin"
					$buildingblocks_output_textbox5.AppendText("`nIntunewin file created: `r`n")
					$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-UserContext\$appname.intunewin")
					$buildingblocks_output_textbox5.AppendText("`r`n")
					
					$context = 'user'
					$icmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File install.ps1"
					$ucmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File uninstall.ps1"
					$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
					$regkeyApp = "$regkeyRoot$appname"
					$usercontextVersion = $appversion + "user"
					$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
							IntuneWinFile = "$appname.intunewin"
							DisplayName   = $appname
							Publisher	  = $config_customername
							AppVersion    = $usercontextVersion;
							reglocation   = $regkeyApp
							regValue	  = 'Version'
							installCMD    = $icmd
							uninstallCMD  = $ucmd
							context	      = $context
						})
					$IntuneWinPackageConfig | Export-Csv "$config_buildingblockspath\$appname\output-UserContext\config.csv" -NoTypeInformation
					$buildingblocks_output_textbox5.AppendText("`Config.csv created: `r`n")
					$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-UserContext\config.csv")
					$buildingblocks_output_textbox5.AppendText("`r`n")
					if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
					{
						if ($bbSystemContext -like $false)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $false
									usercontext				     = $true
									systemcontextconfig		     = $null;
									systembuildingblockslocation = $null;
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv";
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
							
						}
						
					}
					else
					{
						if ($bbSystemContext -like $false)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $false
									systemcontext			     = $false
									usercontext				     = $true
									systemcontextconfig		     = $null;
									systembuildingblockslocation = $null;
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv";
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Building Blocks - Standalone Package Info')
							
						}
					}
					
				}
				if ($bbSystemContext -like $true)
				{
					$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
					$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
					$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
					$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
					$appname = $buildingblocks_Name_textbox4.text
					$appversion = $buildingblocks_version_textbox3.Text
					
					if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
					{
						if ($bbUserContext -like $true)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $true
									usercontext				     = $true
									systemcontextconfig		     = $null
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv"
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
						}
						else
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $true
									usercontext				     = $false
									systemcontextconfig		     = $null;
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig		     = $null;
									userbuildingblockslocation   = $null;
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
						}
					}
					else
					{
						
						
						$systemContext_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksSystemContextInstall_$appname$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 

	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\i.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
		
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1 }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
						$systemContext_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextUninstall_$appname$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
	
	
}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1 }
else { remove-item $regkeyApp; exit 0 }
'@
						$buildingblocks_output_textbox5.AppendText("`Generating install and uninstall powershell scripts for the System Context Package...`r`n")
						$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
						$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
						$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
						$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
						$appname = $buildingblocks_Name_textbox4.text
						$appversion = $buildingblocks_version_textbox3.Text
						$RegisterDetectionroot = "Intune_" + $config_customername
						$systemContext_installFile = $systemContext_installFile.Replace('!!AppName!!', "$appname")
						$systemContext_installFile = $systemContext_installFile.Replace('!!logdir!!', $config_logfoldertarget)
						$systemContext_installFile = $systemContext_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
						$systemContext_installFile = $systemContext_installFile.Replace('!!version!!', $appversion)
						$systemContext_installFile | Out-File "$config_buildingblockspath\$appname\System\install.ps1" -Force
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!AppName!!', "$appname")
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!version!!', $appversion)
						$systemContext_uninstallFile | Out-File "$config_buildingblockspath\$appname\System\uninstall.ps1" -Force
						$buildingblocks_output_textbox5.AppendText("`install.ps1 and uninstall.ps1 created! `r`n")
						#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
						[void][System.Windows.Forms.MessageBox]::Show(
							'The IntunePrepTool will not respond until packaging is complete. Large packages may take several minutes. Please wait.',
							'Creating System Context Package'
						) # Casting the method to [void] suppresses the output. 
						if (!(Test-Path "$config_buildingblockspath\$appname\output-SystemContext\"))
						{
							mkdir "$config_buildingblockspath\$appname\output-SystemContext\" -Force
						}
						
						
						& .\IntuneWinAppUtil.exe -c "$config_buildingblockspath\$appname\System\" -s "$config_buildingblockspath\$appname\System\install.ps1" -o "$config_buildingblockspath\$appname\output-SystemContext\" -q
						Rename-Item -Path "$config_buildingblockspath\$appname\output-SystemContext\install.intunewin" -NewName "$config_buildingblockspath\$appname\output-SystemContext\$appname.intunewin"
						$buildingblocks_output_textbox5.AppendText("`nIntunewin file created: `r`n")
						$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-SystemContext\$appname.intunewin")
						$buildingblocks_output_textbox5.AppendText("`r`n")
						
						$context = 'system'
						$icmd = "powershell -executionpolicy bypass -file install.ps1"
						$ucmd = "powershell -executionpolicy bypass -file uninstall.ps1"
						$regkeyRoot = "HKEY_LOCAL_MACHINE\Software\$RegisterDetectionroot\"
						$regkeyApp = "$regkeyRoot$appname"
						$IntuneWinPackageConfig = $null;
						$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
								IntuneWinFile = "$appname.intunewin"
								DisplayName   = $appname
								Publisher	  = $config_customername
								AppVersion    = $appversion;
								reglocation   = $regkeyApp
								regValue	  = 'Version'
								installCMD    = $icmd
								uninstallCMD  = $ucmd
								context	      = $context
							})
						$IntuneWinPackageConfig | Export-Csv "$config_buildingblockspath\$appname\output-SystemContext\config.csv" -NoTypeInformation
						$buildingblocks_output_textbox5.AppendText("`Config.csv created: `r`n")
						$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-SystemContext\config.csv")
						$buildingblocks_output_textbox5.AppendText("`r`n")
						
						if ($bbUserContext -like $true)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress   = $false
									systemcontext	    = $true
									usercontext		    = $true
									systemcontextconfig = "$config_buildingblockspath\$appname\output-SystemContext\config.csv"
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig   = "$config_buildingblockspath\$appname\output-UserContext\config.csv"
									userbuildingblockslocation = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Building Blocks - Standalone Package Info')
						}
						else
						{
							
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress   = $false
									systemcontext	    = $true
									usercontext		    = $false
									systemcontextconfig = "$config_buildingblockspath\$appname\output-SystemContext\config.csv"
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig   = $null
									userbuildingblockslocation = $null;
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - Standalone Package Info')
							
						}
					}
				}
				
			}
		}
	}
	
	
}

$buildingblocks_Name_textbox4_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		
	}
}

$config_buildingBlocksBrowse_button1_Click={
	#TODO: Place custom script here
	if ($config_buildingBlcoks_folderbrowsermoderndialog3.ShowDialog() -eq 'OK')
	{
		$config_buildingblocks_textbox3.Text = $config_buildingBlcoks_folderbrowsermoderndialog3.SelectedPath
	}
}

$config_install_orca_buttonInstallOrcaPowershel_Click={
	#TODO: Place custom script here
$installOrca = @'



[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
$WinSDKSetup = "C:\windows\Temp\winsdksetup.exe"
try {
Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/?linkid=2313119" -OutFile $WinSDKSetup -ErrorAction Stop
Write-Host "Downloaded winsdksetup.exe to $WinSDKSetup"
}
catch {
Write-Error "Failed downloading winsdksetup.exe"
}

$exeParameters = '/layout "C:\Program Files\IntunePrepTool" /q /features OptionId.MSIInstallTools /quiet /norestart'

try
{
	Start-Process -FilePath $WinSDKSetup -ArgumentList $exeParameters -Wait -NoNewWindow -ErrorAction Stop
	write-host "Installation completed of $WinSDKSetup" -ForegroundColor Green
	
	
}
catch
{
	write-host "Error executing "C:\windows\Temp\winsdksetup.exe"" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	
	
}

try
{
	$startPMSI = Start-Process msiexec.exe `
    -ArgumentList '/i', '"C:\Program Files\IntunePrepTool\Installers\Orca-x86_en-us.msi"', '/qn', '/l*v', '"C:\Windows\Temp\OrcaMSI.txt"' `
    -Wait `
    -NoNewWindow `
    -ErrorAction Stop

	write-host $startPMSI
	$msilog = get-content 'c:\windows\temp\OrcaMSI.txt'
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Install done!" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green

	}
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content 'c:\windows\temp\OrcaMSI.txt'
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
}
write-host "Cleaning temp install files now" -ForegroundColor Green
Remove-Item $WinSDKSetup -Confirm:$false
Remove-Item -Path "C:\Program Files\IntunePrepTool\Installers" -Recurse -Force -Confirm:$false
Remove-Item  "C:\Windows\Temp\OrcaMSI.txt" -Confirm:$false

'@

	
	if (!(Test-Path "c:\program files\IntunePrepTool\installOrca.ps1" -PathType Leaf))
	{
		$installOrca  | Out-File "c:\program files\IntunePrepTool\installOrca.ps1"
	}
	else
	{
		Remove-Item -Path "c:\program files\IntunePrepTool\installOrca.ps1" -Confirm:$false -Force
		$installOrca | Out-File "c:\program files\IntunePrepTool\installOrca.ps1"
	}
	
	powershell_ise -file "c:\program files\IntunePrepTool\installOrca.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$msi_open_Orca_button1_Click={
	#TODO: Place custom script here
	if (Test-Path "C:\Program Files (x86)\Orca\Orca.exe" -Type Leaf)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		$MSINewname = $msi_openfiledialog1.FileName
		$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
		$MSINewname = $MSINewname.Replace(" ", "")
		$MSIbestand = "$config_packagefolder\$msipnaam\$msiversie\source\$MSINewname"
		Start-Process "C:\Program Files (x86)\Orca\Orca.exe" -ArgumentList $MSIbestand
	}
	else
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Use the Install Orca (PowerShell_ISE) button in the Start/Config menu.", 'Please install Orca first') # Casting the method to [void] suppresses the output.
		
	}
	
}

$msi_gotobuildingblocks_button2TestInstallPowershe_Click={
	#TODO: Place custom script here
	
}

$msi_buttonOptionalGoToBuilding_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'msi'| Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'msi' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $msi_packagenaam_textbox1.text
	$buildingblocks_version_textbox3.text = $msi_versie_textbox1.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
	
	
}

$msi_addBuildingBlocksSystemContextbutton5CreateIntunewinFile_Click= {
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $msi_packagenaam_textbox1.text
			$PacVersion = $msi_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$MSI_buildigblocks_Package_InProgresstextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			$MSI_buildigblocks_Package_InProgresstextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
		}
	}
}

$bb_gobackToPackageInProgress_button1_Click={
	#TODO: Place custom script here
	if (!(Test-Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Type Leaf))
	{
		
	}
	else
	{
		$BBWheretoGoBack = get-content 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt'
		if ($BBWheretoGoBack -like 'msi')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $true
			$package_msi_tabcontrol2.Visible = $true
			$package_msi_tabcontrol2.Dock = 'Fill'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'exe')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $true
			$package_exe_tabcontrol2.Visible = $true
			$package_exe_tabcontrol2.Dock = 'Fill'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'msix')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'Fill'
			$MSIX_tabcontrol1.Enabled = $true
			$MSIX_tabcontrol1.Visible = $true
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'choco')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $true
			$tools_chocolatey_tabcontrol1.Visible = $true
			$tools_chocolatey_tabcontrol1.Dock = 'Fill'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'winget')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $true
			$package_winget_tabcontrol2.Visible = $true
			$package_winget_tabcontrol2.Dock = 'Fill'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
	}
	
}

$bb_standalone_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($bb_standalone_radiobutton1.Enabled -eq $true)
	{
		#$bb_usePackageInProgress_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $true
		$buildingblocks_version_textbox3.Enabled = $true
	}
	if ($bb_standalone_radiobutton1.Enabled -eq $false)
	{
		#$bb_usePackageInProgress_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $false
		$buildingblocks_version_textbox3.Enabled = $false
		
	}
	
}

$bb_usePackageInProgress_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($bb_usePackageInProgress_radiobutton1.Enabled -eq $true)
	{
		#$bb_standalone_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $false
		$buildingblocks_version_textbox3.Enabled = $false
		
		
	}
	if ($bb_usePackageInProgress_radiobutton1.Enabled -eq $false)
	{
		#$bb_standalone_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $true
		$buildingblocks_version_textbox3.Enabled = $true
	}
	if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
	{
		if (($buildingblocks_Name_textbox4.Text -like $Null) -or ($buildingblocks_version_textbox3.Text -like $Null))
		{
			[void][System.Windows.Forms.MessageBox]::Show(
				"Please go to your MSI, MSIX, EXE, Chocolatey or Winget package. After testing install, then use the '(Optional) Go to Building Blocks' button",
				"Button '(Optional) Go to Building Blocks' not used!"
			)
		}
	}
	
	
}

$buildingblocks_add_script_buttonAddShotcut_Click={
	#TODO: Place custom script here
	
}

$exe_open_withqquestion_button1_Click={
	#TODO: Place custom script here
	[void][System.Windows.Forms.MessageBox]::Show(
		"If the EXE file supports this, a popup will open with all the install parameters. If the EXE file does not support it, it might launch the setup. In that case, please close it before continuing.",
		'Testing opening EXE file with /?'
	)
	[string]$exe_org_path = $exe_openfiledialog1.FileNames
	Unblock-File -Path $exe_org_path -Confirm:$false
	Start-Process $exe_org_path -ArgumentList '/?' -WindowStyle Normal
	
}

$exe_test_done_button1CreateInstallScript_Click={
	#TODO: Place custom script here
	$exe_preBackupPath64 = Get-Variable -Name exe_preBackupPath64 -ValueOnly -Scope Script
	$exe_preBackupPath32 = Get-Variable -Name exe_preBackupPath32 -ValueOnly -Scope Script
	$backupFolder = "$env:LOCALAPPDATA\temp"
	$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$PostBackupPath64 = Join-Path $backupFolder "PostChanges64_$timeStamp.reg"
	$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$PostBackupPath32 = Join-Path $backupFolder "PostChanges32_$timeStamp.reg"
	$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	reg export "$regExportPath" "$PostBackupPath32" /y | Out-Null
	$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	reg export "$regExportPath" "$PostBackupPath64" /y | Out-Null
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$regDiffFile64 = Join-Path $backupFolder "Difffile64_$timeStamp.reg"
	$regDiffFile32 = Join-Path $backupFolder "Difffile32_$timeStamp.reg"
	function Compare-RegFiles
	{
		param (
			[string]$OldRegPath,
			[string]$NewRegPath,
			[string]$DiffOutPath
		)
		
		$oldLines = [System.IO.File]::ReadAllLines($OldRegPath)
		$newLines = [System.IO.File]::ReadAllLines($NewRegPath)
		$oldHashSet = [System.Collections.Generic.HashSet[string]]::new($oldLines)
		$differences = New-Object System.Collections.Specialized.OrderedDictionary
		$currentKey = $null
		foreach ($line in $newLines)
		{
			if ($line -match '^\[\S+\]$')
			{
				$currentKey = $line
				continue
			}
			if ($line -match '^\S+=' -and $currentKey)
			{
				if (-not $oldHashSet.Contains($line))
				{
					if (-not $differences.Contains($currentKey))
					{
						$differences[$currentKey] = [System.Collections.Generic.List[string]]::new()
					}
					$differences[$currentKey].Add($line)
				}
			}
		}
		if ($differences.Count -gt 0)
		{
			Set-Content -Path $DiffOutPath -Value "Windows Registry Editor Version 5.00`r`n"
			foreach ($key in $differences.Keys)
			{
				Add-Content -Path $DiffOutPath -Value "`r`n$key"
				foreach ($val in $differences[$key])
				{
					Add-Content -Path $DiffOutPath -Value $val
				}
			}
			$DiffOutPath | out-file "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt" -force
		}
		else
		{
			if (Test-Path $DiffOutPath)
			{
				Remove-Item $DiffOutPath -ErrorAction SilentlyContinue
			}
		}
	}
	
	Compare-RegFiles -OldRegPath $exe_preBackupPath64 `
					 -NewRegPath $PostBackupPath64 `
					 -DiffOutPath $regDiffFile64
	
	Compare-RegFiles -OldRegPath $exe_preBackupPath32 `
					 -NewRegPath $PostBackupPath32 `
					 -DiffOutPath $regDiffFile32
	Remove-Item $PostBackupPath64 -Confirm:$false
	Remove-Item $exe_preBackupPath64 -Confirm:$false
	Remove-Item $PostBackupPath32 -Confirm:$false
	Remove-Item $exe_preBackupPath32 -Confirm:$false
	
	foreach ($file in @($regDiffFile64, $regDiffFile32))
	{
		if (Test-Path $file -PathType Leaf)
		{
			$regString = Get-Content $file
			$regInfo = @{ }
			
			foreach ($line in $regString)
			{
				if ($line -match '^\s*\"(?<key>.+?)\"=\"(?<value>.*)\"')
				{
					$regInfo[$matches['key']] = $matches['value']
				}
				elseif ($line -match '^\s*\"(?<key>.+?)\"=dword:(?<value>.+)')
				{
					$regInfo[$matches['key']] = [Convert]::ToInt32($matches['value'], 16)
				}
				elseif ($line -match '^\s*\"(?<key>.+?)\"=(?<value>.+)')
				{
					$regInfo[$matches['key']] = $matches['value'].Trim().Trim('"')
				}
			}
			
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("DisplayName: " + $regInfo["DisplayName"] + "`r`n")
			$exe_output_textbox1.AppendText("DisplayVersion: " + $regInfo["DisplayVersion"] + "`r`n")
			$exe_output_textbox1.AppendText("InstallDate: " + $regInfo["InstallDate"] + "`r`n")
			$exe_output_textbox1.AppendText("UninstallString: " + $regInfo["UninstallString"] + "`r`n")
			$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
			$wattezoeken = $regInfo["DisplayName"]
			$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
			if ($InstallsUninstallString -notlike $null)
			{
				
				foreach ($ius in $InstallsUninstallString)
				{
					$exe_output_textbox1.AppendText("Another possible uninstall string: " + $ius.UninstallString + "`r`n")
					$uninststr = $ius.UninstallString
					if ($uninststr -like '*.exe*') { $exe_uninstall_exe_path_textbox2.Text = $uninststr; $exe_radiobuttonUninstallEXEPath.Checked = $true; $exe_parsUnInstall_textbox1.Text = $exe_parsInstall_textbox1.Text }
					if ($uninststr -like '*{*')
					{
						$newuni = $uninststr.Split("{")[1]
						$newuni = $newuni.Split("}")[0]
						$exe_radiobutton3.Checked = $true
						$MSIXECUninstall = $exe_msiexecuninstall.Text
						$MSIXECUninstall = $MSIXECUninstall -replace ("PlaceProductIDhere", $newuni)
						$exe_msiexecuninstall.Text = $MSIXECUninstall;
					}
				}
			}
			$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
			$wattezoeken = $regInfo["DisplayName"]
			$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
			if ($InstallsUninstallString -notlike $null)
			{
				
				foreach ($ius in $InstallsUninstallString)
				{
					$exe_output_textbox1.AppendText("Another possible uninstall string: " + $ius.UninstallString + "`r`n")
					$uninststr = $ius.UninstallString
					if ($uninststr -like '*.exe*') { $exe_uninstall_exe_path_textbox2.Text = $uninststr; $exe_radiobuttonUninstallEXEPath.Checked = $true; $exe_parsUnInstall_textbox1.Text = $exe_parsInstall_textbox1.Text  }
					if ($uninststr -like '*{*')
					{
						$newuni = $uninststr.Split("{")[1]
						$newuni = $newuni.Split("}")[0]
						$exe_radiobutton3.Checked = $true
						$MSIXECUninstall = $exe_msiexecuninstall.Text
						$MSIXECUninstall = $MSIXECUninstall -replace("PlaceProductIDhere", $newuni)
						$exe_msiexecuninstall.Text = $MSIXECUninstall;
						 }
				}
			}
			
		}
	}
	
	
}

$tablelayoutpanel3_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_buttonOpenReleaseNotesOnIn_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/updates/intunepreptool-release-notes-1-6-8-0/'
}


$exe_gotobuildingblocksButton_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'exe' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'exe' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $exe_packagenaam_textbox1.text
	$buildingblocks_version_textbox3.text = $exe_versie_textbox1.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$tools_choco_gotoBuildingBlocks_Button_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'choco' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'choco' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $tools_choco_displayname_textbox3.text
	$buildingblocks_version_textbox3.text = $tools_choco_appversion_textbox3.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$msix_GotoBuildingBlocks_Button_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'msix' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'msix' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $msix_packagename_textbox3.text
	$buildingblocks_version_textbox3.text = $msix_packageVersion_textbox3.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$winget_gotobuildingBlocks_buttonTestInstallPowershel_Click={
	#TODO: Place custom script here
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'winget' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'winget' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $winget_displayname_textbox1.text
	$buildingblocks_version_textbox3.text = $versie_textbox2.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$exe_addBuildingBlocksCSVButton_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $exe_packagenaam_textbox1.text
			$PacVersion = $exe_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$exe_buildingblockscsv_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
			$exe_buildingblockscsv_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$msix_addBuildingBlokcsCSV_buttonOptionalAddBuildingB_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $msix_packageVersion_textbox3.text
			$PacVersion = $msi_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$msix_buildingblocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
			$msix_buildingblocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$tools_choco_addBuildingBlocksCSVButton_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $tools_choco_displayname_textbox3.text
			$PacVersion = $tools_choco_appversion_textbox3.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$choco_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
			$choco_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$winget_addBuildingBlocksCSVbuttonOptionalAddBuildingB_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $winget_displayname_textbox1.text
			$PacVersion = $versie_textbox2.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$winget_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
			$winget_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$upload_LoadBuildingBlocksg_button1_Click={
	#TODO: Place custom script here
	$upload2_IntuneWinFile_textbox1.Text = $null;
	$upload2_DisplayName_textbox2.Text = $null;
	$upload2_Publisher_textbox1.Text = $null;
	$upload2_AppVersion_textbox1.Text = $null;
	$upload2_reglocation_textbox2.Text = $null;
	$upload2_regValue_textbox1.Text = $null;
	$upload2_installCMD_textbox1.Text = $null;
	$upload2_uninstallCMD_textbox1.Text = $null;
	$upload2_context_textbox1.Text = $null;
	
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		$upload_configLoaded_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		$upload_checkboxSetupAssignmentLikeP.Enabled = $false
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		$systemcsvLOC = $BuildingBlocksCSVContent.systemcontextconfig
		$usercsvLOC = $BuildingBlocksCSVContent.usercontextconfig
		if (($BuildingBlocksCSVContent.usercontext -like $true) -and ($BuildingBlocksCSVContent.systemcontext -like $true))
		{
			$upload_panel2.Enabled = $true
			$upload_panel2.Visible = $true
			$ConfigCSVImport = $null
			$ConfigCSVImport = Import-Csv $systemcsvLOC
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $systemcsvLOC.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload_context_textbox1.Text = $context
			$ConfigCSVImport = $null
			$ConfigCSVImport = Import-Csv $usercsvLOC
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $usercsvLOC.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload2_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload2_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload2_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload2_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload2_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload2_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload2_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload2_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload2_context_textbox1.Text = $context
	
			if (!(test-path "$filepath\Logo.png" -PathType Leaf))
			{
				[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
				$upload_logo_button2.Enabled = $true
				$upload_logo_button2.Visible = $true
				
			}
			
		}
		else
		{
			
			if ($systemcsvLOC -like $null)
			{
				$ConfigCSVImport = $null
				$ConfigCSVImport = Import-Csv $usercsvLOC
				$itwnf = $ConfigCSVImport.IntuneWinFile
				$filepath = $usercsvLOC.TrimEnd("config.csv")
				$itwnffilepath = $filepath + $itwnf
				$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
				
				$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
				$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
				$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
				$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
				$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
				$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
				$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
				if ($ConfigCSVImport.context)
				{
					$context = $ConfigCSVImport.context
				}
				else
				{
					$context = 'system'
				}
				$upload_context_textbox1.Text = $context
				
				if (!(test-path "$filepath\Logo.png" -PathType Leaf))
				{
					[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
					$upload_logo_button2.Enabled = $true
					$upload_logo_button2.Visible = $true
					
				}
			}
			else
			{
				$ConfigCSVImport = $null
				$ConfigCSVImport = Import-Csv $systemcsvLOC
				$itwnf = $ConfigCSVImport.IntuneWinFile
				$filepath = $systemcsvLOC.TrimEnd("config.csv")
				$itwnffilepath = $filepath + $itwnf
				$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
				
				$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
				$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
				$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
				$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
				$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
				$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
				$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
				if ($ConfigCSVImport.context)
				{
					$context = $ConfigCSVImport.context
				}
				else
				{
					$context = 'system'
				}
				$upload_context_textbox1.Text = $context
				
				if (!(test-path "$filepath\Logo.png" -PathType Leaf))
				{
					[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
					$upload_logo_button2.Enabled = $true
					$upload_logo_button2.Visible = $true
					
				}
			}
		
		}
		
		
	}
	
	
	
}

$config_howtoBasicSetup_buttonOpenHowToBasicSetupO_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/basic-setup/'
}

$BB_OpenHowTo_button_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/building-blocks/'
}

$tools_choco_label5_Click={
	#TODO: Place custom script here
	
}

$buttonRefreshTenants_Click={
	#TODO: Place custom script here
	refreshTenants
	refreshTenantsUpload
}


$msi_addDescription_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $msi_packagenaam_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $msi_packagenaam_textbox1.text  -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $msi_versie_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $msi_versie_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$exe_buttonAddCustomPackageDesc_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $exe_packagenaam_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $exe_packagenaam_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $exe_versie_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $exe_versie_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$winget_buttonAddCustomDescription_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $winget_displayname_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $winget_displayname_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $versie_textbox2.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $versie_textbox2.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$msix_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $msix_packagename_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $msix_packagename_textbox3.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $msix_packageVersion_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $msix_packageVersion_textbox3.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$powershell_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $powershell_packagename_textbox.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $powershell_packagename_textbox.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $powershell_packageversion_textbox.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $powershell_packageversion_textbox.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$scheduledtask_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $powershell_package_name_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $powershell_package_name_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $powershell_package_version_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $powershell_package_version_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$tools_choco_buttonOpenPackageDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $tools_choco_displayname_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $tools_choco_displayname_textbox3.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $tools_choco_appversion_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $tools_choco_appversion_textbox3.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$config_tenant_customprivacy_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_tenant_checkboxYes_CheckedChanged={
	#TODO: Place custom script here
	if ($config_tenant_checkboxYes.Checked -eq $true)
	{
		$config_tenant_customprivacy_textbox3.Enabled = $true
	}
	if ($config_tenant_checkboxYes.Checked -eq $false) {
		$config_tenant_customprivacy_textbox3.Text = $null
		$config_tenant_customprivacy_textbox3.Enabled = $false
	}
}

$config_tenant_info_secret_label_Click={
	#TODO: Place custom script here
	
}
]]></Code>
  <TV>0</TV>
  <Bookmarks />
  <BreakPoints>
    <Line Disabled="False">1684</Line>
    <Line Disabled="False">12130</Line>
    <Line Disabled="False">14596</Line>
  </BreakPoints>
  <TracePoints />
  <Mode>1</Mode>
  <Assemblies />
</File>