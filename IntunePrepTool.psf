<File version="3.2">
  <FileID>373d466f-0843-40eb-9006-241e20fcf1fd</FileID>
  <LastExport>133227411031353429</LastExport>
  <Preview>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
Scqv5CMArgMgSVJ+JZ8D4AiAJEn5lbwKwDkAkiTlV/J1ACwDlCQpv5KPAJgASJKUX8knAboOgCRJ
+WUZoCRJbVjyEQDLACVJyq+DCYBlgJIktU/JJwH6OGBJkvIreRmgkwAlScqv5CMAlgFKkpRfyecA
OAIgSVJ+Ja8CcA6AJEn5lTwBsApAkqT8asEEwHUAJEnKLR8HLElSG2YZoCRJbVjyBMAyQEmS8iv5
LQBHACRJyq/kkwD3lgGaAEiSlFPJEwAnAUqSlF8tmABYBihJUm4lXwrYEQBJkvIr+cOAnAMgSVJ+
JS8DtApAkqT8Sj4C4DoAkiTlV/I5AI4ASJKUX8mrAHwcsCRJ+ZU8AbAMUJKk/DIBkCSpDUs+CdBb
AJIk5df+BKDLMkBJktqn5CMAlgFKkpRfPg5YkqQ2LPkkQJcCliQpv5InAD4MSJKk/GrBBMAyQEmS
civ5UsCOAEiSlF/JqwCcAyBJUn75OGBJktqw5CMArgMgSVJ+JZ8D4AiAJEn51YJVAE4ClCQpt1ow
AbAMUJKk3GrBBMARAEmSciv5JEAfByxJUn5ZBihJUhuWfATAMkBJkvLLxwFLktSGJZ8E6FLAkiTl
16sJwERzEwCrACRJyq/kIwCuAyBJUn4lnwPgCIAkSfmVvArAOQCSJOVX8nUALAOUJCm/ko8AmABI
kpRfyScBug6AJEn5lbwMsDgHYGj+QbkjSZKUR7enVuJKZe71JwDPvo242jMc//ofP4qbY8vRWamW
XTmhNzHWaLzZsUbjKWOnjZ/WadudNtZovNmxRuPNjjWq2W0bPfdvYqzReLNjjcZTxhqNH78tdazR
eLNjjcabHWtUs9t67s821mj8+G2pY43Gmx1rNN7sWKOOb3t1cC5+dWM0rnQPxdbn3559AvD4ecRo
9X78z++uRPfgZHT1j5YVJxPcrIyX7ykUFX/vKtofGzg89nL8YGys7tj++MFYvf2e8JjFn3W3PTRW
s+3hn+XI97t3//pjtfut+5infb/7308T+93/3vb32/A5qoyf/Bwdecyjz/3B93vKc3Rkv8ce8/jP
cvz7PfLzHH/MIz9rnefo0HNY9zGb3W+d5+hg23b6/UzY7/73dvzf++Tn6JT9/j/+fh7eb81jNnqO
XnbkZ6mz31Y89wfb1vl+Gz/3p/x+Jj73++O1Yyf/LG/qOWrV7+f+tvXGmnmOTnzuD2970vdb59/7
+H6PP2Zn92BU796PzaffnG0C8IuOX3fs/m/Eyu7XsfNlxMNn35SHD4oefvZN+feDPjs8dmy8+Prw
djVjZ93vyWONxhuOnfA9nfaznGm/J441t9+a7ert9/DYoX+zmv0e+jlrxmr2W/scHdnvscds9LMc
+X048THrfb+n7/dsY29qvyePNRpvOFbz/Z7w+9Cyn6W5/dZsV2+/x8ZO3O+hn7NmrGa/tc/R/lg5
fni7cvyEx6y33xPH6n2/f8n7PXmsZjzxud8ff3M/S3P7rdmu3n6Pje3vd//nOjp21u+3dtv9sfrb
njZ21sc8Or71+YvYfPrHWP7k61j95A+NJwA//fl7Hz39OuL+9pfljEGSJOXb6u4fYmP3q8YTAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAADgRP8HI7JhHSBlJIEAAAAASUVORK5CYII=</Preview>
  <Form>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
pI+gNOQO5QSaKkyb27Sr3iy9HTcIBm5iJ3OgfjGHc/DZwLzLTHwXOAtP8oRDGD9oZdnU2/QPauTR
BT+yFvUu4+PvCWuCqtn8g390iKo6BYrp4Nf0XyyIM075+j+xX2i2V4mH27EMhqU0Or1JuQeG0BSN
ATvjYv5F/0dhLcyUBPhB4XZY6PbK+XzttlW8+ZwUHvWfFaX7drnS+3H1VB5pUkJr3dL8y2RZ71Zn
0jT58Pok0cmPVjov9t5f+3NOVh+m/X6xI/Xl6Wv7pSNpdOdLfK3UOs1iOfVcnkt3t6vqj6tk/jXL
tmt377e0Os58vL4/lBv31VKx1hW4Sm0h5V/qy2Wjx9YfpOmgWC+1eVlsMzLTmtZv1uvZiGVa6kt2
JLwzw88fV2rl90Rq9B74/ouSqk66D1O+e53/+Pp6ndzJhdJUHuVvbjrXuS+6lKr8vlvVmut6rvtV
WL0n7j5fGq8PldX6pZm6KWh1+sdViXtdFz/Wd4/rUpPJllOjceN9tiq8i6mHz/dqY/6eKsxLL3W6
UJ3kn+uZ0dOAad6vnm9mN8Vkr6PkG/mbx+fX0lp8KRZ+XA0eWWn1ynce+Hb3tv3YanXVLFNaiZmP
Qm8t8sUe/8Kt+3O2di/dCjN1UGZyy8fFdNj67PD1x2RpKajv+YnM3pRE7cfVMqlOudyiNul8fNRz
aiJ1Uy5L9Ro/Fm7rfG+iriYP7GN++tq7Gz/zuUH2Ucv2youP+ro/UfMJhVlX78bdSvPm4a5Q/HFV
mxUrA2FdK3I8nWEzt4XObTHXf7wd0NXXSWX0LD8/5pKTa75xfy3Qs1whr2X72fs6w750ag0hlxVv
c+m2cvvUbTReflxJ163MOJetiaMe89WSyuM79uV5OVmsuzef66cCO3hs3Ay4XptJ/C41HlNPJXE0
eL7OTvLT/td1WeJGq9ogz7A0N37S93Td7jbS05eHZYmvK7/TGb42njw0Bjfzytf4/ZZZsamn7mTW
zD3VmyNR/122LPOfz/0nviRwj3y6MV4UG6On/EBYNoUfV+N85osvZlLT14q0bl2vxaFwf19JSR9a
sTK/uZusV6+rRjtZUdh1/ku4fc9+VgtL9rNVKLy8dBKPxZt0YVaZ9NbKzd3dj6v2/H5aW6Zu2eRX
7qGmPOVrL/PF3XWKEW+eblIy3xWz47Yg9F6bz7fz7kRQxOE8P1aV68rkPT8b1UoPr7lSWZndF16Y
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</Form>
  <Code><![CDATA[


class config_customerinfo {
	[string]$customername
	[string]$customPrivacyURL
	[string]$logfoldertarget
	[string]$packagefolder
	[string]$tenanturl
	[string]$downloadpath
	[string]$buildingblockspath
}
function refreshTenants
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$config_treeview3.BeginUpdate()
		$config_treeview3.Refresh()
		$config_treeview3.Nodes.Clear()
		$Root = $config_treeview3.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			
			$node = $Root.Nodes.Add($tenantCSV.customername)
			#$upload_upload_listbox1.Items.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			$node.ContextMenuStrip = $config_tenants_contextmenustrip1
			
		}
		$Root.Expand()
		$config_treeview3.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function refreshTenantsUpload
{
	try
	{
		$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv" -ErrorAction Stop
		$upload_treeview2.BeginUpdate()
		$upload_treeview2.Refresh()
		$upload_treeview2.Nodes.Clear()
		$upload_treeview2.CheckBoxes = $true
		$Root = $upload_treeview2.Nodes.Add("Tenants")
		foreach ($tenantCSV in $TenantsCSV)
		{
			#$upload_treeview2.Nodes.Add($tenantCSV.customername)
			$node = $Root.Nodes.Add($tenantCSV.customername)
			$node.Tag = $tenantCSV.target
			$node.Name = $tenantCSV.customername
			
			
		}
		$Root.Expand()
		$upload_treeview2.EndUpdate()
	}
	catch
	{
		#Please add Tenant
	}
}
function PowershellISEOnTop
{
	Add-Type @"
using System;
using System.Runtime.InteropServices;
public class User32 {
    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);
    
    [DllImport("user32.dll", SetLastError = true)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
    
    public static IntPtr HWND_TOPMOST = new IntPtr(-1);
    public static IntPtr HWND_NOTOPMOST = new IntPtr(-2);
    public const UInt32 SWP_NOSIZE = 0x0001;
    public const UInt32 SWP_NOMOVE = 0x0002;
    public const UInt32 SWP_SHOWWINDOW = 0x0040;
}
"@
	$hwnd = [User32]::FindWindow($null, "Administrator: Windows PowerShell ISE")
	if ($hwnd -ne [IntPtr]::Zero)
	{
		[User32]::SetWindowPos($hwnd, [User32]::HWND_TOPMOST, 0, 0, 0, 0, [User32]::SWP_NOSIZE -bor [User32]::SWP_NOMOVE -bor [User32]::SWP_SHOWWINDOW)
	}
}



$IntunePrepTool_Load = {
	Set-ControlTheme $IntunePrepTool -Theme Dark
	#Set-ControlTheme $config_tabpage -Theme Dark
	$scaledHeight = ConvertTo-ScaledPixel -Form $IntunePrepTool -Height 720
	$scaledWidth = ConvertTo-ScaledPixel -Form $IntunePrepTool -Width 1725
	

	if (!(Test-Path -Path "c:\users\$env:username\.IntunePrepTool"))
	{
		
		New-Item -ItemType Directory -Path "c:\users\$env:username\.IntunePrepTool"
	}
	
	try
	{
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			Copy-Item -Path "C:\Program Files\IntunePrepTool\config_customerinfo.csv" -Destination "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
			Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
			Update-ListBox $update_exe_listbox1 $cis.customername -Append
		}
		
	}
	catch
	{
		
		[void][System.Windows.Forms.MessageBox]::Show('Add customers in the config tab', 'Please Add Customer first')
		
	}
	
	$rechten = [bool](([System.Security.Principal.WindowsIdentity]::GetCurrent()).groups -match "S-1-5-32-544")
	if ($rechten -eq $false)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Admin Rights needed!, Please run as Administrator', 'Please run as Administrator') # Casting the method to [void] suppresses the output. 
		
	}
	else
	{
		$restrictionpolicy = Get-ExecutionPolicy -ErrorAction SilentlyContinue;
		if ($restrictionpolicy -ne 'Unrestricted')
		{
			
			if ([System.Windows.Forms.MessageBox]::Show('Set-ExecutionPolicy Unrestricted?; Please reopen IntunePrepTool', 'Powershell Execution Policy needs to be unrestricted', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	Set-ExecutionPolicy Unrestricted

'@
				if (Test-Path "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1")
				{
					powershell.exe -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
				}
				else
				{
					$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1" -Confirm:$false -Force
					Start-Sleep 1
					powershell -ExecutionPolicy Bypass -file "c:\Program Files\IntunePrepTool\ExecutionPolicyUnrestricted.ps1"
				}
			}
		}
		else
		{
			if (Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf)
			{
				Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
			}
			$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
			if ($ResolveWingetPath)
			{
				$WingetPath = $ResolveWingetPath[-1].Path
			}
			$wingetexe = $ResolveWingetPath
			
			if (Test-path $wingetexe)
			{
				$wingetOption = 1
				$version = & $wingetexe --version
			}
			else
			{
				$wingetOption = 2
				$version = winget --version
			}
			if (($version -notlike 'v1.9*') -and ($version -notlike 'v1.10*') -and ($version -notlike 'v1.11*'))
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use button to Install / Update Winget', 'Winget missing or wrong version')
				
			}
			else
			{
			<#
			if ($wingetOption -like 1)
			{
				& $wingetexe search rink-turksma.IntunePrepTool --accept-source-agreements 2>$null
				$IntunePrepToolversion = & $wingetexe list --id rink-turksma.IntunePrepTool
			}
			else
			{
				winget search rink-turksma.IntunePrepTool --accept-source-agreements
				$IntunePrepToolversion = winget list --id rink-turksma.IntunePrepTool
			}
			Write-Host $IntunePrepToolversion
			if ($IntunePrepToolversion | Select-String '\bVersion\s+Available\b')
			{
				[void][System.Windows.Forms.MessageBox]::Show('Use button on config page to check for updates ', 'New version IntunePrepTool available')
			} #>
			}
			
			
			
			try
			{
				
				Get-ChildItem -Path "IntuneWinAppUtil.exe" -ErrorAction Stop
			}
			catch
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download Microsoft Win32 Content Prep Tool. Place EXE file in same directory as this script', 'IntuneWinAppUtil missing') # Casting the method to [void] suppresses the output. 
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			}
			if (Test-Path 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -PathType Leaf)
			{
				$reqPSModules = Get-Content 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt'
				if ($reqPSModules -like 'false')
				{
					Remove-Item 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Confirm:$false -Force
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
				}
				else
				{
					
				}
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use the button to install required Powershell Modules', 'Powershell module missing or version mismatch') # Casting the method to [void] suppresses the output. 
			}
			
			
			if (!(test-path -path 'C:\ProgramData\chocolatey'))
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please use the Button: "Install Chocolatey"', 'Chocolatey missing') # Casting the method to [void] suppresses the output. 
				
			}
			
			
			refreshTenants
			refreshTenantsUpload
			
			$config_tabpage.Dock = 'Fill'
			$config_tabpage.Visible = $true
			$config_tabpage.Enabled = $true
			
			
			
			
			$BuildingBlocks_datagridview1.DataSource = $BuildingBlocksTable;
			$BuildingBlocks_datagridview2.DataSource = $BuildingBlocksTable2;
			$BuildingBlocks_datagridview3.DataSource = $BuildingBlocksTable3;
			
		}
	}
}





$darkToolStripMenuItem_Click = {
	#TODO: Place custom script here
	Set-ControlTheme -Control $IntunePrepTool -Theme Dark
}

$lightToolStripMenuItem_Click = {
	Set-ControlTheme -Control $IntunePrepTool -Theme Light
}

#region Control Theme Helper Function
<#
	.SYNOPSIS
		Applies a theme to the control and its children.
	
	.PARAMETER Control
		The control to theme. Usually the form itself.
	
	.PARAMETER Theme
		The color theme:
		Light
		Dark

	.PARAMETER CustomColor
		A hashtable that contains the color values.
		Keys:
		WindowColor
		ContainerColor
		BackColor
		ForeColor
		BorderColor
		SelectionForeColor
		SelectionBackColor
		MenuSelectionColor
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -Theme Dark
	
	.EXAMPLE
		PS C:\> Set-ControlTheme -Control $form1 -CustomColor @{ WindowColor = 'White'; ContainerBackColor = 'Gray'; BackColor... }
	.NOTES
		Created by SAPIEN Technologies, Inc.
#>
function Set-ControlTheme
{
	[CmdletBinding()]
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.ComponentModel.Component]$Control,
		[ValidateSet('Light', 'Dark')]
		[string]$Theme = 'Dark',
		[System.Collections.Hashtable]$CustomColor
	)
	
	$Font = [System.Drawing.Font]::New('Segoe UI', 9)
	
	#Initialize the colors
	if ($Theme -eq 'Dark')
	{
		$WindowColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ContainerColor = [System.Drawing.Color]::FromArgb(45, 45, 45)
		$BackColor = [System.Drawing.Color]::FromArgb(32, 32, 32)
		$ForeColor = [System.Drawing.Color]::White
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::DimGray
	}
	else
	{
		$WindowColor = [System.Drawing.Color]::White
		$ContainerColor = [System.Drawing.Color]::WhiteSmoke
		$BackColor = [System.Drawing.Color]::Gainsboro
		$ForeColor = [System.Drawing.Color]::Black
		$BorderColor = [System.Drawing.Color]::DimGray
		$SelectionBackColor = [System.Drawing.SystemColors]::Highlight
		$SelectionForeColor = [System.Drawing.Color]::White
		$MenuSelectionColor = [System.Drawing.Color]::LightSteelBlue
	}
	
	if ($CustomColor)
	{
		#Check and Validate the custom colors:
		$Color = $CustomColor.WindowColor -as [System.Drawing.Color]
		if ($Color) { $WindowColor = $Color }
		$Color = $CustomColor.ContainerColor -as [System.Drawing.Color]
		if ($Color) { $ContainerColor = $Color }
		$Color = $CustomColor.BackColor -as [System.Drawing.Color]
		if ($Color) { $BackColor = $Color }
		$Color = $CustomColor.ForeColor -as [System.Drawing.Color]
		if ($Color) { $ForeColor = $Color }
		$Color = $CustomColor.BorderColor -as [System.Drawing.Color]
		if ($Color) { $BorderColor = $Color }
		$Color = $CustomColor.SelectionBackColor -as [System.Drawing.Color]
		if ($Color) { $SelectionBackColor = $Color }
		$Color = $CustomColor.SelectionForeColor -as [System.Drawing.Color]
		if ($Color) { $SelectionForeColor = $Color }
		$Color = $CustomColor.MenuSelectionColor -as [System.Drawing.Color]
		if ($Color) { $MenuSelectionColor = $Color }
	}
	
	#Define the custom renderer for the menus
	#region Add-Type definition
	try
	{
		[SAPIENTypes.SAPIENColorTable] | Out-Null
	}
	catch
	{
		if ($PSVersionTable.PSVersion.Major -ge 7)
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing', 'System.Drawing.Primitives'
		}
		else
		{
			$Assemblies = 'System.Windows.Forms', 'System.Drawing'
		}
		Add-Type -ReferencedAssemblies $Assemblies -TypeDefinition "
using System;
using System.Windows.Forms;
using System.Drawing;
namespace SAPIENTypes
{
    public class SAPIENColorTable : ProfessionalColorTable
    {
        Color ContainerBackColor;
        Color BackColor;
        Color BorderColor;
		Color SelectBackColor;

        public SAPIENColorTable(Color containerColor, Color backColor, Color borderColor, Color selectBackColor)
        {
            ContainerBackColor = containerColor;
            BackColor = backColor;
            BorderColor = borderColor;
			SelectBackColor = selectBackColor;
        } 
		public override Color MenuStripGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuStripGradientEnd { get { return ContainerBackColor; } }
        public override Color ToolStripBorder { get { return BorderColor; } }
        public override Color MenuItemBorder { get { return SelectBackColor; } }
        public override Color MenuItemSelected { get { return SelectBackColor; } }
        public override Color SeparatorDark { get { return BorderColor; } }
        public override Color ToolStripDropDownBackground { get { return BackColor; } }
        public override Color MenuBorder { get { return BorderColor; } }
        public override Color MenuItemSelectedGradientBegin { get { return SelectBackColor; } }
        public override Color MenuItemSelectedGradientEnd { get { return SelectBackColor; } }      
        public override Color MenuItemPressedGradientBegin { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientEnd { get { return ContainerBackColor; } }
        public override Color MenuItemPressedGradientMiddle { get { return ContainerBackColor; } }
        public override Color ImageMarginGradientBegin { get { return BackColor; } }
        public override Color ImageMarginGradientEnd { get { return BackColor; } }
        public override Color ImageMarginGradientMiddle { get { return BackColor; } }
    }
}"
	}
	#endregion
	
	$colorTable = New-Object SAPIENTypes.SAPIENColorTable -ArgumentList $ContainerColor, $BackColor, $BorderColor, $MenuSelectionColor
	$render = New-Object System.Windows.Forms.ToolStripProfessionalRenderer -ArgumentList $colorTable
	[System.Windows.Forms.ToolStripManager]::Renderer = $render
	
	#Set up our processing queue
	$Queue = New-Object System.Collections.Generic.Queue[System.ComponentModel.Component]
	$Queue.Enqueue($Control)
	
	Add-Type -AssemblyName System.Core
	
	#Only process the controls once.
	$Processed = New-Object System.Collections.Generic.HashSet[System.ComponentModel.Component]
	
	#Apply the colors to the controls
	while ($Queue.Count -gt 0)
	{
		$target = $Queue.Dequeue()
		
		#Skip controls we already processed
		if ($Processed.Contains($target)) { continue }
		$Processed.Add($target)
		
		#Set the text color
		$target.ForeColor = $ForeColor
		
		#region Handle Controls
		if ($target -is [System.Windows.Forms.Form])
		{
			#Set Font
			$target.Font = $Font
			$target.BackColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.SplitContainer])
		{
			$target.BackColor = $BorderColor
		}
		elseif ($target -is [System.Windows.Forms.PropertyGrid])
		{
			$target.BackColor = $BorderColor
			$target.ViewBackColor = $BackColor
			$target.ViewForeColor = $ForeColor
			$target.ViewBorderColor = $BorderColor
			$target.CategoryForeColor = $ForeColor
			$target.CategorySplitterColor = $ContainerColor
			$target.HelpBackColor = $BackColor
			$target.HelpForeColor = $ForeColor
			$target.HelpBorderColor = $BorderColor
			$target.CommandsBackColor = $BackColor
			$target.CommandsBorderColor = $BorderColor
			$target.CommandsForeColor = $ForeColor
			$target.LineColor = $ContainerColor
		}
		elseif ($target -is [System.Windows.Forms.ContainerControl] -or
			$target -is [System.Windows.Forms.Panel])
		{
			#Set the BackColor for the container
			$target.BackColor = $ContainerColor
			
		}
		elseif ($target -is [System.Windows.Forms.GroupBox])
		{
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.Button])
		{
			$target.FlatStyle = 'Flat'
			$target.FlatAppearance.BorderColor = $BorderColor
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.CheckBox] -or
			$target -is [System.Windows.Forms.RadioButton] -or
			$target -is [System.Windows.Forms.Label])
		{
			#$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.ComboBox])
		{
			$target.BackColor = $BackColor
			$target.FlatStyle = 'Flat'
		}
		elseif ($target -is [System.Windows.Forms.TextBox])
		{
			$target.BorderStyle = 'FixedSingle'
			$target.BackColor = $BackColor
		}
		elseif ($target -is [System.Windows.Forms.DataGridView])
		{
			$target.GridColor = $BorderColor
			$target.BackgroundColor = $ContainerColor
			$target.DefaultCellStyle.BackColor = $WindowColor
			$target.DefaultCellStyle.SelectionBackColor = $SelectionBackColor
			$target.DefaultCellStyle.SelectionForeColor = $SelectionForeColor
			$target.ColumnHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.ColumnHeadersDefaultCellStyle.ForeColor = $ForeColor
			$target.EnableHeadersVisualStyles = $false
			$target.ColumnHeadersBorderStyle = 'Single'
			$target.RowHeadersBorderStyle = 'Single'
			$target.RowHeadersDefaultCellStyle.BackColor = $ContainerColor
			$target.RowHeadersDefaultCellStyle.ForeColor = $ForeColor
			
		}
		elseif ($PSVersionTable.PSVersion.Major -le 5 -and $target -is [System.Windows.Forms.DataGrid])
		{
			$target.CaptionBackColor = $WindowColor
			$target.CaptionForeColor = $ForeColor
			$target.BackgroundColor = $ContainerColor
			$target.BackColor = $WindowColor
			$target.ForeColor = $ForeColor
			$target.HeaderBackColor = $ContainerColor
			$target.HeaderForeColor = $ForeColor
			$target.FlatMode = $true
			$target.BorderStyle = 'FixedSingle'
			$target.GridLineColor = $BorderColor
			$target.AlternatingBackColor = $ContainerColor
			$target.SelectionBackColor = $SelectionBackColor
			$target.SelectionForeColor = $SelectionForeColor
		}
		elseif ($target -is [System.Windows.Forms.ToolStrip])
		{
			
			$target.BackColor = $BackColor
			$target.Renderer = $render
			
			foreach ($item in $target.Items)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ToolStripMenuItem] -or
			$target -is [System.Windows.Forms.ToolStripDropDown] -or
			$target -is [System.Windows.Forms.ToolStripDropDownItem])
		{
			$target.BackColor = $BackColor
			foreach ($item in $target.DropDownItems)
			{
				$Queue.Enqueue($item)
			}
		}
		elseif ($target -is [System.Windows.Forms.ListBox] -or
			$target -is [System.Windows.Forms.ListView] -or
			$target -is [System.Windows.Forms.TreeView])
		{
			$target.BackColor = $WindowColor
		}
		else
		{
			$target.BackColor = $BackColor
		}
		#endregion
		
		if ($target -is [System.Windows.Forms.Control])
		{
			#Queue all the child controls
			foreach ($child in $target.Controls)
			{
				$Queue.Enqueue($child)
			}
		}
	}
}
#endregion

$winget_maakPackage_button1_Click = {
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$fid = $config_packagefolder
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$wlo = $Winget_locale_textbox.text
		
	}
	else { $wlo = $null; }
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$wve = $winget_version_textbox1.text
	}
	else { $wve = $null; }
	
	$DisplayName = $winget_displayname_textbox1.text
	$WinGetID = $wid
	$regApp1 = $DisplayName
	$version = $vid
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$outputDirectory = $fid
	Set-Location $PSScriptRoot
	
	$winget_output_textbox3.Text = "`nNew intunewin package will now be created: `r`n"
	$winget_output_textbox3.AppendText("Please wait`r`n")
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$DisplayName\$version\source" -s "$outputDirectory\$DisplayName\$version\source\install.ps1" -o "$outputDirectory\$DisplayName\$version\output" -q
	
	Rename-Item -Path "$outputDirectory\$DisplayName\$version\output\install.intunewin" -NewName "$outputDirectory\$DisplayName\$version\output\$DisplayName.intunewin"
	
	
	$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\output\$DisplayName.intunewin")
	$winget_output_textbox3.AppendText("`r`n")
	$winget_output_textbox3.AppendText("Version: $Version `r`n")
	$winget_output_textbox3.AppendText("Install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$winget_output_textbox3.AppendText("un-install command is: `r`n")
	$winget_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$winget_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$regApp1\"
	$regkeyApp
	$winget_output_textbox3.AppendText("$regkeyApp `r`n")
	$winget_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$winget_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$winget_output_textbox3.AppendText("Detection Value is: $Version `r`n")
	$winget_output_textbox3.AppendText("Please reopen tool to make another winget package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$DisplayName.intunewin"
			DisplayName   = $DisplayName
			Publisher	  = $config_customername_textbox.Text
			AppVersion    = $version;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$DisplayName\$version\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$DisplayName\$version\output\"
	$winget_output_textbox3.AppendText("Config.csv written to: `r`n")
	$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\output\config.csv")
	$winget_output_textbox3.AppendText("  `r`n")
	$winget_output_textbox3.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
	$winget_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	$winget_upload_logo_button1.Visible = $true
	$winget_upload_logo_button1.Enabled = $true;
	$buildingBlokcsCSV = $winget_buildingBlocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$DisplayName\$version\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$DisplayName\BuildingBlocks.csv" -force -NoTypeInformation
		$winget_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$winget_output_textbox3.AppendText("$config_buildingblockspath\$DisplayName\BuildingBlocks.csv `r`n")
		$winget_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		
	}
	
	
	
	
}



$winget_WingetID_textbox1_TextChanged = {
	#TODO: Place custom script here
	
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$versie_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$config_packagefolder_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_output_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_intunewin_tabpage2_Click = {
	#TODO: Place custom script here
	
}

$config_packagefolder_label_Click = {
	#TODO: Place custom script here
	
}

$winget_checkurl_button1_Click = {
	
	$wgid = $winget_WingetID_textbox1.text
	
	
	$showurl = winget show $wgid --accept-source-agreements
	foreach ($l in $showurl)
	{
		if ($l -like "*Installer Url*") { $url = "https:" + $l.Split(":")[2] }
	}
	
	
	
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show($URL, 'Download source URL') # Casting the method to [void] suppresses the output. 
	
}

$config_customername_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_logfoldertarger_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_save_button_Click = {
	#TODO: Place custom script here
	
	[string]$c_customername = $config_customername_textbox.text
	[string]$c_logfoldertarget = $config_logfoldertarger_textbox.text
	[string]$c_packagefolder = $config_packagefolder_textbox.text
	[string]$c_buildingblocksfolder  = $config_buildingblocks_textbox3.text
	[string]$c_downloadfolder = $config_download_folder_textbox3.Text
	
	[string]$c_customername = $c_customername.Replace(" ","")
	[string]$c_logfoldertarget = $c_logfoldertarget.Replace(" ", "")
	[string]$c_packagefolder = $c_packagefolder.Replace(" ", "")
	[string]$c_buildingblocksfolder = $c_buildingblocksfolder.Replace(" ", "")
	[string]$c_downloadfolder = $c_downloadfolder.Replace(" ", "")

	$config_customerinfo += @([config_customerinfo]@{
			customername    = $c_customername
			logfoldertarget = $c_logfoldertarget
			packagefolder   = $c_packagefolder
			downloadpath    = $c_downloadfolder;
			buildingblockspath = $c_buildingblocksfolder;
		})
	
	
	$existing_customerinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$filtered_customerinfo = $existing_customerinfo | Where-Object { $_.customername -ne $config_customerinfo.customername }
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Force
	$filtered_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation -Append
	$config_listbox.ResetText()
	try
	{
		$config_import_csv = $null;
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		$config_listbox.ClearSelected()
		$config_listbox.Items.Clear()
		$config_listbox.Refresh()
		foreach ($cis in $config_import_csv)
		{
		
				Update-ListBox $config_listbox $cis.customername -Append
				Update-ListBox $updatepackage_msi_change_customer_listbox1 $cis.customername -Append
				Update-ListBox $update_exe_listbox1 $cis.customername -Append
			
			
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$tools_winget_searchtabcontrol1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$exe_openexe_button1_Click = {
	#TODO: Place custom script here
	$exe_openfiledialog1.ShowDialog()
	$exe_label1.Text = $exe_openfiledialog1.SafeFileName
	$exe_label1.Visible = $true;
	$exe_maakPackageDir_button1.Enabled = $true
	$exe_open_Azure_OpenAI_Example_button1.Enabled = $true
	$exe_open_withqquestion_button1.Enabled = $true
}

$exe_label1_Click = {
	#TODO: Place custom script here
	
}

$exe_maakPackageDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$exepnaam = $exepnaam -replace (" ", "")
	$exe_packagenaam_textbox1.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$exe_output_textbox1.Text = "`nNew package directory created: `r`n"
			$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("`nEXE file will be copied now `r`n")
			
			[string]$exe_org_path = $exe_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $exe_org_path -Confirm:$false
				Copy-Item -Path $exe_org_path -Destination "$outputDirectory\$exepnaam\$exeversie\source" -ErrorAction Stop
				$exe_output_textbox1.AppendText("`nEXE file copy done!`r`n")
				$exe_output_textbox1.AppendText("`nIf you need any additional files please place in just created source directory `r`n")
				$exe_panel1.Enabled = $true
				$exe_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nEXE file copy failed. Please select EXE file first `r`n")
			}
			$exe_open_sourcedir_button1.Enabled = $true
			$exe_open_sourcedir_button1.Visible = $true
			$exe_maakScripting_button1.Enabled = $true
			$exe_buttonAddCustomPackageDesc.Enabled = $true
			$exe_buttonAddCustomPackageDesc.Visible = $true
			
		}
	}
	
	
}

$exe_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$exe_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_intunewin_tabpage5_Click = {
	#TODO: Place custom script here
	
}

$exe_parsInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	$argList = $exe_parsInstall_textbox1.Text
	$exebestand = $exe_openfiledialog1.SafeFileName
	$exe_output_installparameters.text = "Start-Process -FilePath $EXEbestand -ArgumentList $argList"
}

$exe_output_installparameters_Click = {
	#TODO: Place custom script here
	
}

$exe_install_test_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show("After successful test in PowerShell ISE. Please click the 'Test Done' button.", 'Test install.ps1?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		$backupFolder = "$env:LOCALAPPDATA\temp"
		$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
		$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
		$preBackupPath = Join-Path $backupFolder "PreChanges64_$timeStamp.reg"
		try
		{
			New-Variable -Name 'exe_preBackupPath64' -Value $preBackupPath -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'exe_preBackupPath64' -Value $preBackupPath -Scope Script
		}
		
		reg export "$regExportPath" "$preBackupPath" /y | Out-Null
		$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
		$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
		$preBackupPath = Join-Path $backupFolder "PreChanges32_$timeStamp.reg"
		try
		{
			New-Variable -Name 'exe_preBackupPath32' -Value $preBackupPath -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'exe_preBackupPath32' -Value $preBackupPath -Scope Script
		}
		reg export "$regExportPath" "$preBackupPath" /y | Out-Null
		$exe_test_done_button1CreateInstallScript.Enabled = $true
		$exe_gotobuildingblocksButton.Enabled = $true
		
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
}

$exe_radiobuttonUninstallEXEPath_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_parsUnInstall_textbox1.Enabled = $true
	$exe_parsUnInstall_textbox1.Visible = $true
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
}

$exe_radiobuttonGebruikZelfdeEXEAlsB_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $true
		$exe_parsUnInstall_textbox1.Visible = $true
		$argList2 = $exe_parsUnInstall_textbox1.text
		if ($exe_openfiledialog1.SafeFileName -like "*.exe")
		{
			
			$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
		}
		
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_parsUnInstall_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exebestandUninstall = $exe_uninstall_exe_path_textbox2.text
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exebestandUninstall = $exe_openfiledialog1.SafeFileName
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $true
	$exe_labelVoorbeeldUninstall.Enabled = $true
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
	
	
	$argList2 = $exe_parsUnInstall_textbox1.text
	if ($exe_openfiledialog1.SafeFileName -like "*.exe")
	{
		
		$exe_labelVoorbeeldUninstall.text = "Start-Process -FilePath $exebestandUninstall -ArgumentList $argList2"
	}
}

$exe_labelVoorbeeldUninstall_Click = {
	#TODO: Place custom script here
	
}

$exe_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation.. You can Edit in Powershell ISE. And save that file if needed.', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		powershell_ise -file "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$exe_addBuildingBlocksCSVButton.Enabled = $true
	}
	
	
	
}

$exe_maakScripting_button1_Click = {
	#TODO: Place custom script here
	
	$exe_UnlInstallParameters.Visible = $true
	$exe_UnlInstallParameters.Enabled = $true
	$exe_radiobuttonUninstallEXEPath.Visible = $true
	$exe_radiobuttonUninstallEXEPath.Enabled = $true
	$exe_install_test_button1.Enabled = $true
	$exe_install_test_button1.Visible = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Enabled = $true
	$exe_radiobuttonGebruikZelfdeEXEAlsB.Visible = $true
	$exe_radiobutton3.Enabled = $true
	$exe_radiobutton3.Visible = $true
	
	
	$exe_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 18:02
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$exeFile = "!!ExeFile!!"
$exeParameters = "!!ExeParams!!" ## Check EXE Params.. 
# Customer variables
$logDir = "!!LogDir!!"
$registerDetectionRoot = "!!RegisterDetectionRoot!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $exeFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Installation completed of $exeFile" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error executing $exeFile" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:









Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $exe_versie_textbox1.text
	$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
	$EXEPARSInput = $exe_parsInstall_textbox1.Text
	
	$exe_installFile = $exe_installFile.Replace('"!!AppName!!"', $appnaam)
	$exe_installFile = $exe_installFile.Replace('!!LogDir!!', $logdir)
	$exe_installFile = $exe_installFile.Replace('!!RegisterDetectionRoot!!', $RegisterDetectionroot)
	$exe_installFile = $exe_installFile.Replace('!!Version!!', $versie)
	$exe_installFile = $exe_installFile.Replace('"!!ExeFile!!"', $EXEbestand)
	$exe_installFile = $exe_installFile.Replace('"!!ExeParams!!"', $EXEPARSInput)
	
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	try
	{
		$exe_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$exe_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
	}
	catch
	{
		$exe_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	
	
}

$exe_uninstall_exe_path_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$exe_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$exe_maak_intuneWIN_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$mkiapn = $exe_packagenaam_textbox1.text
	$versie = $exe_versie_textbox1.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$exepnaam\$exeversie\source\" -s "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -o "$outputDirectory\$exepnaam\$exeversie\output\" -q
	Rename-Item -Path "$outputDirectory\$exepnaam\$exeversie\output\install.intunewin" -NewName "$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin"
	$exe_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\$mkiapn.intunewin")
	$exe_output_textbox1.AppendText("`r`n")
	
	$exe_output_textbox1.AppendText("Install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$exe_output_textbox1.AppendText("un-install command is: `r`n")
	$exe_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$exe_output_textbox1.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$mkiapn\"
	$regkeyApp
	$exe_output_textbox1.AppendText("$regkeyApp `r`n")
	$exe_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$exe_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$exe_output_textbox1.AppendText("Detection Value is: $Versie `r`n")
	$exe_output_textbox1.AppendText("Please reopen tool to make another EXE package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$exepnaam.intunewin"
			DisplayName   = $exepnaam
			Publisher	  = $config_customername
			AppVersion    = $exeversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$exepnaam\$exeversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$exepnaam\$exeversie\output\"
	$exe_output_textbox1.AppendText("Config.csv written to naar: `r`n")
	$exe_output_textbox1.AppendText("$outputDirectory\$exepnaam\$exeversie\output\config.csv")
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	$exe_output_textbox1.AppendText("  `r`n")

	$buildingBlokcsCSV = $exe_buildingblockscsv_textbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$exepnaam\$exeversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$exepnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$exe_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$exe_output_textbox1.AppendText("$config_buildingblockspath\$exepnaam\BuildingBlocks.csv `r`n")
		$exe_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$exe_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$exe_output_textbox1.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$exe_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
	
	
}

$msi_buttonOpenMSIFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog1.ShowDialog()
	$msi_openmsi_label1.Text = $msi_openfiledialog1.SafeFileName
	$msi_openmsi_label1.Visible = $true;
	$msi_openfiledialog2.Reset()
	$msi_openfiledialog3.Reset()
	$msi_openmsp_label1.Text = ''
	$msi_openmsp_label1.Visible = $false
	$msi_openmsp_label1.Enabled = $false
	$msi_buttonOpenMSPFile.Enabled = $true
	$msi_buttonOpenMSPFile.Visible = $true
	$msi_openmst_label1.Text = ''
	$msi_buttonOpenMSTFile.Visible = $true
	$msi_buttonOpenMSTFile.Enabled = $true
	#$msi_reg_hklm_label5.Visible = $false
	#$msi_reg_hklm_label5.Enabled = $false
	
	
}

$msi_buttonOpenMSPFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog2.ShowDialog()
	$msi_openmsp_label1.Text = $msi_openfiledialog2.SafeFileName
	$msi_openmsp_label1.Visible = $true
	$msi_openmsp_label1.Enabled = $true
}


$msi_buttonOpenMSTFile_Click = {
	#TODO: Place custom script here
	$msi_openfiledialog3.ShowDialog()
	$msi_openmst_label1.Text = $msi_openfiledialog3.SafeFileName
	$msi_openmst_label1.Visible = $true
	$msi_openmst_label1.Enabled = $true
}



$msi_openmsi_label1_Click = {
	#TODO: Place custom script here
	
}

$msi_buttonCreatePackageDirecto_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msipnaam = $msi_packagenaam_textbox1.text
	$msipnaam = $msipnaam -replace (" ", "")
	$msi_packagenaam_textbox1.text = $msipnaam
	$msiversie = $msi_versie_textbox1.text
	
	if ($msipnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msiversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msipnaam\$msiversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msipnaam\$msiversie\output"
			}
			$msi_output_textbox1.Text = "`nNew package direcotory created: `r`n"
			$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\source")
			$msi_output_textbox1.AppendText("`r`n")
			$msi_output_textbox1.AppendText("`nMSI file will now be copied`r`n")
			[string]$msi_org_path = $msi_openfiledialog1.FileNames
			
			
			
			try
			{
				Unblock-File -Path $msi_org_path -Confirm:$false
				function Get-MSIProductCode
				{
					### GPT o1-preview
					param (
						[Parameter(Mandatory = $true)]
						[string]$MSIPath
					)
					$installer = New-Object -ComObject WindowsInstaller.Installer
					$database = $installer.OpenDatabase($MSIPath, 0)
					$view = $database.OpenView("SELECT Value FROM Property WHERE Property='ProductCode'")
					$view.Execute()
					$record = $view.Fetch()
					if ($record -ne $null)
					{
						$productCode = $record.StringData(1)
						return $productCode
					}
					else
					{
						Write-Error "ProductCode niet gevonden in het MSI-bestand."
						return $null
					}
					$view.Close()
				}
				$productCode = Get-MSIProductCode -MSIPath $msi_org_path
				
				
				$MSINewname = $msi_openfiledialog1.FileName
				
				$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
				$MSINewname = $MSINewname.Replace(" ", "")
				$MSIbestand = "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname"
				
				
				
				#Write-Host $MSIbestand
				Copy-Item -Path $msi_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSINewname" -ErrorAction Stop
				$msi_output_textbox1.AppendText("`nMSI file copy done `r`n")
				$msp = $msi_openmsp_label1.Text
				
				if ($msp -ne '')
				{
					[string]$msp_org_path = $msi_openfiledialog2.FileNames
					Unblock-File -Path $msp_org_path -Confirm:$false
					$MSPNewname = $msi_openfiledialog2.FileName
					$MSPNewname = $MSPNewname.Split("\")[$MSPNewname.Split("\").Count - 1]
					$MSPNewname = $MSPNewname.Replace(" ", "")
					Copy-Item -Path $msp_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSPNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMSP file copy done `r`n")
				}
				$mst = $msi_openmst_label1.Text
				if ($mst -ne '')
				{
					[string]$mst_org_path = $msi_openfiledialog3.FileNames
					Unblock-File -Path $mst_org_path -Confirm:$false
					$MSTNewname = $msi_openfiledialog3.FileName
					$MSTNewname = $MSTNewname.Split("\")[$MSTNewname.Split("\").Count - 1]
					$MSTNewname = $MSTNewname.Replace(" ", "")
					Copy-Item -Path $mst_org_path -Destination "$outputDirectory\$msipnaam\$msiversie\source\$MSTNewname" -ErrorAction Stop
					$msi_output_textbox1.AppendText("`nMST file copy done `r`n")
				}
				
				$msi_output_textbox1.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				$msi_panel1.Enabled = $true
				$msi_panel1.Visible = $true
			}
			catch
			{
				$exe_output_textbox1.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			$appNaam = $msipnaam
			$versie = $msiversie
			#$msi_openfiledialog1.SafeFileName
			#klant variabelen
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			#Dyn vars
			$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
			$filenaamMSILog = $appNaam + $versie + "MSI"
			$filenaamMSIUninstallLog = $appNaam + $versie + "MSI" + "_uninstall"
			$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
			$logfileMSIUninstall = "$(Join-Path $logdir  "$filenaamMSIUninstallLog.txt")"
			
			if ($msp -ne '')
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname PATCH=$MSPNewname"
			}
			else
			{
				$msi_install_par_textbox3.Text = "msiexec /qn, /l*v $logfileMSI /i $MSINewname"
			}
			if ($mst -ne '')
			{
				$oldMSIInstallstring = $msi_install_par_textbox3.Text
				$msi_install_par_textbox3.Text = $oldMSIInstallstring + " TRANSFORMS=$MSTNewname"
				
			}
			
			
			$msi_uninstall_par_textbox1.Text = "msiexec /qn, /l*v $logfileMSIUninstall /x$productCode"
			$msi_OpenSourceDir_button1.Enabled = $true
			$msi_OpenSourceDir_button1.Visible = $true
			$msi_open_Orca_button1.Enabled = $true
			$msi_addDescription.Enabled = $true
			$msi_addDescription.Visible = $true
		}
	}
	
	
}

$labelInstallParametersadj_Click = {
	#TODO: Place custom script here
	
}

$msi_uninstall_par_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$msi_button1CreateInstallScript_Click = {
	#TODO: Place custom script here
	#'"' + $exe_openfiledialog1.SafeFileName + '"'
	
	$msi_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	28-8-2025 17:00
	 Created by:   	Rink Turksma	
	 Organization: 	https://intunepreptool.com
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Install file generated by the IntunePrepTool
#>


#AppsVars
$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"

#Customer vars
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$loglevel = "!!loglevel!!"

#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;



##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot

if ($loglevel -eq 'verbose')
{
	
	try
	{
		$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
		
		$msilog = get-content $logfileMSI
		if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
		Else
		{
			foreach ($ml in $msilog)
			{
				if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
				{
					$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
				}
			}
			write-host "Script started i.cmd" -ForegroundColor Green
			Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
			write-host $logfileMSI -ForegroundColor Green
			$MSILOGS = get-content $logfileMSI
			
			
			
		}
		
		if ($msiuninstallcode -eq $null) { $excode = 1; write-error "Can't find uninstall code in MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
		Else
		{
			
			$MSILogs = Get-Content -Path $logfileMSI
			
			
			$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
			
			$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
			
			$Status = $null
			
			
			$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
			if ($lastStatusLine)
			{
				if ($lastStatusLine.Line -match $patternStatus)
				{
					$Status = [int]$Matches['code']
				}
			}
			
			
			if (-not $Status)
			{
				$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
				if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
				{
					$Status = [int]$Matches['code']
				}
			}
			
			$MsiErrors = @{
				0 = 'ERROR_SUCCESS - The action completed successfully.'
				13 = 'ERROR_INVALID_DATA - The data is invalid.'
				87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
				120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
				1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
				1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
				1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
				1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
				1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
				1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
				1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
				1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
				1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
				1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
				1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
				3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
			}
			[int]$code = $Status
			if ($MsiErrors.ContainsKey($code))
			{
				$msg = $MsiErrors[$code]
			}
			else
			{
				$msg = "Unknown MSI error code: $code"
			}
			if ($code -eq 0 -or $code -eq 3010)
			{
				Write-Host "MSI Result: $msg" -ForegroundColor Green
				$excode = 0
			}
			else
			{
				Write-Error "MSI Result: $msg"
				$excode = 1
			}
			$excode = 0
		}
	}
	catch
	{
		Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
		Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
		$MSILogs = Get-Content -Path $logfileMSI
		
		
		$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
		
		$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
		
		$Status = $null
		
		
		$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
		if ($lastStatusLine)
		{
			if ($lastStatusLine.Line -match $patternStatus)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		if (-not $Status)
		{
			$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
			if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		
		# Output
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
		
		
		$excode = 1
	}
}
else
{
	try
	{
		$startPMSI = start-process i.cmd -wait -WindowStyle Hidden -erroraction stop
		write-host $startPMSI
		$msilog = get-content $logfileMSI
		if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
		Else
		{
			foreach ($ml in $msilog)
			{
				if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
				{
					$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
				}
			}
			write-host "Script started i.cmd" -ForegroundColor Green
			write-host ""
			Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
			write-host $logfileMSI -ForegroundColor Green
			$MSILOGS = $null; $MSILOGS = get-content $logfileMSI
			$MSILOGS
			$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
			if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
			{
				$Status = $matches[1]
			}
			
			
			$MsiErrors = @{
				0 = 'ERROR_SUCCESS - The action completed successfully.'
				13 = 'ERROR_INVALID_DATA - The data is invalid.'
				87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
				120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
				1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
				1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
				1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
				1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
				1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
				1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
				1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
				1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
				1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
				1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
				1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
				3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
			}
			[int]$code = $Status
			if ($MsiErrors.ContainsKey($code))
			{
				$msg = $MsiErrors[$code]
			}
			else
			{
				$msg = "Unknown MSI error code: $code"
			}
			if ($code -eq 0 -or $code -eq 3010)
			{
				Write-Host "MSI Result: $msg" -ForegroundColor Green
				$excode = 0
			}
			else
			{
				Write-Error "MSI Result: $msg"
				$excode = 1
			}
		}
	}
	catch
	{
		Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
		Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
		
		$MSILOGS = $null; $MSILOGS = get-content $logfileMSI
		$MSILOGS
		$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
		if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
		{
			$Status = $matches[1]
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		
		# Output
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
		
	}
	
}
try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'hklm.reg')
{
	Write-Host "hklm.reg detected.. Now importing" -ForegroundColor Green
	
	# Run reg import, capturing stdout/stderr in $output
	$output = reg import "hklm.reg" /reg:64 2>&1
	
	# reg.exe sets a process exit code. 0 = success
	if ($LASTEXITCODE -eq 0)
	{
		Write-Host "Import succeeded!" -ForegroundColor Green
	}
	else
	{
		Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
		Write-Host "Output was: $output"
	}
}
if (Test-Path 'BuildingBlocks\System')
{
	$originalLocation = Get-Location
	Write-Host "BuildBlocks folder detected"
	
	$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
	foreach ($bb in $allBuildingBlocks)
	{
		$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
		
		if (Test-Path $bbScriptLocation -PathType Leaf)
		{
			Write-Host "Now running Building Blocks Script $bbScriptLocation"
			& $bbScriptLocation
			Set-Location $originalLocation
		}
	}
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	fDetectionInRegistry -succes $true
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}


'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_install_par_textbox3.Text + '"'
	
	$msi_installFile = $msi_installFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_installFile = $msi_installFile.Replace('!!logdir!!', $logdir)
	$msi_installFile = $msi_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_installFile = $msi_installFile.Replace('!!versie!!', $versie)
	$msi_installFile = $msi_installFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$loglevel = '"' + 'verbose' + '"'
	}
	else
	{
		$loglevel = '"' + 'info' + '"'
	}
	$msi_installFile = $msi_installFile.Replace('"!!loglevel!!"', $loglevel)

	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_install_par_textbox3.Text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\i.cmd" -encoding ascii -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$exepnaam\$exeversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$msi_installFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\install.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nInstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`ni.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
		$msi_output_textbox1.AppendText("`nAfter succesvol installation you can see the uninstall string in Powershell_ISE `r`n")
		$msi_output_textbox1.AppendText("`nIf this is not working. Check Tab Tools for uninstall strings `r`n")
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	
	$msi_test_install_button1.Enabled = $true
	$msi_test_install_button1.Visible = $true
	
	
}

$msi_install_par_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_packagenaam_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$msi_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show("When you want to add Building Blocks to this package, test installation first, then use the '(Optional) Go to Building Blocks' button", 'Test install.ps1?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msi_buttonOptionalGoToBuilding.Enabled = $true
	}
}

$Tools_Uninstall_String_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_Output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_Syswow_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	$tools_uninstallstring_textbox2.Text = "Here are alle the uninstall strings on your computer. Sorted by date `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$buttonUninstallstringWowAA32Node_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Hier volgen alle uninstallString sort by datum WowAA32Node `r`n"
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WowAA32Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	foreach ($ius in $InstallsUninstallString)
	{
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}

$msi_button5CreateIntunewinFile_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msi_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$msi_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$msi_output_textbox1.AppendText("`r`n")
	
	$msi_output_textbox1.AppendText("Install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msi_output_textbox1.AppendText("un-install command is: `r`n")
	$msi_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msi_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$msi_output_textbox1.AppendText("$regkeyApp `r`n")
	$msi_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$msi_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$msi_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$msi_output_textbox1.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$msi_output_textbox1.AppendText("Config.csv written to: `r`n")
	$msi_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$msi_output_textbox1.AppendText("  `r`n")
	$msi_buttonUploadLogoPNG.Enabled = $true
	$msi_buttonUploadLogoPNG.Visible = $true

	$buildingBlokcsCSV = $MSI_buildigblocks_Package_InProgresstextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$outputDirectory\$msipnaam\$msiversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$msipnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$msi_output_textbox1.AppendText("New BuildingBlocks.csv written to: `r`n")
		$msi_output_textbox1.AppendText("$config_buildingblockspath\$msipnaam\BuildingBlocks.csv `r`n")
		$msi_output_textbox1.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$msi_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$msi_output_textbox1.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$msi_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
}

$msi_OpenSourceDir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$msipnaam\$msiversie\source\"
}

$msi_button3CreateUninstallScri_Click = {
	#TODO: Place custom script here
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	29-8-2025 18:17
	 Created by:   	Rink Turksma
	 Organization: 	https://intunepreptool.com
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$loglevel = "!!loglevel!!"

#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI_uninstall"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
if ($loglevel -eq 'verbose')
{
	try
	{
		$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
		write-host $startPMSI
		write-host "Uninstall done!" -ForegroundColor Green
		write-host "Script used u.cmd" -ForegroundColor Green
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		
		$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
		
		$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
		
		$Status = $null
		
		
		$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
		if ($lastStatusLine)
		{
			if ($lastStatusLine.Line -match $patternStatus)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		if (-not $Status)
		{
			$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
			if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
		$excode = 0
	}
	catch
	{
		
		Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
		write-host "Script used u.cmd" -ForegroundColor Red
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		
		$patternStatus = '(?i)(?:Installation|Reconfiguration)\s+success\s+or\s+error\s+status:\s*(?<code>\d+)\.?'
		
		$patternEngine = '(?i)MainEngineThread\s+is\s+returning\s+(?<code>\d+)'
		
		$Status = $null
		
		
		$lastStatusLine = Select-String -Path $logfileMSI -Pattern $patternStatus | Select-Object -Last 1
		if ($lastStatusLine)
		{
			if ($lastStatusLine.Line -match $patternStatus)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		
		if (-not $Status)
		{
			$lastEngineLine = Select-String -Path $logfileMSI -Pattern $patternEngine | Select-Object -Last 1
			if ($lastEngineLine -and $lastEngineLine.Line -match $patternEngine)
			{
				$Status = [int]$Matches['code']
			}
		}
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
			$startPMSI
		}
		$startPMSI
		$excode = 1
	}
}
else
{
	try
	{
		$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
		write-host $startPMSI
		write-host "Uninstall done!" -ForegroundColor Green
		write-host "Script used u.cmd" -ForegroundColor Green
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Green
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
		if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
		{
			$Status = $matches[1]
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
	}
	catch
	{
		
		Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
		write-host "Script used u.cmd" -ForegroundColor Red
		Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red
		write-host $logfileMSI -ForegroundColor Green
		$MSILogs = Get-Content -Path $logfileMSI
		
		$MSILastLine = $null; $MSILastLine = Get-Content $logfileMSI | Select-Object -Last 3 | Select-Object -First 1
		if ($MSILastLine -match 'Installation success or error status:\s+(\d+)')
		{
			$Status = $matches[1]
		}
		
		
		$MsiErrors = @{
			0 = 'ERROR_SUCCESS - The action completed successfully.'
			13 = 'ERROR_INVALID_DATA - The data is invalid.'
			87 = 'ERROR_INVALID_PARAMETER - One of the parameters was invalid.'
			120 = "ERROR_CALL_NOT_IMPLEMENTED - Function can't be called from custom actions."
			1259 = 'ERROR_APPHELP_BLOCK - Product blocked as incompatible.'
			1601 = "ERROR_INSTALL_SERVICE_FAILURE - Windows Installer service couldn't be accessed."
			1602 = 'ERROR_INSTALL_USEREXIT - The user canceled installation.'
			1603 = 'ERROR_INSTALL_FAILURE - A fatal error occurred during installation.'
			1604 = 'ERROR_INSTALL_SUSPEND - Installation suspended, incomplete.'
			1605 = 'ERROR_UNKNOWN_PRODUCT - Action valid only for installed products.'
			1606 = "ERROR_UNKNOWN_FEATURE - The feature identifier isn't registered."
			1610 = "ERROR_BAD_CONFIGURATION - Configuration data corrupt."
			1612 = "ERROR_INSTALL_SOURCE_ABSENT - Source not available."
			1619 = "ERROR_INSTALL_PACKAGE_OPEN_FAILED - Package couldn't be opened."
			1620 = "ERROR_INSTALL_PACKAGE_INVALID - Package isn't valid."
			3010 = "ERROR_SUCCESS_REBOOT_REQUIRED - Restart required to complete install."
		}
		[int]$code = $Status
		if ($MsiErrors.ContainsKey($code))
		{
			$msg = $MsiErrors[$code]
		}
		else
		{
			$msg = "Unknown MSI error code: $code"
		}
		if ($code -eq 0 -or $code -eq 3010)
		{
			Write-Host "MSI Result: $msg" -ForegroundColor Green
			$excode = 0
		}
		else
		{
			Write-Error "MSI Result: $msg"
			$excode = 1
		}
	}


if (Test-Path 'BuildingBlocks\System')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
}

#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	remove-item $regkeyApp
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$versie = $msi_versie_textbox1.text
	$MSIbestand = '"' + $msi_openfiledialog1.SafeFileName + '"'
	$appnaam = '"' + $MSI_packagenaam_textbox1.text + '"'
	$MSIPARSInput = '"' + $msi_uninstall_par_textbox1.Text + '"'
	
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$loglevel = '"' + 'verbose' + '"'
	}
	else
	{
		$loglevel = '"' + 'info' + '"'
	}
	$msi_uninstallFile = $msi_uninstallFile.Replace('"!!loglevel!!"', $loglevel)
	
	$exepnaam = $msi_packagenaam_textbox1.text
	$exeversie = $versie
	$outputDirectory = $config_packagefolder
	
	try
	{
		$jjmsii = $msi_uninstall_par_textbox1.text
		
		$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
		$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
		$msi_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		$msi_output_textbox1.AppendText("`nu.cmd created `r`n")
		$msi_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
		
		
	}
	catch
	{
		$msi_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
	}
	$msi_button4TestUninstallPowers.Enabled = $true
	$msi_button4TestUninstallPowers.Visible = $true
	$msi_button5CreateIntunewinFile.Enabled = $true
	$msi_button5CreateIntunewinFile.Visible = $true
	
	
}

$msi_button4TestUninstallPowers_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test deinstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$fid = $config_packagefolder; $outputDirectory = $fid
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		
		powershell_ise -file "$outputDirectory\$msipnaam\$msiversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msi_addBuildingBlocksSystemContextbutton5CreateIntunewinFile.Enabled = $true;
	}
}

$Reset_button1_Click = {
	#TODO: Place custom script here
	Clear-Host
}

$config_tabpage1_Click = {
	#TODO: Place custom script here
	
}

$winget_upload_button1_Click = {
	#TODO: Place custom script here
	<#
	$token = Connect-MSIntuneGraph -TenantID "339ad6f1-ba98-4db6-bf71-0c140c9271bc" -Interactive
	$RegisterDetectionroot = "Intune_Customer"
	$appNaam = "Greenshot"
	$versie = 1
	$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
	$regkeyApp = "$regkeyRoot\$appNaam"
	$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName 'Versie' -StringComparisonOperator equal -StringComparisonValue $versie
	Add-IntuneWin32App -FilePath $IntuneWinFile `
					   -DisplayName $DisplayName `
					   -Description $DisplayName `
					   -Publisher $Publisher `
					   -AppVersion $AppVersion `
					   -Icon $IconCMD `
					   -InstallExperience "system" `
					   -RestartBehavior "suppress" `
					   -DetectionRule $DetectionRule `
					   -InstallCommandLine 'powershell -executionpolicy bypass -file install.ps1' `
					   -UninstallCommandLine 'powershell -executionpolicy bypass -file uninstall.ps1' -Verbose
	#>
}

$upload_LoadConfig_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	}
	else
	{
		
		
		$config_csv_openfiledialog1.ShowDialog() | Out-Null
		if ($config_csv_openfiledialog1.FileNames -notcontains 'config_csv_openfiledialog1')
		{
			$upload2_IntuneWinFile_textbox1.Text = $null;
			$upload2_DisplayName_textbox2.Text = $null;
			$upload2_Publisher_textbox1.Text = $null;
			$upload2_AppVersion_textbox1.Text = $null;
			$upload2_reglocation_textbox2.Text = $null;
			$upload2_regValue_textbox1.Text = $null;
			$upload2_installCMD_textbox1.Text = $null;
			$upload2_uninstallCMD_textbox1.Text = $null;
			$upload2_context_textbox1.Text = $null;
			
			$upload_panel2.Enabled = $false
			[string]$config_csv_path = $config_csv_openfiledialog1.FileNames
			$upload_configLoaded_textbox3.Text = $config_csv_openfiledialog1.FileNames
			$ConfigCSVImport = Import-Csv $config_csv_path
			#Write-Host $ConfigCSVImport
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload_context_textbox1.Text = $context
			
			
			if (!(test-path "$filepath\Logo.png" -PathType Leaf))
			{
				[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG, JPG, JPEG or WEBP file for the company portal', 'No Logo for Company portal found')
				$upload_logo_button2.Enabled = $true
				$upload_logo_button2.Visible = $true
				
			}
		}
	}
}

$upload_IntuneWinFile_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_DisplayName_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_Publisher_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_AppVersion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_reglocation_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_regValue_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_installCMD_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$upload_upload_button1_Click = {
	#TODO: Place custom script here
	$uploadIntuneFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	18-9-2025 15:30
	 Created by:   	Rink Turksma
	 Organization: 	https://intunepreptool.com
	 Filename:     	UploadIntune.ps1
	========================================
#>

#Requires -RunAsAdministrator
$RequiredPSModules = get-content "C:\Program Files\IntunePrepTool\InstallReqPSModules.txt"
if ($RequiredPSModules -like 'false')
{
	write-error 'Missing required Powershell Modules'
	start-sleep 60
	exit
}

[string]$config_csv_path = '!!CONFIGCSV!!'
[string]$buildingblocks_csv_path = '!!BUILDINGBLOCKSCSV!!'
$dep = "!!DEPENDENCY!!"
$AvailableAllUsers = "!!AvailableAllUsers!!"
$RequiredAllDevices = "!!RequiredAllDevices!!"
$SetupLikeOldVersion = "!!SetupLikeOldVersion!!"
$TenantName = "!!TenantName!!"
Write-host "First we logon to the Microsoft Tenant"
Write-host "`r`n"
Write-host "`r`n"

try
{
	$load_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv" -ErrorAction Stop
}
catch
{
	Write-Error "Error loading csv file c:\users\$env:username\.IntunePrepTool\config_tenantinfo.csv"
}


foreach ($load in $load_import_csv)
{
	if ($load.customername -eq $tenantName)
	{
		
		if ($load.target -ne 'plain')
		{
			$checkCredLoad = Get-StoredCredential -Target $load.target -AsCredentialObject
			$tenantID = $checkCredLoad.TargetName
			$tenantID = $tenantID.Split("_")[1]
			$AppId = $checkCredLoad.UserName
			$Secret = $checkCredLoad.Password
		}
		else
		{
			$cust = import-csv "c:\users\$env:username\.IntunePrepTool\$tenantname.csv"
			$tenantID = $cust.tenantID
			$AppId = $cust.appId
			$Secret = $cust.clientsecret
			$customPrivacyURL = $cust.customPrivacyURL
			
		}
	}
}

try
{
	Connect-MSIntuneGraph -TenantID $tenantID -ClientID $appID -ClientSecret $secret -ErrorAction Stop
}
catch
{
	Write-Error "No Connection to tenant. Please check app registration!!"
	start-sleep 60
	exit
}
$ConfigCSVImport = Import-Csv $config_csv_path
$itwnf = $ConfigCSVImport.IntuneWinFile
$filepath = $config_csv_path.TrimEnd("config.csv")
$itwnffilepath = $filepath + $itwnf
$descriptionpath = $filepath + 'Description.txt'
if (Test-Path $descriptionpath)
{
	[string]$description = Get-Content $descriptionpath
}
else
{
	$description = "The package has been uploaded using the IntunePrepTool."
}
$regKeyApp = $ConfigCSVImport.regLocation
$versie = $ConfigCSVImport.AppVersion
$regvalue = $ConfigCSVImport.RegValue
$dnam = $ConfigCSVImport.DisplayName
$publ = $ConfigCSVImport.Publisher
$icmd = $ConfigCSVImport.installCMD
$ucmd = $ConfigCSVImport.uninstallCMD
if ($ConfigCSVImport.context)
{
	$context = $ConfigCSVImport.context
}
else
{
	$context = 'system'
}
$logoaanwezig = $null;
try
{
	$logoaanwezig = get-childitem "$filepath\logo.png" -ErrorAction Stop
	$icon = New-IntuneWin32AppIcon -FilePath "$filepath\logo.png"
}
catch
{
	Write-Host "No Logo.PNG found in Output Directory" - ForegroundColor Green; Write-host "`r`n"; $logoaanwezig = $null;
}
$DetectionRule = New-IntuneWin32AppDetectionRuleRegistry -StringComparison -KeyPath $regkeyApp -ValueName $regvalue -StringComparisonOperator equal -StringComparisonValue $versie
$RequirementRule = New-IntuneWin32AppRequirementRule -Architecture "All" -MinimumSupportedWindowsRelease "W10_20H2"
write-host "We will first check if there are any apps already available in Intune with the same DisplayName" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
$Win32AppEvtVorigeVersies = Get-IntuneWin32App -DisplayName $dnam
if ($Win32AppEvtVorigeVersies -ne $null)
{
	write-host "Already version(s) found " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	$evtvversie = $Win32AppEvtVorigeVersies.DisplayVersion
	write-host $evtvversie
	$alversieAppAanwezig = $true;
	write-host "After uploading new version you can choose Superseedence in this script" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
}

else
{
	$alversieAppAanwezig = $false;
}

write-host "We will upload to Intune now" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
if ($logoaanwezig -eq $null)
{
	if (($customPrivacyURL -ne $null) -and ($customPrivacyURL -notlike ''))
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -PrivacyURL $customPrivacyURL
	}
	else
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule
	}
	
}
else
{
	if (($customPrivacyURL -ne $null) -and ($customPrivacyURL -notlike ''))
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule -PrivacyURL $customPrivacyURL
	}
	else
	{
		$Win32App = Add-IntuneWin32App -FilePath $itwnffilepath -DisplayName $dnam -Description $description -Publisher $publ -AppVersion $versie -Icon $Icon -InstallExperience $context -RestartBehavior "suppress" -DetectionRule $DetectionRule -InstallCommandLine $icmd -UninstallCommandLine $ucmd -RequirementRule $RequirementRule
	}
}
Write-host "If all is good the app will now be available in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";

if ($SetupLikeOldVersion -eq $true)
{
	if ($alversieAppAanwezig -eq $false) { write-host "Because there where no older versions of this software in Intune you have to do the assingments in the Intune portal" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"; }
	else
	{
		
		foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
		{
			write-host "We will now try to setup assignments " -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
			$assinmentVorigeVersie = get-IntuneWin32AppAssignment -id $vorigeversie.id
			$evtvversie = $vorigeversie.DisplayVersion
			
			if ($assinmentVorigeVersie -eq $null) { write-host "Older version: $evtvversie has no assignments" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
			else
			{
				write-host ""; Write-host "`r`n"; Write-host "`r`n"
				$response = read-host "Press q to do nothing, Any other key to setup assignments like: $evtvversie"
				$niksdoen = $response -eq "q"
				if ($niksdoen -eq $true) { write-host "Ok.. Then you have to setup the assignments in Intune" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
				else
				{
					write-host "Ok .. We will fix the assignments for you!" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
					Remove-IntuneWin32AppAssignment -ID $vorigeversie.ID -Confirm:$false
					try
					{
						Add-IntuneWin32AppAssignmentGroup -Intent $assinmentVorigeVersie.intent -Include -ID $Win32App.id -GroupID $assinmentVorigeVersie.Target.groupId -ErrorAction Stop
					}
					catch
					{
						Write-Host "Something went wrong. You will have to do this in Intune" -ForegroundColor Green
					}
				}
			}
		}
		
		foreach ($vorigeversie in $Win32AppEvtVorigeVersies)
		{
			$response = read-host "Press q to do nothing, Any other key to setup Supersedence  "
			$niksdoen = $response -eq "q"
			if ($niksdoen -eq $true) { write-host "Ok.. We are doing nothing here" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n" }
			else
			{
				write-host "Ok .. We will try to fix superseedence" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n"
				Write-host "We will fix superseedence for:" -ForegroundColor Green
				$vorigeversie.displayVersion
				
				$superseede = New-IntuneWin32AppSupersedence -ID $vorigeversie.id -SupersedenceType Replace
				$bestaandeSuperSedence = $null; $bestaandeSuperSedence = Get-IntuneWin32AppSupersedence -ID $vorigeversie.id
				if ($bestaandeSuperSedence -ne $null) { Remove-IntuneWin32AppSupersedence -ID $bestaandeSuperSedence -Confirm:$False }
				Add-IntuneWin32AppSupersedence -ID $Win32App.id -Supersedence $superseede -Confirm:$false
			}
		}
	}
}
if ($AvailableAllUsers -eq $true)
{
	write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	Add-IntuneWin32AppAssignmentAllUsers -ID $Win32App.Id -Intent available -Notification showAll
}


if ($RequiredAllDevices -eq $true)
{
	write-host "We will now setup assignment" -ForegroundColor Green; Write-host "`r`n"; Write-host "`r`n";
	Add-IntuneWin32AppAssignmentAllDevices -ID $Win32App.Id -Intent required -Notification hideAll
}
write-host 'Upload Finished!' -ForegroundColor Green
start-sleep 15

'@
	function Get-CheckedNodes
	{
		param (
			[ValidateNotNull()]
			[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
			[ValidateNotNull()]
			[System.Collections.ArrayList]$CheckedNodes)
		
		foreach ($Node in $NodeCollection)
		{
			if ($Node.Checked)
			{
				[void]$CheckedNodes.Add($Node)
			}
			Get-CheckedNodes $Node.Nodes $CheckedNodes
		}
	}
	$CheckedNodes = New-Object System.Collections.ArrayList
	Get-CheckedNodes $upload_treeview2.Nodes $CheckedNodes
	[string]$config_csv_path = $upload_configLoaded_textbox3.Text
	foreach ($node in $CheckedNodes)
	{
		
		if ($config_csv_path -notlike '*BuildingBlocks.csv*')
		{
			$depWin = $upload_dep_textbox1.Text
			$tenantName = $node.Name
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!CONFIGCSV!!', $config_csv_path)
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!TenantName!!', $TenantName)
			$uploadIntuneFile = $uploadIntuneFile.Replace('!!DEPENDENCY!!', $depWin)
			if ($Upload_beschikbaar_all_users_checkbox1.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!AvailableAllUsers!!', $false)
			}
			if ($upload_checkboxRequiredForAllDevice.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!RequiredAllDevices!!', $false)
			}
			if ($upload_checkboxSetupAssignmentLikeP.Checked -eq $true)
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $true)
			}
			else
			{
				$uploadIntuneFile = $uploadIntuneFile.Replace('!!SetupLikeOldVersion!!', $false)
			}
			
			
			
			
			$filepath = $config_csv_path.TrimEnd("config.csv")
			$tenant = $node.Name
			$uploadFile = $filepath + "\uploadIntune" + $tenant + ".ps1"
			$uploadIntuneFile | Out-File $uploadFile -Force
			
			if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				Start-Process -FilePath "powershell.exe" -ArgumentList "-NoProfile -File $uploadFile"
				#powershell -file $filepath\uploadIntune.ps1
				#Start-Sleep 1
				#PowershellISEOnTop
			}
		}
		else
		{
			if ([System.Windows.Forms.MessageBox]::Show('A PowerShell window will open, allowing you to monitor the status. If you selected multiple tenants, an additional popup will appear. After uploading, please reopen the IntunePrepTool to create another package.', "Upload to Intune tenant $tenant", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
			{
				$tenantName = $node.Name
				$scriptPath = "C:\Program Files\IntunePrepTool\UploadToIntuneBuildingBlocksCSV.ps1"
				$args = "-NoProfile -File `"$scriptPath`" -buildingblocks_csv_path `"$config_csv_path`" -tenantname `"$tenantName`""
				
				if ($Upload_beschikbaar_all_users_checkbox1.Checked)
				{
					$args += " -AvailableAllUsers `"True`""
				}
				
				if ($upload_checkboxRequiredForAllDevice.Checked)
				{
					$args += " -RequiredAllDevices `"True`""
				}
				Write-Host $args
				Start-Process -FilePath "powershell.exe" -ArgumentList $args
				
			}
			
		}
		
		
	}
	
	
}

$upload_tenantURL_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_upload_logo_button1_Click = {
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$DisplayName = $winget_displayname_textbox1.text
	$msipnaam = $DisplayName -replace (" ", "")
	$msiversie = $versie_textbox2.Text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
}

$msi_buttonUploadLogoPNG_Click = {
	#TODO: Place custom script here
	
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msi_packagenaam_textbox1.text
	$msiversie = $msi_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\","\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
}

$exe_uploadlogo_button1_Click = {
	#TODO: Place custom script here
	$msipnaam = $exe_packagenaam_textbox1.text
	$msiversie = $exe_versie_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
}



$upload_dep_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}





$config_panel_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_tenanturl_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

#region Control Helper Functions
function Show-NotifyIcon
{
<#
	.SYNOPSIS
		Displays a NotifyIcon's balloon tip message in the taskbar's notification area.
	
	.DESCRIPTION
		Displays a NotifyIcon's a balloon tip message in the taskbar's notification area.
		
	.PARAMETER NotifyIcon
     	The NotifyIcon control that will be displayed.
	
	.PARAMETER BalloonTipText
     	Sets the text to display in the balloon tip.
	
	.PARAMETER BalloonTipTitle
		Sets the Title to display in the balloon tip.
	
	.PARAMETER BalloonTipIcon	
		The icon to display in the ballon tip.
	
	.PARAMETER Timeout	
		The time the ToolTip Balloon will remain visible in milliseconds. 
		Default: 0 - Uses windows default.
#>
	 param(
	  [Parameter(Mandatory = $true, Position = 0)]
	  [ValidateNotNull()]
	  [System.Windows.Forms.NotifyIcon]$NotifyIcon,
	  [Parameter(Mandatory = $true, Position = 1)]
	  [ValidateNotNullOrEmpty()]
	  [String]$BalloonTipText,
	  [Parameter(Position = 2)]
	  [String]$BalloonTipTitle = '',
	  [Parameter(Position = 3)]
	  [System.Windows.Forms.ToolTipIcon]$BalloonTipIcon = 'None',
	  [Parameter(Position = 4)]
	  [int]$Timeout = 0
 	)
	
	if($null -eq $NotifyIcon.Icon)
	{
		#Set a Default Icon otherwise the balloon will not show
		$NotifyIcon.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon([System.Windows.Forms.Application]::ExecutablePath)
	}
	
	$NotifyIcon.ShowBalloonTip($Timeout, $BalloonTipTitle, $BalloonTipText, $BalloonTipIcon)
}




<#
	.SYNOPSIS
		Sets the emulation of the WebBrowser control for the application.
	
	.DESCRIPTION
		Sets the emulation of the WebBrowser control for the application using the installed version of IE.
		This improves the WebBrowser control compatibility with newer html features.
	
	.PARAMETER ExecutableName
		The name of the executable E.g. PowerShellStudio.exe.
		Default Value: The running executable name.
	
	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation

	.EXAMPLE
		PS C:\> Set-WebBrowserEmulation PowerShell.exe
#>
function Set-WebBrowserEmulation
{
	param
	(
		[ValidateNotNullOrEmpty()]
		[string]$ExecutableName = [System.IO.Path]::GetFileName([System.Diagnostics.Process]::GetCurrentProcess().MainModule.FileName)
	)
	
	#region Get IE Version
	$valueNames = 'svcVersion', 'svcUpdateVersion', 'Version', 'W2kVersion'
	
	$version = 0;
	for ($i = 0; $i -lt $valueNames.Length; $i++)
	{
		$objVal = [Microsoft.Win32.Registry]::GetValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Internet Explorer', $valueNames[$i], '0')
		$strVal = [System.Convert]::ToString($objVal)
		if ($strVal)
		{
			$iPos = $strVal.IndexOf('.')
			if ($iPos -gt 0)
			{
				$strVal = $strVal.Substring(0, $iPos)
			}
			
			$res = 0;
			if ([int]::TryParse($strVal, [ref]$res))
			{
				$version = [Math]::Max($version, $res)
			}
		}
	}
	
	if ($version -lt 7)
	{
		$version = 7000
	}
	else
	{
		$version = $version * 1000
	}
	#endregion
	
	[Microsoft.Win32.Registry]::SetValue('HKEY_CURRENT_USER\SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION', $ExecutableName, $version)
}



function Update-ComboBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ComboBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ComboBox control.
	
	.PARAMETER ComboBox
		The ComboBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ComboBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ComboBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ComboBox $combobox1 "Red" -Append
		Update-ComboBox $combobox1 "White" -Append
		Update-ComboBox $combobox1 "Blue" -Append
	
	.EXAMPLE
		Update-ComboBox $combobox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ComboBox]$ComboBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ComboBox.Items.Clear()
	}
	
	if ($Items -is [Object[]])
	{
		$ComboBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ComboBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ComboBox.Items.Add($obj)
		}
		$ComboBox.EndUpdate()
	}
	else
	{
		$ComboBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	if ($ValueMember)
	{
		$ComboBox.ValueMember = $ValueMember
	}
}



function Get-CheckedNode
{
<#
	.SYNOPSIS
		This function collects a list of checked nodes in a TreeView

	.DESCRIPTION
		This function collects a list of checked nodes in a TreeView

	.PARAMETER  $NodeCollection
		The collection of nodes to search

	.PARAMETER  $CheckedNodes
		The ArrayList that will contain the all the checked items
	
	.EXAMPLE
		$CheckedNodes = New-Object System.Collections.ArrayList
		Get-CheckedNode $treeview1.Nodes $CheckedNodes
		foreach($node in $CheckedNodes)
		{	
			Write-Host $node.Text
		}
#>
	param (
		[ValidateNotNull()]
		[System.Windows.Forms.TreeNodeCollection]$NodeCollection,
		[ValidateNotNull()]
		[System.Collections.ArrayList]$CheckedNodes
	)
	
	foreach ($Node in $NodeCollection)
	{
		if ($Node.Checked)
		{
			[void]$CheckedNodes.Add($Node)
		}
		Get-CheckedNode $Node.Nodes $CheckedNodes
	}
}



function Update-DataGridView
{
	<#
	.SYNOPSIS
		This functions helps you load items into a DataGridView.

	.DESCRIPTION
		Use this function to dynamically load items into the DataGridView control.

	.PARAMETER  DataGridView
		The DataGridView control you want to add items to.

	.PARAMETER  Item
		The object or objects you wish to load into the DataGridView's items collection.
	
	.PARAMETER  DataMember
		Sets the name of the list or table in the data source for which the DataGridView is displaying data.

	.PARAMETER AutoSizeColumns
	    Resizes DataGridView control's columns after loading the items.
	#>
	Param (
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		[System.Windows.Forms.DataGridView]$DataGridView,
		[ValidateNotNull()]
		[Parameter(Mandatory = $true)]
		$Item,
		[Parameter(Mandatory = $false)]
		[string]$DataMember,
		[System.Windows.Forms.DataGridViewAutoSizeColumnsMode]$AutoSizeColumns = 'None'
	)
	$DataGridView.SuspendLayout()
	$DataGridView.DataMember = $DataMember
	
	if ($null -eq $Item)
	{
		$DataGridView.DataSource = $null
	}
	elseif ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
	{
		$DataGridView.DataSource = $Item.Tables[0]
	}
	elseif ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView])
	{
		$DataGridView.DataSource = $Item
	}
	else
	{
		$array = New-Object System.Collections.ArrayList
		
		if ($Item -is [System.Collections.IList])
		{
			$array.AddRange($Item)
		}
		else
		{
			$array.Add($Item)
		}
		$DataGridView.DataSource = $array
	}
	
	if ($AutoSizeColumns -ne 'None')
	{
		$DataGridView.AutoResizeColumns($AutoSizeColumns)
	}
	
	$DataGridView.ResumeLayout()
}



function ConvertTo-DataTable
{
	<#
		.SYNOPSIS
			Converts objects into a DataTable.
	
		.DESCRIPTION
			Converts objects into a DataTable, which are used for DataBinding.
	
		.PARAMETER  InputObject
			The input to convert into a DataTable.
	
		.PARAMETER  Table
			The DataTable you wish to load the input into.
	
		.PARAMETER RetainColumns
			This switch tells the function to keep the DataTable's existing columns.
		
		.PARAMETER FilterCIMProperties
			This switch removes CIM properties that start with an underline.
	
		.EXAMPLE
			$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
	#>
	[OutputType([System.Data.DataTable])]
	param (
		$InputObject,
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterCIMProperties)
	
	if ($null -eq $Table)
	{
		$Table = New-Object System.Data.DataTable
	}
	
	if ($null -eq $InputObject)
	{
		$Table.Clear()
		return @( ,$Table)
	}
	
	if ($InputObject -is [System.Data.DataTable])
	{
		$Table = $InputObject
	}
	elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
	{
		$Table = $InputObject.Tables[0]
	}
	else
	{
		if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
		{
			#Clear out the Table Contents
			$Table.Clear()
			
			if ($null -eq $InputObject) { return } #Empty Data
			
			$object = $null
			#find the first non null value
			foreach ($item in $InputObject)
			{
				if ($null -ne $item)
				{
					$object = $item
					break
				}
			}
			
			if ($null -eq $object) { return } #All null then empty
			
			#Get all the properties in order to create the columns
			foreach ($prop in $object.PSObject.Get_Properties())
			{
				if (-not $FilterCIMProperties -or -not $prop.Name.StartsWith('__')) #filter out CIM properties
				{
					#Get the type from the Definition string
					$type = $null
					
					if ($null -ne $prop.Value)
					{
						try { $type = $prop.Value.GetType() }
						catch { Out-Null }
					}
					
					if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
					{
						[void]$table.Columns.Add($prop.Name, $type)
					}
					else #Type info not found
					{
						[void]$table.Columns.Add($prop.Name)
					}
				}
			}
			
			if ($object -is [System.Data.DataRow])
			{
				foreach ($item in $InputObject)
				{
					$Table.Rows.Add($item)
				}
				return @( ,$Table)
			}
		}
		else
		{
			$Table.Rows.Clear()
		}
		
		foreach ($item in $InputObject)
		{
			$row = $table.NewRow()
			
			if ($item)
			{
				foreach ($prop in $item.PSObject.Get_Properties())
				{
					if ($table.Columns.Contains($prop.Name))
					{
						$row.Item($prop.Name) = $prop.Value
					}
				}
			}
			[void]$table.Rows.Add($row)
		}
	}
	
	return @( ,$Table)
}



function Update-ListBox
{
<#
	.SYNOPSIS
		This functions helps you load items into a ListBox or CheckedListBox.
	
	.DESCRIPTION
		Use this function to dynamically load items into the ListBox control.
	
	.PARAMETER ListBox
		The ListBox control you want to add items to.
	
	.PARAMETER Items
		The object or objects you wish to load into the ListBox's Items collection.
	
	.PARAMETER DisplayMember
		Indicates the property to display for the items in this control.
		
	.PARAMETER ValueMember
		Indicates the property to use for the value of the control.
	
	.PARAMETER Append
		Adds the item(s) to the ListBox without clearing the Items collection.
	
	.EXAMPLE
		Update-ListBox $ListBox1 "Red", "White", "Blue"
	
	.EXAMPLE
		Update-ListBox $listBox1 "Red" -Append
		Update-ListBox $listBox1 "White" -Append
		Update-ListBox $listBox1 "Blue" -Append
	
	.EXAMPLE
		Update-ListBox $listBox1 (Get-Process) "ProcessName"
	
	.NOTES
		Additional information about the function.
#>
	
	param
	(
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		[System.Windows.Forms.ListBox]$ListBox,
		[Parameter(Mandatory = $true)]
		[ValidateNotNull()]
		$Items,
		[Parameter(Mandatory = $false)]
		[string]$DisplayMember,
		[Parameter(Mandatory = $false)]
		[string]$ValueMember,
		[switch]$Append
	)
	
	if (-not $Append)
	{
		$ListBox.Items.Clear()
	}
	
	if ($Items -is [System.Windows.Forms.ListBox+ObjectCollection] -or $Items -is [System.Collections.ICollection])
	{
		$ListBox.Items.AddRange($Items)
	}
	elseif ($Items -is [System.Collections.IEnumerable])
	{
		$ListBox.BeginUpdate()
		foreach ($obj in $Items)
		{
			$ListBox.Items.Add($obj)
		}
		$ListBox.EndUpdate()
	}
	else
	{
		$ListBox.Items.Add($Items)
	}
	
	if ($DisplayMember)
	{
		$ListBox.DisplayMember = $DisplayMember
	}
	if ($ValueMember)
	{
		$ListBox.ValueMember = $ValueMember
	}
}


#endregion

$config_listbox_SelectedIndexChanged = {
	#TODO: Place custom script here
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
	}
	catch
	{
		#Error handling here
	}
	
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -eq $config_listbox.SelectedItem)
		{
			$config_customername_textbox.text = $cis.customername
			$config_logfoldertarger_textbox.text = $cis.logfoldertarget;
			$config_packagefolder_textbox.text = $cis.packagefolder;
			$config_download_folder_textbox3.Text = $cis.downloadpath
			$config_buildingblocks_textbox3.Text = $cis.buildingblockspath
			if ($cis.downloadpath -like 'Enter UNC or local path for the download Package folder. (Evergreen / Winget)')
			{
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show('Download folder was added to config. Please use this tool or edit "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" ', 'Please add Download folder') # Casting the method to [void] suppresses the output. 
			}
			
			try
			{
				New-Variable -Name 'config_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_customername' -Value $cis.customername -Scope Script
			}
			try
			{
				New-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
			}
			try
			{
				New-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_packagefolder' -Value $cis.packagefolder -Scope Script
			}
			try
			{
				New-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_downloadpath' -Value $cis.downloadpath -Scope Script
			}
			try
			{
				New-Variable -Name 'config_buildingblockspath' -Value $cis.buildingblockspath -Scope Script -ErrorAction Stop
			}
			catch
			{
				Set-Variable -Name 'config_buildingblockspath' -Value $cis.buildingblockspath -Scope Script
			}
		
			$toolstripstatuslabel1.Text = "Selected Customer: $config_customername"
		}
	}
	
}



$config_new_button_Click = {
	#TODO: Place custom script here
	$config_customername_textbox.text = "Enter Customer name here"
	$config_logfoldertarger_textbox.text = "Enter log directory used by scripting on target; Example c:\ProgramData\customername\logs"
	$config_packagefolder_textbox.text = "Enter local path where packages & scripts will be stored; Example c:\sources\"
	$config_download_folder_textbox3.Text = "Enter UNC or local path for the download Package folder. (Evergreen / Winget)"
	$config_buildingblocks_textbox3.Text = "Enter local path where Building Blocks will be stored; Example c:\BuildingBlocks\"
}

$tools_winget_search_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $true
	$tools_datagridview1.Visible = $true
	$tools_Output_textbox1.Enabled = $false
	$tools_Output_textbox1.Visible = $false
	
	
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$tools_wsearchstring = $tools_search_winget_textbox.text
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	$wsearch__winget_search_output = winget search $tools_wsearchstring --accept-source-agreements
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			
			$tools_datagridview1.DataSource = $table;
		}
		
	}
	
}

$tools_show_winget_button_Click = {
	#TODO: Place custom script here
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	<#
	$winget_exe = Resolve-Path "\Microsoft.DesktopAppInstaller_1.19.10173.0_x64__8wekyb3d8bbwe\winget.exe"
	if ($winget_exe.count -gt 1)
	{
		$winget_exe = $winget_exe[-1].Path
	}
	
	if (!$winget_exe)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Install winget", 'No Winget found') # Casting the method to [void] suppresses the output. 
	}
	
	#>
	$tools_winget_show_string = $tools_show_winget.text
	$tools_winget_id = winget show $tools_winget_show_string --accept-source-agreements
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
}

$tools_show_winget_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_locale_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_locale_checkbox1.Checked -eq $true)
	{
		$winget_locale_label.Enabled = $true
		$winget_locale_label.Visible = $true
		$Winget_locale_textbox.Enabled = $true
		$Winget_locale_textbox.Visible = $true
	}
	else
	{
		$winget_locale_label.Enabled = $false
		$winget_locale_label.Visible = $false
		$Winget_locale_textbox.Enabled = $false
		$Winget_locale_textbox.Visible = $false
	}
}

$Winget_locale_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_version_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($winget_version_checkbox.Checked -eq $true)
	{
		$winget_version_label1.Enabled = $true
		$winget_version_label1.Visible = $true
		$winget_version_textbox1.Enabled = $true
		$winget_version_textbox1.Visible = $true
	}
	else
	{
		$winget_version_label1.Enabled = $false
		$winget_version_label1.Visible = $false
		$winget_version_textbox1.Enabled = $false
		$winget_version_textbox1.Visible = $false
	}
}

$tools_versions_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_winget_show_versions_button_Click = {
	
	$tools_datagridview1.Enabled = $false
	$tools_datagridview1.Visible = $false
	$tools_Output_textbox1.Enabled = $true
	$tools_Output_textbox1.Visible = $true
	
	
	$tools_winget_show_string = $tools_versions_winget_textbox.text
	$tools_winget_id = winget show $tools_winget_show_string --versions --accept-source-agreements
	
	
	$tools_Output_textbox1.Text = "Search results: `r`n"
	foreach ($twi in $tools_winget_id)
	{
		
		$tools_Output_textbox1.AppendText("$twi `r`n")
	}
	
}

$exe_open_sourcedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$exepnaam = $exe_packagenaam_textbox1.text
	$exeversie = $exe_versie_textbox1.text
	Invoke-Item "$config_packagefolder\$exepnaam\$exeversie\source"
}

$msi_labelPackageName_Click = {
	#TODO: Place custom script here
	
}


$tools_search_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_search_output_button1_Click = {
	#TODO: Place custom script here
	
}

$deP_label3_Click = {
	#TODO: Place custom script here
	
}

$tools_tabpage7_Click = {
	#TODO: Place custom script here
	
}

$upload_checkboxSetupAssignmentLikeP_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllDevice_CheckedChanged = {
	#TODO: Place custom script here
	
}

$upload_checkboxRequiredForAllUsers_CheckedChanged = {
	#TODO: Place custom script here
	
}

$Upload_beschikbaar_all_users_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$weblink_ico_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$shortcut_openfiledialog1.ShowDialog()
	[string]$ICO_org_path = $shortcut_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	Copy-Item -Path $ICO_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\$weblinkName.ico" -ErrorAction Stop
	
	$weblink_output_textbox1.AppendText("*.ICO now available in source directory `r`n")
	$weblink_ico_label1.text = $shortcut_openfiledialog1.SafeFileName
	$weblink_ico_label1.Visible = $true;
	$weblink_ico_label1.Enabled = $true;
	$weblink_logo_png_button1.Visible = $true
	$weblink_logo_png_button1.Enabled = $true
	$weblink_output_textbox1.AppendText("Now upload *.png file `r`n")
	
	
	
	
}

$weblink_create_intunewin_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\" -s "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -o "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\" -q
	Rename-Item -Path "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\install.intunewin" -NewName "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkPackageName.intunewin"
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\"
	$weblink_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\$weblinkName.intunewin")
	$weblink_output_textbox1.AppendText("`r`n")
	
	$weblink_output_textbox1.AppendText("Install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$weblink_output_textbox1.AppendText("un-install command is: `r`n")
	$weblink_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$weblink_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$weblinkPackageName\"
	$regkeyApp
	$weblink_output_textbox1.AppendText("$regkeyApp `r`n")
	$weblink_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$weblink_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$weblink_output_textbox1.AppendText("Detection Value is: $weblinkVersion `r`n")
	$weblink_output_textbox1.AppendText("Please reopen tool to make another Weblink package `r`n")
	
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$weblinkPackageName.intunewin"
			DisplayName   = $weblinkPackageName
			Publisher	  = $config_customername
			AppVersion    = $weblinkVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\config.csv" -NoTypeInformation
	$weblink_output_textbox1.AppendText("Config.csv written to: `r`n")
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkPackageName\$weblinkVersion\Output\\config.csv")
	$weblink_output_textbox1.AppendText("  `r`n")
	$weblink_output_textbox1.AppendText("Use config file to upload package to Intune. `r`n")
	
}

$config_delete_button1_Click = {
	#TODO: Place custom script here
	
	$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv"
	$config_customerinfo = $null;
	Remove-Item "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -Confirm:$false
	foreach ($cis in $config_import_csv)
	{
		if ($cis.customername -ne $config_listbox.SelectedItem)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername    = $cis.customername
					logfoldertarget = $cis.logfoldertarget
					packagefolder   = $cis.packagefolder
					downloadpath    = $cis.downloadpath
					buildingblockspath = $cis.buildingblockspath
				})
		}
		
		
	}
	
	
	
	
	
	$config_customerinfo | Export-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -NoTypeInformation
	$config_listbox.Items.Clear()
	
	try
	{
		$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		foreach ($cis in $config_import_csv)
		{
			Update-ListBox $config_listbox $cis.customername -Append
		}
		
	}
	catch
	{
		
		Write-Host "Taak hier"
		
	}
	
	
}

$weblink_logo_png_button1_Click = {
	#TODO: Place custom script here
	
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblink_logo_openfiledialog1.ShowDialog()
	[string]$weblinkLogo_org_path = $weblink_logo_openfiledialog1.FileNames
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	Copy-Item -Path $weblinkLogo_org_path -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\output\logo.png" -ErrorAction Stop
	$weblink_output_textbox1.AppendText("Logo.PNG now available in Output directory `r`n")
	$weblink_png_label1.text = $weblink_logo_openfiledialog1.SafeFileName
	$weblink_png_label1.Enabled = $true
	$weblink_png_label1.Visible = $true
	$weblink_create_scripts_button1.Enabled = $true
	$weblink_create_scripts_button1.Visible = $true
	$weblink_output_textbox1.AppendText("Click Create scripts to create install.ps1 and uninstall.ps1 `r`n")
}

$weblink_test_install_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$weblink_create_scripts_button1_Click = {
	#TODO: Place custom script here
	$weblink_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}


#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will now copy ICO file"
	Copy-Item "$Name.ico" "$logdir\ico\$Name.ico" -confirm:$false
	Write-Host "Script will now create extra folder in startmenu (when needed)"
  if (!(Test-Path -Path $location))
{
	
	New-Item -ItemType Directory -Path $location
}

	Write-Host "Script will now create shortcut"
	fCreateShortcut -TargetFile $browser -shortcutName $Name -ShortcutArguments $URL -icon "$logdir\ico\$Name.ico" -programmenu $location
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	$weblink_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.218
	 Created on:   	27/04/2023 13:14
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Script genererated with:
		https://github.com/rink-turksma/IntunePrepTool
#>

$packagename = "!!packagename!!"
$Name = "!!Name!!"
$version = "!!Version!!"
$URL = "!!URL!!"
$location = "!!Location!!"
$browser = "!!Browser!!"
$ICOFile = "!!ICOFile!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$packagename$Version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$packagename"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create ICO direcotry if needed.
if (!(Test-Path -Path $logdir\ico))
{
	
	New-Item -ItemType Directory -Path $logdir\ico
}

##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### Functie zorgt voor naar succesvolle of onsuccesvolle uitvoering..
	### Uiteindelijk heb je dan bijvoorbeeld:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### Met een Versie waarde en een [BOOL]Succes waarde
	### Gebruik: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType Dword
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType Dword
	}
}
function fCreateShortcut
{
	### Function creates shortcut
	
	param
	(
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[string]$shortcutName,
		[string]$icon,
		[string]$ShortcutArguments,
		[string]$programmenu
	)
	
	
	$browser = $TargetFile
	$wdirCount = $browser.Split("\").Count
	$eraf = $browser.Split("\")[$wdirCount - 1]
	$workingdir = $browser.TrimEnd($eraf)
	$ShortcutFile = "$programmenu\$shortcutName.lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.WorkingDirectory = $workingdir
	if ($Icon)
	{
		$Shortcut.IconLocation = $Icon
	}
	if ($ShortcutArguments)
	{
		$Shortcut.Arguments = $ShortcutArguments
	}
	$Shortcut.Save()
	
}



<# Einde Powershell Functies
Hier dus nog geen script uitvoering doen
#>

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}




#Start Transcript.  Dit gaat opgeslagen onder de  $logdir. Zal daar in txt file beschikbaar zijn. En in de eventviewer.
Start-Transcript -Path $logfile

<#--Hieronder start Script ter installatie---
	Hier kan dus 1 van de functies gedeclareerd hierboven gebruikt worden.
	Altijd met een -ErrorAction Stop erachter
#>


try
{
	Write-Host "Script will remove ICO file and Lnk file"
	Remove-Item $logdir\ico\$Name.ico -confirm:$false
	Remove-Item $location\$Name.lnk -confirm:$false
	$excode = 0
}
catch
{
	
	$excode = 1
}


<#----Hieronder einde script voor installatie---#>
#Nu wordt de Transcript logging gestart
Stop-Transcript
#Na die commando wordt dit dus automatisch opgeslagen in de $logdir locatie
#Hier is wat om de log zo te splitsen zodat we enkel de laatste run hebben.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In de try / catch in de uitvoering hebben we $excode op 0 of op 1 gezet
# Op basis hiervan wordt de Log in de Event viewer op Error of op Informational gezet.
# Daarnaast wordt de eerder gedeclareerde functie fDetectionInRegistry ingezet die de detectiemethodiek in het register plaats met of een succesvolle melding van applicatie of onsuccesvol
if ($excode -eq 1) { $warning = 'Error'; fDetectionInRegistry -succes $false }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$weblinkName = $weblink_Name.Text
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	$weblinkPackageName = $weblink_packagename.Text
	$weblinkICOFile = "$weblinkName.ico"
	$logdir = $config_logfoldertarget
	$RegisterDetectionroot = "Intune_" + $config_customername
	$weblink_installFile = $weblink_installFile.Replace("!!packagename!!", $weblinkPackageName)
	$weblink_installFile = $weblink_installFile.Replace("!!Name!!", $weblinkName)
	$weblink_installFile = $weblink_installFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_installFile = $weblink_installFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_installFile = $weblink_installFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_installFile = $weblink_installFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_installFile = $weblink_installFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_installFile = $weblink_installFile.Replace("!!logdir!!", $logdir)
	$weblink_installFile = $weblink_installFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!packagename", $weblinkPackageName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Name!!", $weblinkName)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Version!!", $weblinkVersion)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!URL!!", $weblinkUrl)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Location!!", $weblinkLocation)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!Browser!!", $weblinkBrowser)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!ICOFile!!", $weblinkICOFile)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!logdir!!", $logdir)
	$weblink_uninstallFile = $weblink_uninstallFile.Replace("!!RegisterDetectionroot!!", $RegisterDetectionroot)
	$weblink_installFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\install.ps1" -force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$weblink_uninstallFile | Out-File "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1" -force
	$weblink_output_textbox1.AppendText("Install.ps1 and uninstall.ps1 created `r`n")
	$weblink_output_textbox1.AppendText("You can now test install and uninstall `r`n")
	$weblink_output_textbox1.AppendText("You can save changes in script if needed `r`n")
	$weblink_output_textbox1.AppendText("Then create Intunewin file`r`n")
	$weblink_test_install_button1.Visible = $true
	$weblink_test_install_button1.Enabled = $true
	$weblink_test_uninstall_button1.Visible = $true
	$weblink_test_uninstall_button1.Enabled = $true
	$weblink_create_intunewin_button1.Visible = $true
	$weblink_create_intunewin_button1.Enabled = $true
	
}



$weblink_create_packagedir_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$weblinkName = $weblink_packagename.Text
	$weblinkName = $weblinkName -replace (" ", "")
	$weblink_packagename.Text = $weblinkName
	$weblinkUrl = $weblink_url_textbox1.Text
	$weblinkLocation = $weblink_location_textbox1.Text
	$weblinkBrowser = $weblink_browser_textbox1.Text
	$weblinkVersion = $weblink_version_textbox1.Text
	
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\source"
	}
	if (!(Test-Path -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"))
	{
		
		New-Item -ItemType Directory -Path "$config_packagefolder\$weblinkName\$weblinkVersion\output"
	}
	$weblink_output_textbox1.Text = "`nNew package direcotory created: `r`n"
	$weblink_output_textbox1.AppendText("$config_packagefolder\$weblinkName\$weblinkVersion\")
	$weblink_output_textbox1.AppendText(" `r`n")
	$weblink_output_textbox1.AppendText("Now Upload *.ICO file `r`n")
	$weblink_ico_button1.Enabled = $true
	$weblink_ico_button1.Visible = $true
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_browser_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_location_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_url_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$weblink_Name_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$weblink_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation using Powershell_ISE?. ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$weblinkName = $weblink_Name.Text
		$weblinkVersion = $weblink_version_textbox1.Text
		$weblinkPackageName = $weblink_packagename.Text
		
		
		powershell_ise -file "$config_packagefolder\$weblinkPackageName\$weblinkVersion\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$helpbutton1_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://github.com/rink-turksma/IntunePrepTool'
}

$winget_displayname_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_create_scripts_button1_Click = {
	#TODO: Place custom script here
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$version = $versie_textbox2.Text
		if ($version -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
			$wid = $winget_WingetID_textbox1.text
			$DisplayName = $winget_displayname_textbox1.text
			$fid = $config_packagefolder
			if ($winget_locale_checkbox1.Checked -eq $true)
			{
				$wlo = $Winget_locale_textbox.text
				
			}
			else { $wlo = $null; }
			if ($winget_version_checkbox.Checked -eq $true)
			{
				$wve = $winget_version_textbox1.text
			}
			else { $wve = $null; }
			$WinGetID = $wid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			$outputDirectory = $fid
			
			$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.259
	 Created on:   	13-9-2025 11:16
	 Created by:   	Rink Turksma
	 Organization: 	https://intunepreptool.com
	 Filename:     	Winget_install_uninstall.ps1
	===========================================================================
#>
# Variables will be provided from IntunePrepTool
$WinGetID = "!!WinGetID!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$version = "!!version!!"
$locale = "!!locale!!"
$localeSelected = "!!localeSelected!!"
$versionWinget = "!!versionWinget!!"
$versionWingetSelected = "!!versionSelected!!"
$includeWingetRequirment = "!!includeWingetRequirment!!"
#Dyn vars
$regApp1 = $DisplayName
$logfile = $(Join-Path $logdir  "$DisplayName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null;
#Creates logdirectory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Create registry application key.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
#Start Powershell functions
function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution.
	### Ultimately, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $True
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functies
#>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}



#Start Transcript.  Will be saved under  $logdir.
Start-Transcript -Path $logfile
$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($ResolveWingetPath)
{
	$WingetPath = $ResolveWingetPath[-1].Path
	$wingetexe = $WingetPath
}


if (Test-path $WingetPath -ErrorAction SilentlyContinue)
{
	
	Write-Host "We are now checking the version of Winget"
	$wingetOption = 1
	$versionW = & $wingetexe --version
	Write-Host $versionW
}
else
{
	Write-Host "We are now checking the version of Winget"
	$wingetOption = 2
	$versionW = winget --version
	write-host $versionW
}


if ($versionW -notlike 'v*')
{
	Write-Host "Winget Version does not match.. installing now"
	[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
	$msixUrl = "https://github.com/microsoft/winget-cli/releases/download/v1.11.430/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
	$msixPath = "$($env:TEMP)\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
	(New-Object System.Net.WebClient).DownloadFile($msixUrl, $msixPath)
	
	try
	{
		Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
		Write-Host "Winget installation completed successfully."
	}
	catch
	{
		if ($_.Exception.Message -match "Microsoft.VCLibs.140.00.UWPDesktop")
		{
			Write-Host "Now downloading: Missing dependency 'Microsoft.VCLibs.140.00.UWPDesktop'."
			[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
			$dependencyURL = 'https://github.com/microsoft/winget-cli/releases/download/v1.11.430/DesktopAppInstaller_Dependencies.zip'
			$dependencyPath = "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
			(New-Object System.Net.WebClient).DownloadFile($dependencyURL, $dependencyPath)
			unblock-file "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
			Expand-Archive -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip" -DestinationPath "$($env:TEMP)\DesktopAppInstaller_Dependencies"
			write-host "Now installing dependency"
			try
			{
				Add-AppxPackage -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies\x64\Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64.appx" -ErrorAction Stop
				write-host "Installing depedency done"
			}
			catch
			{
				Write-host "Installing depedency failed"
				Write-Host "An unexpected error occurred: $($_.Exception.Message)"
			}
			try
			{
				write-host "Now trying to install Winget again"
				Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
				write-host "Install winget done"
			}
			catch
			{
				Write-Host "An unexpected error occurred: $($_.Exception.Message)"
			}
		}
		else
		{
			Write-Host "An unexpected error occurred: $($_.Exception.Message)"
		}
	}
	$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
	if ($ResolveWingetPath)
	{
		$WingetPath = $ResolveWingetPath[-1].Path
	}
	$wingetexe = $WingetPath
	
	if (Test-path $wingetexe)
	{
		
		Write-Host "We are now checking the version of Winget"
		$wingetOption = 1
		$versionW = & $wingetexe --version
		Write-Host $versionW
	}
	else
	{
		Write-Host "We are now checking the version of Winget"
		$wingetOption = 2
		$versionW = winget --version
		write-host $versionW
	}
}
else
{
	write-host "Winget already active"
}
$loglocation = 'C:\Windows\Temp\intunepreptoolwinget.txt'
if (Test-Path $loglocation) { Remove-Item $loglocation -Confirm:$false }
$TreatAsSuccessCodes = @(
	-1978335189, # 0x8A15002B UPDATE_NOT_APPLICABLE
	-1978335153, # 0x8A15004F UPGRADE_VERSION_NOT_NEWER
	-1978335135 # 0x8A150061 PACKAGE_ALREADY_INSTALLED
)


$BenignVerbatim = @(
	'No applicable upgrade found',
	'Found an existing package already installed'
)


$PatternRules = New-Object System.Collections.ArrayList

function ConvertTo-RegexFromPhrase
{
	param ([Parameter(Mandatory)]
		[string]$Text)
	if ([string]::IsNullOrWhiteSpace($Text)) { return $null }
	$escaped = [regex]::Escape($Text)
	$escaped = $escaped -replace '\\\s+', '\s+' -replace '\s+', '\s+'
	return "(?i)$escaped"
}

function Add-Rule
{
	param (
		[Parameter(Mandatory)]
		[System.Collections.IList]$Rules,
		[Parameter(Mandatory)]
		[string]$Regex,
		[Parameter(Mandatory)]
		[string]$Description,
		[Parameter(Mandatory)]
		[bool]$TreatAsSuccess
	)
	if ($null -eq $Rules) { throw "Rules list is null." }
	if ([string]::IsNullOrWhiteSpace($Regex)) { return }
	[void]$Rules.Add([pscustomobject]@{
			Regex		   = $Regex
			Description    = $Description
			TreatAsSuccess = $TreatAsSuccess
		})
}
function Convert-ToHex32
{
	param ([Parameter(Mandatory)]
		[object]$Value)
	
	$v = [int64]$Value
	$mask = 0x00000000FFFFFFFF # this is a positive Int64 (4294967295)
	$n = $v -band $mask # low 32 bits as a non-negative Int64
	
	return ('0x{0:X8}' -f $n)
}
function Write-Log
{
	param ([string]$Path,
		[string]$Message)
	Add-Content -Path $Path -Value $Message -Encoding UTF8
}


$WingetErrorCatalog = [ordered]@{
	-1978335231 = @{ Hex = '0x8A150001'; Symbol = 'APPINSTALLER_CLI_ERROR_INTERNAL_ERROR'; Description = 'Internal Error' }
	-1978335230 = @{ Hex = '0x8A150002'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_CL_ARGUMENTS'; Description = 'Invalid command line arguments' }
	-1978335229 = @{ Hex = '0x8A150003'; Symbol = 'APPINSTALLER_CLI_ERROR_COMMAND_FAILED'; Description = 'Executing command failed' }
	-1978335228 = @{ Hex = '0x8A150004'; Symbol = 'APPINSTALLER_CLI_ERROR_MANIFEST_FAILED'; Description = 'Opening manifest failed' }
	-1978335227 = @{ Hex = '0x8A150005'; Symbol = 'APPINSTALLER_CLI_ERROR_CTRL_SIGNAL_RECEIVED'; Description = 'Cancellation signal received' }
	-1978335226 = @{ Hex = '0x8A150006'; Symbol = 'APPINSTALLER_CLI_ERROR_SHELLEXEC_INSTALL_FAILED'; Description = 'Running ShellExecute failed' }
	-1978335225 = @{ Hex = '0x8A150007'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_MANIFESTVERSION'; Description = 'Cannot process manifest. The manifest version is higher than supported. Please update the client.' }
	-1978335224 = @{ Hex = '0x8A150008'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_FAILED'; Description = 'Downloading installer failed' }
	-1978335223 = @{ Hex = '0x8A150009'; Symbol = 'APPINSTALLER_CLI_ERROR_CANNOT_WRITE_TO_UPLEVEL_INDEX'; Description = 'Cannot write to index; it is a higher schema version' }
	-1978335222 = @{ Hex = '0x8A15000A'; Symbol = 'APPINSTALLER_CLI_ERROR_INDEX_INTEGRITY_COMPROMISED'; Description = 'The index is corrupt' }
	-1978335221 = @{ Hex = '0x8A15000B'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCES_INVALID'; Description = 'The configured source information is corrupt' }
	-1978335220 = @{ Hex = '0x8A15000C'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NAME_ALREADY_EXISTS'; Description = 'The source name is already configured' }
	-1978335219 = @{ Hex = '0x8A15000D'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_SOURCE_TYPE'; Description = 'The source type is invalid' }
	-1978335218 = @{ Hex = '0x8A15000E'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_IS_BUNDLE'; Description = 'The MSIX file is a bundle, not a package' }
	-1978335217 = @{ Hex = '0x8A15000F'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_DATA_MISSING'; Description = 'Data required by the source is missing' }
	-1978335216 = @{ Hex = '0x8A150010'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICABLE_INSTALLER'; Description = 'None of the installers are applicable for the current system' }
	-1978335215 = @{ Hex = '0x8A150011'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_HASH_MISMATCH'; Description = "The installer file's hash does not match the manifest" }
	-1978335214 = @{ Hex = '0x8A150012'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NAME_DOES_NOT_EXIST'; Description = 'The source name does not exist' }
	-1978335213 = @{ Hex = '0x8A150013'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_ARG_ALREADY_EXISTS'; Description = 'The source location is already configured under another name' }
	-1978335212 = @{ Hex = '0x8A150014'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICATIONS_FOUND'; Description = 'No packages found' }
	-1978335211 = @{ Hex = '0x8A150015'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_SOURCES_DEFINED'; Description = 'No sources are configured' }
	-1978335210 = @{ Hex = '0x8A150016'; Symbol = 'APPINSTALLER_CLI_ERROR_MULTIPLE_APPLICATIONS_FOUND'; Description = 'Multiple packages found matching the criteria' }
	-1978335209 = @{ Hex = '0x8A150017'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_MANIFEST_FOUND'; Description = 'No manifest found matching the criteria' }
	-1978335208 = @{ Hex = '0x8A150018'; Symbol = 'APPINSTALLER_CLI_ERROR_EXTENSION_PUBLIC_FAILED'; Description = 'Failed to get Public folder from source package' }
	-1978335207 = @{ Hex = '0x8A150019'; Symbol = 'APPINSTALLER_CLI_ERROR_COMMAND_REQUIRES_ADMIN'; Description = 'Command requires administrator privileges to run' }
	-1978335206 = @{ Hex = '0x8A15001A'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NOT_SECURE'; Description = 'The source location is not secure' }
	-1978335205 = @{ Hex = '0x8A15001B'; Symbol = 'APPINSTALLER_CLI_ERROR_MSSTORE_BLOCKED_BY_POLICY'; Description = 'The Microsoft Store client is blocked by policy' }
	-1978335204 = @{ Hex = '0x8A15001C'; Symbol = 'APPINSTALLER_CLI_ERROR_MSSTORE_APP_BLOCKED_BY_POLICY'; Description = 'The Microsoft Store app is blocked by policy' }
	-1978335203 = @{ Hex = '0x8A15001D'; Symbol = 'APPINSTALLER_CLI_ERROR_EXPERIMENTAL_FEATURE_DISABLED'; Description = 'The feature is currently under development. It can be enabled using winget settings.' }
	-1978335202 = @{ Hex = '0x8A15001E'; Symbol = 'APPINSTALLER_CLI_ERROR_MSSTORE_INSTALL_FAILED'; Description = 'Failed to install the Microsoft Store app' }
	-1978335201 = @{ Hex = '0x8A15001F'; Symbol = 'APPINSTALLER_CLI_ERROR_COMPLETE_INPUT_BAD'; Description = 'Failed to perform auto complete' }
	-1978335200 = @{ Hex = '0x8A150020'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INIT_FAILED'; Description = 'Failed to initialize YAML parser' }
	-1978335199 = @{ Hex = '0x8A150021'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_MAPPING_KEY'; Description = 'Encountered an invalid YAML key' }
	-1978335198 = @{ Hex = '0x8A150022'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_DUPLICATE_MAPPING_KEY'; Description = 'Encountered a duplicate YAML key' }
	-1978335197 = @{ Hex = '0x8A150023'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_OPERATION'; Description = 'Invalid YAML operation' }
	-1978335196 = @{ Hex = '0x8A150024'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_DOC_BUILD_FAILED'; Description = 'Failed to build YAML doc' }
	-1978335195 = @{ Hex = '0x8A150025'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_EMITTER_STATE'; Description = 'Invalid YAML emitter state' }
	-1978335194 = @{ Hex = '0x8A150026'; Symbol = 'APPINSTALLER_CLI_ERROR_YAML_INVALID_DATA'; Description = 'Invalid YAML data' }
	-1978335193 = @{ Hex = '0x8A150027'; Symbol = 'APPINSTALLER_CLI_ERROR_LIBYAML_ERROR'; Description = 'LibYAML error' }
	-1978335192 = @{ Hex = '0x8A150028'; Symbol = 'APPINSTALLER_CLI_ERROR_MANIFEST_VALIDATION_WARNING'; Description = 'Manifest validation succeeded with warning' }
	-1978335191 = @{ Hex = '0x8A150029'; Symbol = 'APPINSTALLER_CLI_ERROR_MANIFEST_VALIDATION_FAILURE'; Description = 'Manifest validation failed' }
	-1978335190 = @{ Hex = '0x8A15002A'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_MANIFEST'; Description = 'Manifest is invalid' }
	-1978335189 = @{ Hex = '0x8A15002B'; Symbol = 'APPINSTALLER_CLI_ERROR_UPDATE_NOT_APPLICABLE'; Description = 'No applicable update found' }
	-1978335188 = @{ Hex = '0x8A15002C'; Symbol = 'APPINSTALLER_CLI_ERROR_UPDATE_ALL_HAS_FAILURE'; Description = 'winget upgrade --all completed with failures' }
	-1978335187 = @{ Hex = '0x8A15002D'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_SECURITY_CHECK_FAILED'; Description = 'Installer failed security check' }
	-1978335186 = @{ Hex = '0x8A15002E'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_SIZE_MISMATCH'; Description = 'Download size does not match expected content length' }
	-1978335185 = @{ Hex = '0x8A15002F'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_UNINSTALL_INFO_FOUND'; Description = 'Uninstall command not found' }
	-1978335184 = @{ Hex = '0x8A150030'; Symbol = 'APPINSTALLER_CLI_ERROR_EXEC_UNINSTALL_COMMAND_FAILED'; Description = 'Running uninstall command failed' }
	-1978335183 = @{ Hex = '0x8A150031'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_BREAK_ITERATOR_ERROR'; Description = 'ICU break iterator error' }
	-1978335182 = @{ Hex = '0x8A150032'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_CASEMAP_ERROR'; Description = 'ICU casemap error' }
	-1978335181 = @{ Hex = '0x8A150033'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_REGEX_ERROR'; Description = 'ICU regex error' }
	-1978335180 = @{ Hex = '0x8A150034'; Symbol = 'APPINSTALLER_CLI_ERROR_IMPORT_INSTALL_FAILED'; Description = 'Failed to install one or more imported packages' }
	-1978335179 = @{ Hex = '0x8A150035'; Symbol = 'APPINSTALLER_CLI_ERROR_NOT_ALL_PACKAGES_FOUND'; Description = 'Could not find one or more requested packages' }
	-1978335178 = @{ Hex = '0x8A150036'; Symbol = 'APPINSTALLER_CLI_ERROR_JSON_INVALID_FILE'; Description = 'Json file is invalid' }
	-1978335177 = @{ Hex = '0x8A150037'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_NOT_REMOTE'; Description = 'The source location is not remote' }
	-1978335176 = @{ Hex = '0x8A150038'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_RESTSOURCE'; Description = 'The configured rest source is not supported' }
	-1978335175 = @{ Hex = '0x8A150039'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTSOURCE_INVALID_DATA'; Description = 'Invalid data returned by rest source' }
	-1978335174 = @{ Hex = '0x8A15003A'; Symbol = 'APPINSTALLER_CLI_ERROR_BLOCKED_BY_POLICY'; Description = 'Operation is blocked by Group Policy' }
	-1978335173 = @{ Hex = '0x8A15003B'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTAPI_INTERNAL_ERROR'; Description = 'Rest API internal error' }
	-1978335172 = @{ Hex = '0x8A15003C'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTSOURCE_INVALID_URL'; Description = 'Invalid rest source url' }
	-1978335171 = @{ Hex = '0x8A15003D'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTAPI_UNSUPPORTED_MIME_TYPE'; Description = 'Unsupported MIME type returned by rest API' }
	-1978335170 = @{ Hex = '0x8A15003E'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTSOURCE_INVALID_VERSION'; Description = 'Invalid rest source contract version' }
	-1978335169 = @{ Hex = '0x8A15003F'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_DATA_INTEGRITY_FAILURE'; Description = 'The source data is corrupted or tampered' }
	-1978335168 = @{ Hex = '0x8A150040'; Symbol = 'APPINSTALLER_CLI_ERROR_STREAM_READ_FAILURE'; Description = 'Error reading from the stream' }
	-1978335167 = @{ Hex = '0x8A150041'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_AGREEMENTS_NOT_ACCEPTED'; Description = 'Package agreements were not agreed to' }
	-1978335166 = @{ Hex = '0x8A150042'; Symbol = 'APPINSTALLER_CLI_ERROR_PROMPT_INPUT_ERROR'; Description = 'Error reading input in prompt' }
	-1978335165 = @{ Hex = '0x8A150043'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_SOURCE_REQUEST'; Description = 'The search request is not supported by one or more sources' }
	-1978335164 = @{ Hex = '0x8A150044'; Symbol = 'APPINSTALLER_CLI_ERROR_RESTAPI_ENDPOINT_NOT_FOUND'; Description = 'The rest API endpoint is not found.' }
	-1978335163 = @{ Hex = '0x8A150045'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_OPEN_FAILED'; Description = 'Failed to open the source.' }
	-1978335162 = @{ Hex = '0x8A150046'; Symbol = 'APPINSTALLER_CLI_ERROR_SOURCE_AGREEMENTS_NOT_ACCEPTED'; Description = 'Source agreements were not agreed to' }
	-1978335161 = @{ Hex = '0x8A150047'; Symbol = 'APPINSTALLER_CLI_ERROR_CUSTOMHEADER_EXCEEDS_MAXLENGTH'; Description = 'Header size exceeds the allowable limit of 1024 characters. Please reduce the size and try again.' }
	-1978335160 = @{ Hex = '0x8A150048'; Symbol = 'APPINSTALLER_CLI_ERROR_MISSING_RESOURCE_FILE'; Description = 'Missing resource file' }
	-1978335159 = @{ Hex = '0x8A150049'; Symbol = 'APPINSTALLER_CLI_ERROR_MSI_INSTALL_FAILED'; Description = 'Running MSI install failed' }
	-1978335158 = @{ Hex = '0x8A15004A'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_MSIEXEC_ARGUMENT'; Description = 'Arguments for msiexec are invalid' }
	-1978335157 = @{ Hex = '0x8A15004B'; Symbol = 'APPINSTALLER_CLI_ERROR_FAILED_TO_OPEN_ALL_SOURCES'; Description = 'Failed to open one or more sources' }
	-1978335156 = @{ Hex = '0x8A15004C'; Symbol = 'APPINSTALLER_CLI_ERROR_DEPENDENCIES_VALIDATION_FAILED'; Description = 'Failed to validate dependencies' }
	-1978335155 = @{ Hex = '0x8A15004D'; Symbol = 'APPINSTALLER_CLI_ERROR_MISSING_PACKAGE'; Description = 'One or more package is missing' }
	-1978335154 = @{ Hex = '0x8A15004E'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_TABLE_COLUMN'; Description = 'Invalid table column' }
	-1978335153 = @{ Hex = '0x8A15004F'; Symbol = 'APPINSTALLER_CLI_ERROR_UPGRADE_VERSION_NOT_NEWER'; Description = 'The upgrade version is not newer than the installed version' }
	-1978335152 = @{ Hex = '0x8A150050'; Symbol = 'APPINSTALLER_CLI_ERROR_UPGRADE_VERSION_UNKNOWN'; Description = 'Upgrade version is unknown and override is not specified' }
	-1978335151 = @{ Hex = '0x8A150051'; Symbol = 'APPINSTALLER_CLI_ERROR_ICU_CONVERSION_ERROR'; Description = 'ICU conversion error' }
	-1978335150 = @{ Hex = '0x8A150052'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_INSTALL_FAILED'; Description = 'Failed to install portable package' }
	-1978335149 = @{ Hex = '0x8A150053'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_REPARSE_POINT_NOT_SUPPORTED'; Description = 'Volume does not support reparse points.' }
	-1978335148 = @{ Hex = '0x8A150054'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_PACKAGE_ALREADY_EXISTS'; Description = 'Portable package from a different source already exists.' }
	-1978335147 = @{ Hex = '0x8A150055'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_SYMLINK_PATH_IS_DIRECTORY'; Description = 'Unable to create symlink, path points to a directory.' }
	-1978335146 = @{ Hex = '0x8A150056'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_PROHIBITS_ELEVATION'; Description = 'The installer cannot be run from an administrator context.' }
	-1978335145 = @{ Hex = '0x8A150057'; Symbol = 'APPINSTALLER_CLI_ERROR_PORTABLE_UNINSTALL_FAILED'; Description = 'Failed to uninstall portable package' }
	-1978335144 = @{ Hex = '0x8A150058'; Symbol = 'APPINSTALLER_CLI_ERROR_ARP_VERSION_VALIDATION_FAILED'; Description = 'Failed to validate DisplayVersion values against index.' }
	-1978335143 = @{ Hex = '0x8A150059'; Symbol = 'APPINSTALLER_CLI_ERROR_UNSUPPORTED_ARGUMENT'; Description = 'One or more arguments are not supported.' }
	-1978335142 = @{ Hex = '0x8A15005A'; Symbol = 'APPINSTALLER_CLI_ERROR_BIND_WITH_EMBEDDED_NULL'; Description = 'Embedded null characters are disallowed for SQLite' }
	-1978335141 = @{ Hex = '0x8A15005B'; Symbol = 'APPINSTALLER_CLI_ERROR_NESTEDINSTALLER_NOT_FOUND'; Description = 'Failed to find the nested installer in the archive.' }
	-1978335140 = @{ Hex = '0x8A15005C'; Symbol = 'APPINSTALLER_CLI_ERROR_EXTRACT_ARCHIVE_FAILED'; Description = 'Failed to extract archive.' }
	-1978335139 = @{ Hex = '0x8A15005D'; Symbol = 'APPINSTALLER_CLI_ERROR_NESTEDINSTALLER_INVALID_PATH'; Description = 'Invalid relative file path to nested installer provided.' }
	-1978335138 = @{ Hex = '0x8A15005E'; Symbol = 'APPINSTALLER_CLI_ERROR_PINNED_CERTIFICATE_MISMATCH'; Description = 'The server certificate did not match any of the expected values.' }
	-1978335137 = @{ Hex = '0x8A15005F'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALL_LOCATION_REQUIRED'; Description = 'Install location must be provided.' }
	-1978335136 = @{ Hex = '0x8A150060'; Symbol = 'APPINSTALLER_CLI_ERROR_ARCHIVE_SCAN_FAILED'; Description = 'Archive malware scan failed.' }
	-1978335135 = @{ Hex = '0x8A150061'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_ALREADY_INSTALLED'; Description = 'Found at least one version of the package installed.' }
	-1978335134 = @{ Hex = '0x8A150062'; Symbol = 'APPINSTALLER_CLI_ERROR_PIN_ALREADY_EXISTS'; Description = 'A pin already exists for the package.' }
	-1978335133 = @{ Hex = '0x8A150063'; Symbol = 'APPINSTALLER_CLI_ERROR_PIN_DOES_NOT_EXIST'; Description = 'There is no pin for the package.' }
	-1978335132 = @{ Hex = '0x8A150064'; Symbol = 'APPINSTALLER_CLI_ERROR_CANNOT_OPEN_PINNING_INDEX'; Description = 'Unable to open the pin database.' }
	-1978335131 = @{ Hex = '0x8A150065'; Symbol = 'APPINSTALLER_CLI_ERROR_MULTIPLE_INSTALL_FAILED'; Description = 'One or more applications failed to install' }
	-1978335130 = @{ Hex = '0x8A150066'; Symbol = 'APPINSTALLER_CLI_ERROR_MULTIPLE_UNINSTALL_FAILED'; Description = 'One or more applications failed to uninstall' }
	-1978335129 = @{ Hex = '0x8A150067'; Symbol = 'APPINSTALLER_CLI_ERROR_NOT_ALL_QUERIES_FOUND_SINGLE'; Description = 'One or more queries did not return exactly one match' }
	-1978335128 = @{ Hex = '0x8A150068'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_IS_PINNED'; Description = 'The package has a pin that prevents upgrade.' }
	-1978335127 = @{ Hex = '0x8A150069'; Symbol = 'APPINSTALLER_CLI_ERROR_PACKAGE_IS_STUB'; Description = 'The package currently installed is the stub package' }
	-1978335126 = @{ Hex = '0x8A15006A'; Symbol = 'APPINSTALLER_CLI_ERROR_APPTERMINATION_RECEIVED'; Description = 'Application shutdown signal received' }
	-1978335125 = @{ Hex = '0x8A15006B'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_DEPENDENCIES'; Description = 'Failed to download package dependencies.' }
	-1978335124 = @{ Hex = '0x8A15006C'; Symbol = 'APPINSTALLER_CLI_ERROR_DOWNLOAD_COMMAND_PROHIBITED'; Description = 'Failed to download package. Download for offline installation is prohibited.' }
	-1978335123 = @{ Hex = '0x8A15006D'; Symbol = 'APPINSTALLER_CLI_ERROR_SERVICE_UNAVAILABLE'; Description = 'A required service is busy or unavailable. Try again later.' }
	-1978335122 = @{ Hex = '0x8A15006E'; Symbol = 'APPINSTALLER_CLI_ERROR_RESUME_ID_NOT_FOUND'; Description = 'The guid provided does not correspond to a valid resume state.' }
	-1978335121 = @{ Hex = '0x8A15006F'; Symbol = 'APPINSTALLER_CLI_ERROR_CLIENT_VERSION_MISMATCH'; Description = 'The current client version did not match the client version of the saved state.' }
	-1978335120 = @{ Hex = '0x8A150070'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_RESUME_STATE'; Description = 'The resume state data is invalid.' }
	-1978335119 = @{ Hex = '0x8A150071'; Symbol = 'APPINSTALLER_CLI_ERROR_CANNOT_OPEN_CHECKPOINT_INDEX'; Description = 'Unable to open the checkpoint database.' }
	-1978335118 = @{ Hex = '0x8A150072'; Symbol = 'APPINSTALLER_CLI_ERROR_RESUME_LIMIT_EXCEEDED'; Description = 'Exceeded max resume limit.' }
	-1978335117 = @{ Hex = '0x8A150073'; Symbol = 'APPINSTALLER_CLI_ERROR_INVALID_AUTHENTICATION_INFO'; Description = 'Invalid authentication info.' }
	-1978335116 = @{ Hex = '0x8A150074'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_TYPE_NOT_SUPPORTED'; Description = 'Authentication method not supported.' }
	-1978335115 = @{ Hex = '0x8A150075'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_FAILED'; Description = 'Authentication failed.' }
	-1978335114 = @{ Hex = '0x8A150076'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_INTERACTIVE_REQUIRED'; Description = 'Authentication failed. Interactive authentication required.' }
	-1978335113 = @{ Hex = '0x8A150077'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_CANCELLED_BY_USER'; Description = 'Authentication failed. User cancelled.' }
	-1978335112 = @{ Hex = '0x8A150078'; Symbol = 'APPINSTALLER_CLI_ERROR_AUTHENTICATION_INCORRECT_ACCOUNT'; Description = 'Authentication failed. Authenticated account is not the desired account.' }
	-1978335111 = @{ Hex = '0x8A150079'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_REPAIR_INFO_FOUND'; Description = 'Repair command not found.' }
	-1978335110 = @{ Hex = '0x8A15007A'; Symbol = 'APPINSTALLER_CLI_ERROR_REPAIR_NOT_APPLICABLE'; Description = 'Repair operation is not applicable.' }
	-1978335109 = @{ Hex = '0x8A15007B'; Symbol = 'APPINSTALLER_CLI_ERROR_EXEC_REPAIR_FAILED'; Description = 'Repair operation failed.' }
	-1978335108 = @{ Hex = '0x8A15007C'; Symbol = 'APPINSTALLER_CLI_ERROR_REPAIR_NOT_SUPPORTED'; Description = "The installer technology in use doesn't support repair." }
	-1978335107 = @{ Hex = '0x8A15007D'; Symbol = 'APPINSTALLER_CLI_ERROR_ADMIN_CONTEXT_REPAIR_PROHIBITED'; Description = 'Repair operations involving administrator privileges are not permitted on packages installed within the user scope.' }
	-1978335106 = @{ Hex = '0x8A15007E'; Symbol = 'APPINSTALLER_CLI_ERROR_SQLITE_CONNECTION_TERMINATED'; Description = 'The SQLite connection was terminated to prevent corruption.' }
	-1978335105 = @{ Hex = '0x8A15007F'; Symbol = 'APPINSTALLER_CLI_ERROR_DISPLAYCATALOG_API_FAILED'; Description = 'Failed to get Microsoft Store package catalog.' }
	-1978335104 = @{ Hex = '0x8A150080'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICABLE_DISPLAYCATALOG_PACKAGE'; Description = 'No applicable Microsoft Store package found from Microsoft Store package catalog.' }
	-1978335103 = @{ Hex = '0x8A150081'; Symbol = 'APPINSTALLER_CLI_ERROR_SFSCLIENT_API_FAILED'; Description = 'Failed to get Microsoft Store package download information.' }
	-1978335102 = @{ Hex = '0x8A150082'; Symbol = 'APPINSTALLER_CLI_ERROR_NO_APPLICABLE_SFSCLIENT_PACKAGE'; Description = 'No applicable Microsoft Store package download information found.' }
	-1978335101 = @{ Hex = '0x8A150083'; Symbol = 'APPINSTALLER_CLI_ERROR_LICENSING_API_FAILED'; Description = 'Failed to retrieve Microsoft Store package license.' }
	-1978335100 = @{ Hex = '0x8A150084'; Symbol = 'APPINSTALLER_CLI_ERROR_SFSCLIENT_PACKAGE_NOT_SUPPORTED'; Description = 'The Microsoft Store package does not support download command.' }
	-1978335099 = @{ Hex = '0x8A150085'; Symbol = 'APPINSTALLER_CLI_ERROR_LICENSING_API_FAILED_FORBIDDEN'; Description = 'Failed to retrieve Microsoft Store package license. The Microsoft Entra Id account does not have required privilege.' }
	-1978335098 = @{ Hex = '0x8A150086'; Symbol = 'APPINSTALLER_CLI_ERROR_INSTALLER_ZERO_BYTE_FILE'; Description = 'Downloaded zero byte installer; ensure that your network connection is working properly.' }
}

$KnownVerbatimToCode = @{
	'No applicable upgrade found' = -1978335189
	'Found an existing package already installed' = -1978335135
	'None of the installers are applicable' = -1978335216
	'No packages found'		      = -1978335212
	'Command requires administrator privileges' = -1978335207
	'Installer failed security check' = -1978335187
	'Download size does not match' = -1978335186
	'Uninstall command not found' = -1978335185
	'Running MSI install failed'  = -1978335159
	'Failed to open the source'   = -1978335163
	'Microsoft Store.*blocked by policy' = -1978335205
}

foreach ($kvp in $KnownVerbatimToCode.GetEnumerator())
{
	$code = [int]$kvp.Value
	if ($WingetErrorCatalog.Contains($code))
	{
		$cat = $WingetErrorCatalog[$code]
		$desc = "$($cat.Description) ($($cat.Symbol))"
		$tSuccess = $TreatAsSuccessCodes -contains $code
		if ($kvp.Key -match '(?i)no applicable upgrade found|found an existing package already installed') { $tSuccess = $true }
		Add-Rule -Rules $PatternRules -Regex "(?i)$($kvp.Key)" -Description $desc -TreatAsSuccess $tSuccess
	}
}


foreach ($code in $WingetErrorCatalog.Keys)
{
	$meta = $WingetErrorCatalog[$code]
	if ($null -eq $meta -or [string]::IsNullOrWhiteSpace($meta.Description)) { continue }
	$rx = ConvertTo-RegexFromPhrase -Text $meta.Description
	if ($null -ne $rx)
	{
		$desc = "$($meta.Description) ($($meta.Symbol))"
		$tSuccess = $TreatAsSuccessCodes -contains $code
		Add-Rule -Rules $PatternRules -Regex $rx -Description $desc -TreatAsSuccess $tSuccess
	}
}
foreach ($line in $BenignVerbatim)
{
	$rx = "(?i)$([regex]::Escape($line))"
	Add-Rule -Rules $PatternRules -Regex $rx -Description "Benign outcome: $line" -TreatAsSuccess $true
}

if ($wingetOption -eq 1)
{
	$install = "!!WingetCommand!!"
	if ($install -like "!!doe*")
	{
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
		{
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
			
		}
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
		{
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
			
		}
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
		{
			
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
			
		}
		
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
		{
			& $wingetexe install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale *>&1 |
			Tee-Object -FilePath $loglocation | Out-Null
		}
		$rawExit = [int]$LASTEXITCODE
		$log = Get-Content $loglocation -Raw
		$decision = $null
		foreach ($rule in $PatternRules)
		{
			if ($log -match $rule.Regex) { $decision = $rule; break }
		}
		
		if ($decision)
		{
			if ($decision.TreatAsSuccess)
			{
				$excode = 0
			}
			else
			{
				# ensure rawExit is numeric
				$excode = if ([int]$rawExit -ne 0) { [int]$rawExit }
				else { 1 }
			}
			
			Write-Log $loglocation "`r`n[Decision] Matched pattern: $($decision.Regex)"
			Write-Log $loglocation "[Decision] TreatAsSuccess: $($decision.TreatAsSuccess)"
		}
		else
		{
			$excode = [int]$rawExit
			
			if ($WingetErrorCatalog.Contains([int]$excode))
			{
				$m = $WingetErrorCatalog[[int]$excode]
				Write-Log $loglocation "`r`n[ExitCode] $($m.Hex) ($excode) $($m.Symbol) - $($m.Description)"
				
				if ($TreatAsSuccessCodes -contains $excode)
				{
					$excode = 0
					Write-Log $loglocation "[Decision] Exit code treated as success by policy."
				}
			}
			else
			{
				$hexUnknown = Convert-ToHex32 $excode
				Write-Log $loglocation "`r`n[ExitCode] $hexUnknown ($excode) - Unknown code"
			}
		}
		Write-Host $log
		$hexOut = Convert-ToHex32 $excode
		Write-Host "ExitCode=$excode (hex $hexOut)"
		
		
		
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
		
		
	}
	else
	{
		& $wingetexe uninstall --id $WinGetID -h *>&1 |
		Tee-Object -FilePath $loglocation | Out-Null
		$rawExit = [int]$LASTEXITCODE
		$log = Get-Content $loglocation -Raw
		$decision = $null
		foreach ($rule in $PatternRules)
		{
			if ($log -match $rule.Regex) { $decision = $rule; break }
		}
		
		if ($decision)
		{
			if ($decision.TreatAsSuccess)
			{
				$excode = 0
			}
			else
			{
				# ensure rawExit is numeric
				$excode = if ([int]$rawExit -ne 0) { [int]$rawExit }
				else { 1 }
			}
			
			Write-Log $loglocation "`r`n[Decision] Matched pattern: $($decision.Regex)"
			Write-Log $loglocation "[Decision] TreatAsSuccess: $($decision.TreatAsSuccess)"
		}
		else
		{
			$excode = [int]$rawExit
			
			if ($WingetErrorCatalog.Contains([int]$excode))
			{
				$m = $WingetErrorCatalog[[int]$excode]
				Write-Log $loglocation "`r`n[ExitCode] $($m.Hex) ($excode) $($m.Symbol) - $($m.Description)"
				
				if ($TreatAsSuccessCodes -contains $excode)
				{
					$excode = 0
					Write-Log $loglocation "[Decision] Exit code treated as success by policy."
				}
			}
			else
			{
				$hexUnknown = Convert-ToHex32 $excode
				Write-Log $loglocation "`r`n[ExitCode] $hexUnknown ($excode) - Unknown code"
			}
		}

		Write-Host $log
		$hexOut = Convert-ToHex32 $excode
		Write-Host "ExitCode=$excode (hex $hexOut)"
		
		
		
		
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
	}
}
else
{
	$install = "!!WingetCommand!!"
	if ($install -like "!!doe*")
	{
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $false))
		{
			winget -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine
			
		}
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $false))
		{
			winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --locale $locale
			
		}
		if (($localeSelected -eq $false) -and ($versionWingetSelected -eq $true))
		{
			
			winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget
			
		}
		
		if (($localeSelected -eq $true) -and ($versionWingetSelected -eq $true))
		{
			winget install -e --id $WinGetID --accept-package-agreements --accept-source-agreements -h --scope=machine --version $versionWinget --locale $locale
		}
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
		
	}
	else
	{
		winget uninstall --id $WinGetID -h
		if (Test-Path 'BuildingBlocks\System')
		{
			$originalLocation = Get-Location
			Write-Host "BuildBlocks folder detected"
			
			$allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
			foreach ($bb in $allBuildingBlocks)
			{
				$bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"
				
				if (Test-Path $bbScriptLocation -PathType Leaf)
				{
					Write-Host "Now running Building Blocks Script $bbScriptLocation"
					& $bbScriptLocation
					Set-Location $originalLocation
				}
			}
		}
	}
}



if ($install -like "!!doe*")
{
	try
	{
		#Searches for startmenu items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
		
	}
	try
	{
		#Searches for Desktop items created the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startMenuItems)
		{
			write-host "`r`n"
			write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
			write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
			write-host "`r`n"
			
		}
	}
	catch
	{
		write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
	
}
#### Place extra actions here:










if ($decision)
{
	write-host "[Decision] Matched pattern: $($decision.Regex)"
	Write-Host "[Decision] TreatAsSuccess: $($decision.TreatAsSuccess)"
	if ($($decision.TreatAsSuccess) -like 'False')
	{
		$excode = 1
	}
}
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
if ($excode -eq 1) { $warning = 'Error'; }
else
{
	$warning = 'Information'; if ($install -like "!!doe*") { fDetectionInRegistry -succes $true }
	else
	{
		remove-item $regkeyApp
	}
}
#End; Write Log file
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}
Else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }


'@
			$installfile = $installfile.Replace('!!WinGetID!!', $WinGetID)
			$installfile = $installfile.Replace('!!DisplayName!!', $DisplayName)
			$installfile = $installfile.Replace('!!logdir!!', $logdir)
			$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$installfile = $installfile.Replace('!!version!!', $version)
			if ($wlo -ne $null)
			{
				$installfile = $installfile.Replace('!!locale!!', $wlo)
				$installfile = $installfile.Replace("!!localeSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!localeSelected!!", $false) }
			if ($wve -ne $null)
			{
				$installfile = $installfile.Replace('!!versionWinget!!', $wve)
				$installfile = $installfile.Replace("!!versionSelected!!", $true)
			}
			else { $installfile = $installfile.Replace("!!versionSelected!!", $false) }
			$installfile = $installfile.Replace('!!includeWingetRequirment!!', $includeWingetRequirment)
			
			
			
			
			$installfile = $installfile.Replace('!!WingetCommand!!', "!!doeinstall!!")
			$installFile | Out-File "$outputDirectory\$DisplayName\$version\source\install.ps1" -Force
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$DisplayName\$version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
			$installFile | Out-File "$outputDirectory\$DisplayName\$version\source\uninstall.ps1" -Force
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\source\install.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("$outputDirectory\$DisplayName\$version\source\uninstall.ps1 created")
			$winget_output_textbox3.AppendText("`r`n")
			$winget_output_textbox3.AppendText("You can test using Powershell ISE (button in GUI) or start the creation of intunewinfile`r`n")
			$winget_test_install_button1.Enabled = $true
			$winget_test_install_button1.Visible = $true
			$winget_uninstall_test_button.Enabled = $true
			$winget_uninstall_test_button.Visible = $true
			$winget_maakPackage_button1.Enabled = $true
			$winget_maakPackage_button1.Visible = $true
			$winget_final_panel7.Enabled = $true
		}
	}
	
}

$winget_test_install_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test installation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		$voorIntall = Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs"
		powershell_ise -file "$config_packagefolder\$DisplayName\$wingetversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	$winget_gotobuildingBlocks_buttonTestInstallPowershel.Enabled = $true
}

$winget_uninstall_test_button_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	
	$wid = $winget_WingetID_textbox1.text
	$vid = $versie_textbox2.Text
	$DisplayName = $winget_displayname_textbox1.text
	$wingetversie = $versie_textbox2.text
	$wingetid = $winget_WingetID_textbox1.text
	
	
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test uninstallation?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		
		
		powershell_ise -file "$config_packagefolder\$DisplayName\$wingetversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	$winget_addBuildingBlocksCSVbuttonOptionalAddBuildingB.Enabled = $true
	
}

$winget_show_version_button1_Click = {
	#TODO: Place custom script here
	$winget_show_string = $winget_WingetID_textbox1.text
	$winget_show_versions = winget show $winget_show_string --versions --accept-source-agreements
	
	
	$winget_output_textbox3.Text = "Search results: `r`n"
	foreach ($twi in $winget_show_versions)
	{
		
		$winget_output_textbox3.AppendText("$twi `r`n")
	}
}

$wsearch_s_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$wsearch_s_button1_Click = {
	#TODO: Place custom script here
	## - [ Section to initialize DataTable objects] - ##
	## - Create DataTable:
	$table = New-Object System.Data.DataTable;
	
	## - Defining DataTable object columns and rows properties:
	# - Column1 = "ID".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "ID";
	$table.Columns.Add($column);
	
	# - Column2 = "Name".
	$column = New-Object System.Data.DataColumn;
	$column.DataType = [System.Type]::GetType("System.String");
	$column.ColumnName = "Name";
	$table.Columns.Add($column);
	
	$wsearchstring = $wsearch_s_textbox1.text
	$wsearch__winget_search_output = winget search $wsearchstring --accept-source-agreements
	
	foreach ($wsearch_l in $wsearch__winget_search_output)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row = $table.NewRow();
			
			$row["Name"] = $wsearch_l.substring(0, $wsearch_IdStart)
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			$table.Rows.Add($row);
			
			## - Save changes to the table:
			$table.AcceptChanges();
			
			## - Display custom data created:
			$wsearch_datagridview1.DataSource = $table;
			
			
			
			
			
			
			
		}
		
	}
	
	
	
	
}


Write-Host $wsearch_datagridview1
$wsearch_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$cunfig_folder_pacakaging_button1_Click = {
	#TODO: Place custom script here
	if ($config_packagefolder_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_packagefolder_textbox.Text = $config_packagefolder_folderbrowsermoderndialog1.SelectedPath
	}
}

$config_logfolder_target_button1_Click = {
	#TODO: Place custom script here
	if ($config_logfolder_target_folderbrowsermoderndialog1.ShowDialog() -eq 'OK')
	{
		$config_logfoldertarger_textbox.Text = $config_logfolder_target_folderbrowsermoderndialog1.SelectedPath
	}
}

$tools_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$tools_search_winget_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$config_csv_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$upload_logo_button2_Click = {
		$dlg = $upload_logo_openfiledialog1.ShowDialog()
		if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
		[string]$logoPath = $upload_logo_openfiledialog1.FileName
		[string]$configPath = $config_csv_openfiledialog1.FileName
		
		if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
		if (-not (Test-Path -LiteralPath $configPath)) { [void][System.Windows.Forms.MessageBox]::Show('config.csv not selected.'); return }
		$destDir = Split-Path -Parent $configPath
		$destPng = Join-Path $destDir 'logo.png'
		
		# Size check (≤ 1 MB)
		$fi = Get-Item -LiteralPath $logoPath
		if ($fi.Length -gt 1MB)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
			return
		}
		$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
		
		switch ($ext)
		{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			Write-Host "WEBP conversion started..."
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
		[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
}

$timer1_Tick = {
	#TODO: Place custom script here
	
}

$weblink_logo_openfiledialog1_FileOk = [System.ComponentModel.CancelEventHandler]{
	#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$msi_versie_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$msi_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_Empty_Scheduled_Task_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Basic template: Creates install.ps1 and uninstall.ps1. With detection method in registry for Intune. And logging to the in Config defined log target"
}

$powershell_scheduledtask_radiobutton_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Template scheduled task: Creates install.ps1 that creates scheduled task to run Powershell script. Uninstall.ps1 cleans up the scheduled task"
}

$powershell_package_name_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package Name (String)"
}

$powershell_package_version_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package Version (String)"
}

$powershell_create_package_dir_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Creates package directory based on the chosen package folder (Config) and Package Name & Version"
}

$powershell_open_package_directory_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Open Package\source directory; Here you can place additional files when needed."
}


$config_listbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Select a customer / tenant"
}

$config_customername_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Customer name"
}

$config_logfoldertarger_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Log folder target. Location is used for Powershell transcript logging used by the packages; Also used for MSIEXEC logging when using an MSI source"
}

$config_packagefolder_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package folder. Must be a local folder. For example: when you create a package with Package Name: 'IntunePrepTool' with Package Version '1.0.3.5', and your package folder is c:\sources\gotomars. The folder created for this package = c:\sources\gotomars\IntunePrepTool\1.0.3.5\"
}

$config_tenanturl_textbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Tenant url is used for the upload function"
}

$helpbutton1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Opens https://github.com/rink-turksma/IntunePrepTool in Edge; If you need more information."
}

$config_delete_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Deletes selected customer. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_new_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click here to create new customer. Click save when done. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_save_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Save to append new customer to list. (Customer list is stored in CSV file: 'c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv')"
}

$config_check_updates_button1_Click = {
	#TODO: Place custom script here
	$config_check_updates = @'
winget upgrade rink-turksma.IntunePrepTool
'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetupdate.ps1" -PathType Leaf))
		{
			$config_check_updates | Out-File "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetupdate.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}

$config_check_updates_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click to open Powershell ISE; Run script to upgrade IntunePrepTool using Winget; When you get the message: 'No applicable upgrade found.' You're already up to date. "
}

$winget_WingetID_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Exact Winget ID here; You can search for the Winget ID using Tabpage Tools"
}

$winget_checkurl_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Shows download URL in Popup window for chosen WingetID"
}

$winget_show_version_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Shows available versions for chosen WingetID; Output in textbox on the right side"
}

$toolstripstatuslabel1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_package_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_displayname_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package name (string)"
}

$versie_textbox2_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package version (string)"
}

$winget_locale_checkbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "'Winget Show' (Also available in tabpage Tools) can be used to find out if the chosen package is available in other languages. Check if you want to specify Locale. Like 'en-US' ; "
}

$global_selected_customer_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$config_listbox_SelectedValueChanged = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text + $config_listbox.SelectedItem
}

$winget_version_checkbox_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Check checkbox to select specify version. When you don't the latest version is used."
}

$winget_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When youre test and edit the installation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_uninstall_test_button_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When youre test and edit the uninstallation in Powershell_ISE directly. When you're done click save and close Powershell_ISE"
}

$winget_maakPackage_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create Intunewin file; don't forget to upload logo after creating Intunewinfile if you wan't to use the upload option."
}

$msi_buttonOpenMSIFile_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Open *.msi file to use for this package."
}

$msi_packagenaam_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package name (string)."
}

$msi_versie_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Package version (string)."
}

$msi_buttonCreatePackageDirecto_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "After selecting MSI, Package name and package version, click Create package directory; The MSI file will be copied to the generated to the package directory"
}

$msi_OpenSourceDir_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click Open source directory to open the source directory for your package.You can add extra files when needed."
}

$msi_install_par_textbox3_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "MSIEXEC install parameters here; after creating package directory, a basic install string is already visible. Edit when needed. Leave the logging options as is. "
}

$msi_button1CreateInstallScript_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click create Install script to create the install.ps1 and i.cmd file; install.ps1 will provide detection method and logging; i.cmd is just the above filled install parameters in as batch file;  "
}

$msi_test_install_button1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Click Test install to test your installation. Powershell_ISE will read the MSIEXEC log file and will show you a possible uninstall string. That you can use for uninstall script. Also when shorcuts are created the install.ps1 will give you the option to remove it."
}

$msi_uninstall_par_textbox1_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Paste the suggested uninstall string from the install.ps1 here. Then click create uninstall script"
}

$msi_button3CreateUninstallScri_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create uninstall script"
}

$msi_button4TestUninstallPowers_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Test uninstall using Powershell_ISE; You can edit the uninstall.ps1 directly. If you need to change the u.cmd file. Please click Open source directory and edit. "
}

$msi_button5CreateIntunewinFile_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "Create intunewin package. This can take a while, depending on the size of your package. Application (STA) will not respond during creation of Intunewin"
}

$msi_buttonUploadLogoPNG_MouseHover = {
	#TODO: Place custom script here
	$toolstripstatuslabel1.Text = "When you plan to use Upload function. Please chose PNG file first. Used in Company portal"
}

$winget_remediations_createscripts_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Upload not yet available for Remediations.. For now use the Intune Admin Portal")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("Please reopen IntunePrepTool to create more Remediations scripts")
				
				
			}
		}
		
		
	}
	
	
	
	
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
	
	
	
}

$configToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $true
	$config_tabpage.Visible = $true
	$config_tabpage.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$wingetToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_winget_tabcontrol2.Enabled = $true
	$package_winget_tabcontrol2.Visible = $true
	$package_winget_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}
$scheduledTaskToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'Fill'
	$package_ScheduledTask_tabcontrol2.Enabled = $true
	$package_ScheduledTask_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}


$mSIXToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$MSIX_tabcontrol1.Dock = 'Fill'
	$MSIX_tabcontrol1.Enabled = $true
	$MSIX_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$mSIToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $true
	$package_msi_tabcontrol2.Visible = $true
	$package_msi_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$eXEToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $true
	$package_exe_tabcontrol2.Visible = $true
	$package_exe_tabcontrol2.Dock = 'Fill'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$main_panel1_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$wingetUpdateToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Dock = 'Fill'
	$Remediations_winget_tabcontrol2.Enabled = $true
	$Remediations_winget_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}

$weblinkToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Dock = 'Fill'
	$package_weblink_tabcontrol2.Visible = $true
	$package_weblink_tabcontrol2.Enabled = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
}



$intunewinToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Dock = 'Fill'
	$upload_intunewin_tabcontrol2.Enabled = $true
	$upload_intunewin_tabcontrol2.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$wingetSearchShowVersionToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Enabled = $true
	$tools_winget_searchtabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$findUninstallStringsToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'Fill'
	$tools_uninstallstring_tabcontrol1.Enabled = $true
	$tools_uninstallstring_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromWingetToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $true
	$download_tabcontrol1.Visible = $true
	$download_tabcontrol1.Dock = 'Fill'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	
}

$sourceFromMSStoreUsingMSStoreURLToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $true
	$download_MSSTore_tabcontrol1.Visible = $true
	$download_MSSTore_tabcontrol1.Dock = 'Fill'
	
}


$powershellToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $true
	$Powershell.Visible = $true
	$Powershell.Dock = 'Fill'
	
	
}
$updateMSIOrEXEPackageToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $false
	$updatepackage_exe_tabcontrol1.Visible = $false
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $true
	$updatepackage_msi_tabcontrol1.Visible = $true
	$updatepackage_msi_tabcontrol1.Dock = 'Fill'
	
}

$updateEXEPackageToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $true
	$updatepackage_exe_tabcontrol1.Visible = $true
	$updatepackage_exe_tabcontrol1.Dock = 'Fill'
	
}

$chocolateyFindToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}
$chocolateyFindToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$chocolateyToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $true
	$tools_chocolatey_tabcontrol1.Visible = $true
	$tools_chocolatey_tabcontrol1.Dock = 'Fill'
}




$fileWizzardToolStripMenuItem_Click = {
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'

	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}






$Weblink_intunewin_tabpage6_Click = {
	#TODO: Place custom script here
	
}

$weblink_packagename_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$remediations_winget_maxversion_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$winget_remediations_maxversion_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	
}

$remediate_winget_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_name_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$winget_remediations_wingetid_textbox1_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$remadiations_winget_textbox2_TextChanged = {
	#TODO: Place custom script here
	
}

$remediations_winget_upload_button1_Click = {
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	if ($winget_remediations_name -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the Name textbox', 'No Name selected') }
	else
	{
		$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
		if ($winget_remediations_wingetid -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the WingetID textbox', 'No WingetID selected') }
		else
		{
			$remediate_winget_version = $remediate_winget_version_textbox1.Text
			if ($remediate_winget_version -like $null) { [void][System.Windows.Forms.MessageBox]::Show('Please fill the version textbox', 'No version selected') }
			else
			{
				
				$remediate_detectFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsDetection.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -Append
$Date = get-date
write-host $date
write-host "Detection of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

exit [int] (& $winget_exe list --id $WingetID | Select-String '\bVersion\s+Available\b' -Quiet)
Stop-Transcript

'@
				$remediate_remediateFile = @'
$WingetID = "!!wingetid!!"
$Name = "!!name!!"
$Version = "!!version!!"
$LogFolderTarget = "!!logfoldertarget!!"
$trancriptlocation = "$LogFolderTarget\$name$version-remediationsRemediate.txt"
#Creates logdirectory if needed.
if (!(Test-Path -Path $LogFolderTarget))
{
	
	New-Item -ItemType Directory -Path $LogFolderTarget
}
Start-Transcript -Path $trancriptlocation -append
$Date = get-date
write-host $date
write-host "Upgrade of $WingetID"
write-host "Detection name : $Name"
write-host "Detection version: $version"
$winget_exe = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($winget_exe.count -gt 1)
{
	$winget_exe = $winget_exe[-1].Path
}

& $winget_exe upgrade --id $WingetID --accept-package-agreements --accept-source-agreements -h
Stop-Transcript

'@
				
				$remediate_detectFile = $remediate_detectFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_detectFile = $remediate_detectFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_detectFile = $remediate_detectFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_detectFile = $remediate_detectFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!wingetid!!', "$winget_remediations_wingetid")
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!name!!', $winget_remediations_name)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!version!!', $remediate_winget_version)
				$remediate_remediateFile = $remediate_remediateFile.Replace('!!logfoldertarget!!', $config_logfoldertarget)
				
				
				
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source"
				}
				$remediate_detectFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\detect.ps1" -Force -Encoding utf8
				$remediate_remediateFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\remediate.ps1" -Force -Encoding utf8
				$remadiations_winget_textbox2.Text = "Created detection.ps1 and remediate.ps1"
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\source\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				
				
				
				$encoding = [System.Text.Encoding]::UTF8
				$bytes = $encoding.GetBytes($remediate_detectFile)
				$Encoded_remediate_detectFile = [Convert]::ToBase64String($bytes)
				$Bytes2 = $encoding.GetBytes($remediate_remediateFile)
				$Encoded_remediate_remediateFile = [Convert]::ToBase64String($Bytes2)
				$UploadRemediationsFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	6/5/2023 3:38 PM
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	upload.ps1
	===========================================================================
	.DESCRIPTION
		Part of IntunePrepTool
		https://github.com/rink-turksma/IntunePrepTool
		Upload Remediations to Intune
#>
	Write-Host "Script will install MSAL.PS powershell module from the Powershell Galery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name MSAL.PS) { Import-Module -Name MSAL.PS -Force }
	else { Install-Module -name MSAL.PS -Scope AllUsers -Force -SkipPublisherCheck -Confirm:$False; Import-Module -Name IMSAL.PS -Force }
	$displayName = "!!displayName!!"
	$publisher = "!!publisher!!"
	$detectionScriptContent = '!!detectionScriptContent!!'
	$remediationScriptContent = '!!remediationScriptContent!!'
	$tenantID = "!!tenantid!!"
	$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547"; $RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	$MsalToken = Get-MsalToken -TenantId $tenantID -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	$body = @"
{"displayName":"$displayName","description":"Uploaded by IntunePrepTool","publisher":"$publisher","runAs32Bit":false,"runAsAccount":"system","enforceSignatureCheck":false,"detectionScriptContent":"$detectionScriptContent","remediationScriptContent":"$remediationScriptContent","roleScopeTagIds":["0"]}
"@
	$uri = "https://graph.microsoft.com/beta/deviceManagement/deviceHealthScripts"
	$createdPolicy = Invoke-RestMethod -Uri $uri -Method POST -Body $body -Headers @{ Authorization = $MsalToken.CreateAuthorizationHeader() } -ContentType 'application/json'
	Write-Host "Remediationa policy created successfully with ID: $($createdPolicy.id)" -ForegroundColor Green
	Write-Host "Please assign and schedule with MS Intune Admin console" -ForegroundColor Green
	
'@
				$displayName = $winget_remediations_name_textbox1.Text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!publisher!!", $config_customername)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!displayName!!", $displayName)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!detectionScriptContent!!", $Encoded_remediate_detectFile)
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!remediationScriptContent!!", $Encoded_remediate_remediateFile)
				$tenatURL = $upload_tenantURL_textbox.text
				$UploadRemediationsFile = $UploadRemediationsFile.Replace("!!tenantid!!", $tenatURL)
				
				if (!(Test-Path -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output"
				}
				$UploadRemediationsFile | Out-File "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1" -Force
				$remadiations_winget_textbox2.AppendText("Created Upload.ps1")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\")
				$remadiations_winget_textbox2.AppendText("`r`n")
				$remadiations_winget_textbox2.AppendText("After uploading; Please go to Intune Management Portal and assign devices or users. And add a schedule")
				
				if ([System.Windows.Forms.MessageBox]::Show('Do you want to upload using Powershell_ISE now?', 'upload.ps1 created', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
				{
					
					
					
					powershell_ise -file "$config_packagefolder\$winget_remediations_name\$remediate_winget_version\output\upload.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
			}
		}
	}
	$remediations_winget_open_button1.Enabled = $true
	$remediations_winget_open_button1.Visible = $true
}

$remediations_winget_open_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$winget_remediations_name = $winget_remediations_name_textbox1.Text
	$winget_remediations_wingetid = $winget_remediations_wingetid_textbox1.Text
	$remediate_winget_version = $remediate_winget_version_textbox1.Text
	Invoke-Item "$config_packagefolder\$winget_remediations_name\$remediate_winget_version"
}

$powershell_scheduledtask_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	if ($powershell_scheduledtask_radiobutton.Checked -eq $true)
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $true
		$package_scheduled_task_WingetID_textbox.Visible = $true
		$package_scheduled_task_WingetID_label3.Enabled = $true
		$package_scheduled_task_WingetID_label3.Visible = $true
		#$package_ScheduledTask_create_scripts_button1.Enabled = $true
		#$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	else
	{
		$package_scheduled_task_WingetID_textbox.Enabled = $false
		$package_scheduled_task_WingetID_textbox.Visible = $false
		$package_scheduled_task_WingetID_label3.Enabled = $false
		$package_scheduled_task_WingetID_label3.Visible = $false
		
	}
}

$powershell_Empty_Scheduled_Task_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	#$package_ScheduledTask_create_scripts_button1.Enabled = $true
	#$package_ScheduledTask_create_scripts_button1.Visible = $true
}



$package_scheduledtasK_option_weekly_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $true
		$package_scheduledtask_weekly_day_combobox1.Visible = $true
		$package_scheduledtask_weekly_time_combobox1.Enabled = $true
		$package_scheduledtask_weekly_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $true
		
	}
	else
	{
		$package_scheduledtask_weekly_day_combobox1.Enabled = $false
		$package_scheduledtask_weekly_day_combobox1.Visible = $false
		$package_scheduledtask_weekly_time_combobox1.Enabled = $false
		$package_scheduledtask_weekly_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_weekly_pm_radiobutton.Visible = $false
		
	}
}

$package_scheduledtask_weekly_day_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$datetimepicker1_ValueChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_weekly_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_textbox_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_winget_max_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_WingetID_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduled_Task_maxVersion_label4_Click = {
	#TODO: Place custom script here
	
}

$powershell_create_package_dir_button1_Click = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		if ($powershell_package_name_textbox1.Text -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package name textbox', 'Select Package Name')
		}
		else
		{
			if ($powershell_package_version_textbox1.Text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('You need to fill the package version textbox', 'Select Package Version')
			}
			else
			{
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
				$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
				$package_scheduledTask_name = $powershell_package_name_textbox1.Text
				$package_scheduledTask_name = $package_scheduledTask_name -replace (" ", "")
				$powershell_package_name_textbox1.Text = $package_scheduledTask_name
				$package_scheduledTask_version = $powershell_package_version_textbox1.text
				
				
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source"
				}
				if (!(Test-Path -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"))
				{
					
					New-Item -ItemType Directory -Path "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\output"
				}
				$package_ScheduledTask_output_textbox1.Text = "`nNew package direcotory created: `r`n"
				$package_ScheduledTask_output_textbox1.AppendText("$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\")
				$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
				$powershell_open_package_directory_button1.Enabled = $true
				$powershell_open_package_directory_button1.Visible = $true
				$package_scheduledtask_system_panel5.Enabled = $true
				$package_scheduledtask_system_panel5.Visible = $true
				#$package_ScheduledTask_create_scripts_button1.Enabled = $true
				#$package_ScheduledTask_create_scripts_button1.Visible = $true
				$scheduledtask_buttonOpenSourceDirectory.Enabled = $true
				$scheduledtask_buttonOpenSourceDirectory.Visible = $true
				
				
				
			}
		}
	}
}

$powershell_package_version_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_open_package_directory_button1_Click = {
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	Invoke-Item "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\"
}

$package_ScheduledTask_output_textbox1_TextChanged = {
	#TODO: Place custom script here
	
}

$package_ScheduledTask_create_scripts_button1_Click = {
	#TODO: Place custom script here
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			$package_scheduledTaskWarning = $true
		}
		else
		{
			$package_scheduledTaskWarning = $false
		}
	}
	if ($package_scheduledTaskWarning -eq $true)
	{
		[void][System.Windows.Forms.MessageBox]::Show('For user context select logon or on schedule first; For system context. Select at startup or on schedule option first', 'Select option first')
	}
	else
	{
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$package_scheduledTask_name = $powershell_package_name_textbox1.Text
		$package_scheduledTask_version = $powershell_package_version_textbox1.text
		#$package_scheduledtask_system_panel3.Visible = $true
		#$package_scheduledtask_system_panel3.Enabled = $true
		
		
		
		$ScheduledTaskFile = @'
<#Place code here#>











'@
		$logdir = "$config_logfoldertarget\scheduledTasks"
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!ps1name!!", "scheduledTask_$package_scheduledTask_name.ps1")
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_name!!", $package_scheduledTask_name)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!package_scheduledTask_version!!", $package_scheduledTask_version)
		$ScheduledTaskFile = $ScheduledTaskFile.Replace("!!logdir!!", $logdir)
		$ScheduledTaskFile | Out-File  "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1" -Force -Confirm:$false -ErrorAction SilentlyContinue
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$package_ScheduledTask_output_textbox1.AppendText("Template script to be scheduled created")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Please add your Powershell code between 'Place your Powershell code here' and 'End of your Powershell script'")
		$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
		$package_ScheduledTask_output_textbox1.AppendText("Save when done")
		
		$package_scheduledTask_Edit_script_button1.Enabled = $true
		$package_scheduledTask_Edit_script_button1.Visible = $true
		$package_scheduledtasK_option_startup_checkbox1.Enabled = $true
		$package_scheduledtasK_option_startup_checkbox1.Visible = $true
		$package_scheduledtasK_option_weekly_checkbox1.Enabled = $true
		$package_scheduledtasK_option_weekly_checkbox1.Visible = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Enabled = $true
		$package_scheduled_task_createIntunewin_scripts_button1.Visible = $true
	}
	
}



$package_scheduledTask_Edit_script_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Powershell_ISE will open now. Please place powershell code between "Place your Powershell code here" and "End of your Powershell script"; Save when done', 'Powershell_ISE') # Casting the method to [void] suppresses the output. 
	
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\scheduledTask_$package_scheduledTask_name.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	
	
	
}

$package_scheduledtasK_option_startup_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduled_task_createIntunewin_scripts_button1_Click = {
	#TODO: Place custom script here
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	
	
	
	$package_scheduledTask_Edit_script_test_install_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_install_button1.Visible = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Enabled = $true
	$package_scheduledTask_Edit_script_test_uninstall_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Visible = $true
	$package_scheduledTask_Edit_script_createIntuneWin_button1.Enabled = $true
	
	
	$ScheduledTaskInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	6-10-2024 17:54
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$systemContext = "!!systemContext!!"
$onSchedule = "!!onSchedule!!"
$StartupTask = "!!StartupTask!!"
$logonTask = "!!LogonTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!"
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$DailyTask = "!!DailyTask!!"
$DailyTaskHour = "!!DailyTaskHour!!"
$DailyTaskAMPM = "!!DailyTaskAMPM!!"

$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $version) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
if (test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force }
write-host "Script will copy the powershell script to be scheduled now" -ForegroundColor Green
copy-item $psFile -Destination "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force

#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
# BEGIN: 3d5f4a6gch7
#Below the code to set the permissions on the scripts folder
write-host "Script will setup NTFS filepermissions for the directory $logdir\scheduledTasks" -ForegroundColor Green
$Acl = Get-Acl "$logdir\scheduledTasks"
$Ar = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators", "Modify", "Allow")
$System = New-Object System.Security.Principal.NTAccount("SYSTEM")
$Ar2 = New-Object System.Security.AccessControl.FileSystemAccessRule($System, "Modify", "Allow")
$Acl.SetAccessRule($Ar)
$Acl.SetAccessRule($Ar2)
Set-Acl "$logdir\scheduledTasks" $Acl
# END: 3d5f4a6gch7

try
{
	
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	# Creates the scheduled task
	
	
	$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -executionpolicy bypass -Command `"& '$logdir\scheduledTasks\scheduledTask_$appName.ps1'`""
	if ($logonTask -eq $true)
	{
		$trigger0 = New-ScheduledTaskTrigger -AtLogOn
	}
	else
	{
		$trigger0 = $null
	}
	
	if ($StartupTask -eq $true)
	{
		$trigger1 = New-ScheduledTaskTrigger -AtStartup -RandomDelay 00:00:30
	}
	else
	{
		$trigger1 = $null
	}
	if ($WeeklyTask -eq $true)
	{
		$trigger2 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek $WeeklyTaskDay -At $WeeklyTaskHour$WeeklyTaskAMPM
	}
	else
	{
		$trigger2 = $null
	}
	if ($DailyTask -eq $true)
	{
		$trigger3 = New-ScheduledTaskTrigger -Daily -At $DailyTaskHour$DailyTaskAMPM
	}
	else
	{
		$trigger3 = $null
	}
	$triggers = @()
	if ($trigger0 -ne $null)
	{
		$triggers += $trigger0
	}
	if ($trigger1 -ne $null)
	{
		$triggers += $trigger1
	}
	if ($trigger2 -ne $null)
	{
		$triggers += $trigger2
	}
	if ($trigger3 -ne $null)
	{
		$triggers += $trigger3
	}
	
	if ($systemContext -eq $true)
	{
		$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	}
	else
	{
		$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -RunLevel Limited
	}
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	Register-ScheduledTask -Action $action -Trigger $triggers -Principal $principal -TaskName $appName -Settings $settings -Description "Scheduled Task for $appName" -Force -ErrorAction Stop
	write-host "Scheduled Task created for $psFile" -ForegroundColor Green
	
	$excode = 0;
	
}
catch
{
	write-host "Error creating scheduled task" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { $warning = 'Error'; }
else { $warning = 'Information'; fDetectionInRegistry -succes $true }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	
	$ScheduledTaskUnInstall = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.232
	 Created on:   	10/24/2023
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
		When needed you can edit the deletion of the scheduled task below
#>
# App Parameters
$appName = "!!AppName!!"
$version = "!!Version!!"
$psFile = "!!psFile!!"
$StartupTask = "!!StartupTask!!"
$WeeklyTask = "!!WeeklyTask!!"
$WeeklyTaskDay = "!!WeeklyTaskDay!!" 
$WeeklyTaskHour = "!!WeeklyTaskHour!!"
$WeeklyTaskAMPM = "!!WeeklyTaskAMPM!!"
$registerDetectionRoot = "!!registerDetectionRoot!!"

# Customer variables
$logDir = "!!LogDir!!"
# Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
# Create log directory in programdata if it doesn't exist.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
if (!(Test-Path -Path "$logdir\scheduledTasks"))
{
	
	New-Item -ItemType Directory -Path "$logdir\scheduledTasks"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application key in the Registry Root if it does not exist
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}
function fDetectionInRegistry
{
	### Function responsible for successful or unsuccessful execution.
	### Ultimately, you will have, for example:
	### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With a Version value and a [BOOL]Success value
	### Usage: fDetectionInRegistry -success $False or fDetectionInRegistry -success $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
Start-Transcript -Path $logfile
#Start; Write Log file
write-host "Script will delete the powershell script used by the task" -ForegroundColor Green
if ( test-path "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -PathType Leaf ) { remove-item "$logdir\scheduledTasks\scheduledTask_$appName.ps1" -Confirm:$false -Force  } 


try
{
	# Script deletes the scheduled task here
	write-host "Script will delete the scheduled task" -ForegroundColor Green
	Unregister-ScheduledTask -TaskName $appName -Confirm:$false -ErrorAction Stop
	write-host "Scheduled Task deleted" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
	write-host "Error with deleting scheduled task" -ForegroundColor Yellow
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}



Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try/catch block in the execution, we set $excode to 0 or 1.
# Based on this, the Log in the Event Viewer is set to either Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful or unsuccessful application message.
if ($excode -eq 1) { [System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)  }
else {
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
remove-item $regKeyApp -Confirm:$false -force }
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$RegisterDetectionroot = "Intune_" + $config_customername
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$psfile = "scheduledTask_$package_scheduledTask_name.ps1"
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!registerDetectionRoot!!", $RegisterDetectionroot)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!AppName!!", $package_scheduledTask_name)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!Version!!", $package_scheduledTask_version)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!psFile!!", $psfile)
	$ScheduledTaskUnInstall = $ScheduledTaskUnInstall.Replace("!!LogDir!!", $config_logfoldertarget)
	
	
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		
		if (($package_scheduledtasK_option_startup_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_system_onschedule.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Weekly or at startup', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				Write-Host "Eerste stap"
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			Write-Host "Check"
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $true)
			
			if ($package_scheduledtasK_option_startup_checkbox1.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $true)
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!StartupTask!!", $false)
			}
			
			if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			Write-Host "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
			
		}
		
		
		
		
	}
	
	
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		if (($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $false) -and ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false))
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Select At logon or at schedule', 'Please select at least one option when to run') # Casting the method to [void] suppresses the output. 
		}
		else
		{
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				if (($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $false) -and ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $false))
				{
					[void][System.Windows.Forms.MessageBox]::Show('Select weekly or daily first', 'Select weekly or daily first') # Casting the method to [void] suppresses the output. 
				}
			}
			
			$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!systemContext!!", $false)
			if ($Package_scheduledtask_User_atlogon_checkbox_logon.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $true)
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!LogonTask!!", $false)
			}
			if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $true)
				if ($package_scheduledtasK_option_weekly_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $true)
					$WeeklyTaskDay = $package_scheduledtask_weekly_day_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskDay!!", $WeeklyTaskDay)
					
					$weeklyTaskHour = $package_scheduledtask_weekly_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskHour!!", $weeklyTaskHour)
					if ($package_scheduledtask_weekly_weekly_am_radiobutton.Checked -eq $true)
					{
						$WeeklyTaskAMPM = "AM"
					}
					else
					{
						$WeeklyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTaskAMPM!!", $WeeklyTaskAMPM)
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!WeeklyTask!!", $false)
					
				}
				if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $true)
					
					
					$DailyTaskHour = $package_scheduledtask_daily_time_combobox1.Text
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskHour!!", $DailyTaskHour)
					if ($package_scheduledtask_weekly_daily_am_radiobutton.Checked -eq $true)
					{
						$DailyTaskAMPM = "AM"
					}
					else
					{
						$DailyTaskAMPM = "PM"
					}
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTaskAMPM!!", $DailyTaskAMPM)
					
					
					
				}
				else
				{
					$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!DailyTask!!", $false)
					
				}
				
			}
			else
			{
				$ScheduledTaskInstall = $ScheduledTaskInstall.Replace("!!onSchedule!!", $false)
			}
			
			$ScheduledTaskInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1" -force
			$ScheduledTaskUnInstall | Out-File "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1" -force
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Install and uninstall.ps1 created'")
			$package_ScheduledTask_output_textbox1.AppendText(" `r`n")
			$package_ScheduledTask_output_textbox1.AppendText("Please test. When ready click on create Intunewin file")
			
			
			
		}
	}
	
}

$windowsFirewallToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$config_InstallRequriedPSmodules_Click = {
	#TODO: Place custom script here
	$config_install_required_ps_modules = @'

<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.242
	 Created on:   	17-5-2024 15:24
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	InstallRequiredPowershellModules.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$problemPSModule = $null;;
if (Get-Module -ListAvailable -Name IntuneWin32App)
{
	$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
	
	if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
{
	$moduleVersion = $null;
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
{
	$moduleVersion = $null;
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name CredentialManager)
{
	$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
	
	if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
{
	$moduleVersion = $null
	$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
	
	if ($moduleVersion.Count -ge 1)
	{
		
	}
	else
	{
		$problemPSModule = 1
	}
}
else
{
	$problemPSModule = 1
	
}
if ($problemPSModule -eq 1)
{
	#Nuget installation
	$nugetUrl = "https://dist.nuget.org/win-x86-commandline/latest/nuget.exe"
	$nugetInstallPath = "$env:ProgramFiles\NuGet"
	if (-not (Test-Path -Path $nugetInstallPath))
	{
		New-Item -ItemType Directory -Path $nugetInstallPath -Force
	}
	$nugetExePath = Join-Path -Path $nugetInstallPath -ChildPath "nuget.exe"
	Invoke-WebRequest -Uri $nugetUrl -OutFile $nugetExePath
	if (Test-Path -Path $nugetExePath)
	{
		Write-Host "NuGet has been installed successfully at $nugetExePath"
	}
	else
	{
		Write-Host "NuGet installation failed"
	}
	$path = [Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
	if ($path -notlike "*$nugetInstallPath*")
	{
		[Environment]::SetEnvironmentVariable("Path", "$path;$nugetInstallPath", [System.EnvironmentVariableTarget]::Machine)
		Write-Host "NuGet has been added to the system PATH"
	}
	else
	{
		Write-Host "NuGet is already in the system PATH"
	}
	& $nugetExePath | Select-String "NuGet Version"
	
	
	Get-PackageProvider -Name Nuget -Force
	
	#Installation Powershell Modules
	Write-Host "Script will install IntuneWin32App powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name IntuneWin32App)
	{
		$moduleVersion = Get-Module -ListAvailable -Name IntuneWin32App
		
		if (($moduleVersion.Version.Major -eq 1) -and ($moduleVersion.Version.Minor -eq 4) -and ($moduleVersion.Version.Build -eq 4))
		{
			Write-Host "IntuneWin32App 1.4.4 already installed"
		}
		else
		{
			Write-Host "Required Version not found.. Now installing"
			Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name IntuneWin32App -Scope AllUsers -RequiredVersion 1.4.4 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	Write-Host "Script will install Microsoft.Graph.Authentication powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Authentication
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Authentication 2.27.0 already installed"
		}
		else
		{
			Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Authentication -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	Write-Host "Script will install Microsoft.Graph.Applications powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Applications)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Applications
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Applications 2.27.0 already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Applications -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	Write-Host "Script will install CredentialManager powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name CredentialManager)
	{
		$moduleVersion = Get-Module -ListAvailable -Name CredentialManager
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 0))
		{
			Write-Host "CredentialManager 2.0.0 Powershell module already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name CredentialManager -Scope AllUsers -RequiredVersion 2.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	Write-Host "Script will install Microsoft.Graph.Identity.SignIns powershell module from the Powershell Gallery if needed." -ForegroundColor Green
	if (Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns)
	{
		$moduleVersion = Get-Module -ListAvailable -Name Microsoft.Graph.Identity.SignIns
		
		if (($moduleVersion.Version.Major -eq 2) -and ($moduleVersion.Version.Minor -eq 27) -and ($moduleVersion.Version.Build -eq 0))
		{
			Write-Host "Microsoft.Graph.Identity.SignIns 2.27.0 Powershell Module already installed"
		}
		else
		{
			Write-Host "Required Module and Version not found.. Now installing"
			Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		}
	}
	else
	{
		Write-Host "Required Module and Version not found.. Now installing"
		Install-Module -Name Microsoft.Graph.Identity.SignIns -Scope AllUsers -RequiredVersion 2.27.0 -Force -SkipPublisherCheck -Confirm:$False
		
	}
	
	"true" | Out-File 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Force -Confirm:$false
	
}
else
{
	write-host "Powershell Modules already installed!"
	"true" | Out-File 'c:\Program Files\IntunePrepTool\InstallReqPSModules.txt' -Force -Confirm:$false
}


'@
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -PathType Leaf))
		{
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1" -Confirm:$false -Force
			$config_install_required_ps_modules | Out-File "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\wingetinstallpsmodules.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$downloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}

$wingetToolStripMenuItem1_Click = {
	#TODO: Place custom script here
	
}

$config_download_folder_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_downloadFolderBrowse_Click = {
	#TODO: Place custom script here
	if ($config_download_folderbrowsermoderndialog2.ShowDialog() -eq 'OK')
	{
		$config_download_folder_textbox3.Text = $config_download_folderbrowsermoderndialog2.SelectedPath
	}
}

$download_winget_tab_Click = {
	#TODO: Place custom script here
	
}

$download_winget_search_button1_Click = {
	
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
	
	
}

$download_winget_search_textbox5_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	
}

$download_winget_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_version_listbox1.Items.Clear()
	
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	$downloadwingetsearchversionselected = winget show --id $winget_download_selected_id --versions --accept-source-agreements
	
	
	foreach ($wsearch_55 in $downloadwingetsearchversionselected)
	{
		
		
		if (($wsearch_55 -notlike "Found*") -and ($wsearch_55 -notlike "*-*") -and ($wsearch_55 -notlike "*Version*") -and ($wsearch_55 -notlike $null) -and ($wsearch_55 -notlike "* *"))
		{
			
			$download_winget_version_listbox1.Items.Add($wsearch_55)
			
			
		}
		
	}
	
	
	
	
}

$download_datagridview1_CellContentClick = [System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	#Write-Host $download_datagridview1.SelectedRows.Item.ToString()
}

$download_winget_version_listbox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	$download_winget_download_and_add_button1.Visible = $true
	$download_winget_download_and_add_button1.Enabled = $true
}

$download_winget_download_and_add_button1_Click = {
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	$download_winget_explorer_button1.Enabled = $true
	$download_winget_explorer_button1.Visible = $true
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	$winget_download_selected_id = $download_winget_listbox1.SelectedItem #| Select ID #| ConvertTo-Csv -NoTypeInformation | select -skip 1
	$winget_download_selected_id = $winget_download_selected_id.ToString()
	$winget_download_selected_id = $winget_download_selected_id.Split(",")[1]
	$winget_download_selected_id = $winget_download_selected_id.Split('"')[1].Split('"')[0]
	if (!(Test-Path -Path $download_winget_path))
	{
		
		New-Item -ItemType Directory -Path $download_winget_path
	}
	#$downloadWingetToLib = winget download --download-directory $download_winget_path --id $winget_download_selected_id --accept-package-agreements --accept-source-agreements
	
	#$download_winget_output_textbox3.Text = $downloadWingetToLib
	#$config_downloadpath
	#Write-Host $download_winget_version_listbox1.SelectedItem
	$download_winget_selectedversion = $download_winget_version_listbox1.SelectedItem
	$download_winget_package = @'
winget download --download-directory '!!@download_winget_path@!!' --id !!@winget_download_selected_id@!! --accept-package-agreements --accept-source-agreements --version !!@download_winget_selectedversion@!!
'@
	$download_winget_package = $download_winget_package.Replace("!!@winget_download_selected_id@!!", $winget_download_selected_id)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_selectedversion@!!", $download_winget_selectedversion)
	$download_winget_package = $download_winget_package.Replace("!!@download_winget_path@!!", $download_winget_path)
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -PathType Leaf))
		{
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1" -Confirm:$false -Force
			$download_winget_package | Out-File "C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1"
		}
		
		powershell_ise 'C:\windows\temp\intunepreptoolWingetDownloadToLib.ps1'
		Start-Sleep 1
		PowershellISEOnTop
	}
	
}


$download_winget_explorer_button1_Click = {
	#TODO: Place custom script here
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_winget_path = "$config_downloadpath\winget"
	explorer $download_winget_path
}

$config_help_button1_Click = {
	#TODO: Place custom script here
	
}

$config_exit_help_button1_Click = {
	#TODO: Place custom script here
	
}

$exe_maak_uninstall_script_button1_Click = {
	#TODO: Place custom script here
	$exe_maak_intuneWIN_button1.Enabled = $true
	$exe_maak_intuneWIN_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	$exe_uploadlogo_button1.Enabled = $true
	$exe_uploadlogo_button1.Visible = $true
	
	$exe_uninstallFile = @'
<#	
    .NOTES
    ===========================================================================
     Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
     Created on:   	21-5-2023 18:04
     Created by:   	Rink Turksma
     Organization: 	
     Filename:     	uninstall.ps1
    ===========================================================================
    .DESCRIPTION
        Parameters will be filled by IntunePrepTool.
#>
#App Parameters
$appName = "!!AppName!!"
$version = "!!version!!"
$exeFile = "!!EXEFile!!"
$exeParameters = "!!EXEPARMS!!" ##Check EXE PARAMETERS.. 
#Customer variables
$logDir = "!!logdir!!"
$registerDetectionRoot = "!!RegisterDetectionroot!!"
#Dynamic variables
$logFile = $(Join-Path $logDir  "$appName$version.txt")
$msiLogFileName = $appName + $version + "MSI"
$msiLogFile = $(Join-Path $logDir  "$msiLogFileName.txt")
$regKeyRoot = "HKLM:\Software\$registerDetectionRoot"
$regKeyApp = "$regKeyRoot\$appName"
$exeCode = $null;
#Create log directory in programdata if it does not exist.
if (!(Test-Path -Path $logDir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
# Creates the Registry Root directory if it does not exist
if (!(Test-Path -Path $regkeyRoot))
{
    New-Item $regkeyRoot -ItemType Key -Force | out-null
}
# Creates the application Key in the Registry Root.
if (!(Test-Path -Path $regkeyApp))
{
    New-Item $regkeyApp -ItemType Key -Force | out-null
}



function fDetectionInRegistry
{
	### Function ensures successful or unsuccessful execution..
	### Eventually you will have, for example:
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Transcript.  
#The code you provided is a comment in PowerShell. It indicates that the following code block is related to a transcript that will be saved in a text file under the $logdir directory and will also be available in the event viewer.
Start-Transcript -Path $logfile
#Start; Write Log file
try
{
	Start-Process -FilePath $EXEFile -ArgumentList $exeParameters -ErrorAction Stop -wait
	write-host "Uninstall completed" -ForegroundColor Green
	$excode = 0;
	
}
catch
{
    write-host "Error executing $EXEbestand" -ForegroundColor Yellow
	Write-Host "Uinstallation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1;
	
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:





<#----Below is the end of the installation script---#>
#Now the Transcript logging is started
Stop-Transcript
#After this command, the log is automatically saved in the $logdir location
#Here is a way to split the log so that we only have the last run.
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
    $lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}
# In the try / catch block in the execution, we set $excode to 0 or 1
# Based on this, the Log in the Event viewer is set to Error or Informational.
# Additionally, the previously declared function fDetectionInRegistry is used to place the detection methodology in the registry with either a successful application message or an unsuccessful one.
if ($excode -eq 1) { $warning = 'Error';  }
else { $warning = 'Information'; remove-item $regkeyApp }
#End; Write Log file
if ($warning -like 'Information')
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
	
}
Else
{
	
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
	
}
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	$msi_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	21-5-2023 17:57
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
<#

#$MSIbestand = "!!MSIBestand!!"
#$MSIparameters = "!!MSIPARMS!!"
Please see u.cmd for MSI parameters used by this script.

#>
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
	$startPMSI = start-process u.cmd -wait -erroraction stop -WindowStyle Hidden
	write-host $startPMSI
	write-host "Uninstall done!" -ForegroundColor Green
	write-host "Please check MSIEXEC log below" -ForegroundColor Green
	write-host $logfileMSI -ForegroundColor Green
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
	Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Green
	$excode = 0
}
catch
{
	
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "See log file from MSI why this is not working.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
	$MSILOGS = get-content $logfileMSI 
	$MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    $excode = 1


	$startPMSI
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
'@
	
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$MSIPARSInput = '"' + $exe_msiexecuninstall.Text + '"'
		
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!AppNaam!!"', $appnaam)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!logdir!!', $logdir)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$msi_uninstallFile = $msi_uninstallFile.Replace('!!versie!!', $versie)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIBestand!!"', $MSIbestand)
		$msi_uninstallFile = $msi_uninstallFile.Replace('"!!MSIPARMS!!"', $MSIPARSInput)
		
		try
		{
			$exepnaam = $exe_packagenaam_textbox1.text
			$exeversie = $exe_versie_textbox1.text
			$outputDirectory = $config_packagefolder
			$jjmsii = $exe_msiexecuninstall.text
			
			$jjmsii | Out-File "$outputDirectory\$exepnaam\$exeversie\source\u.cmd" -encoding ascii -Force -ErrorAction Stop
			$msi_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
			$exe_output_textbox1.AppendText("`nu.cmd created `r`n")
			$exe_output_textbox1.AppendText("`nTest and if needed. Save changes in Powershell_ISE directly `r`n")
			
			
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUninstall.ps1 NOT created `r`n")
		}
		
		
	}
	else
	{
		
		if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
		{
			$EXEbestand = $exe_uninstall_exe_path_textbox2.Text
			
		}
		else
		{
			$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		}
		
		
		
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		$versie = $exe_versie_textbox1.text
		#$EXEbestand = '"' + $exe_openfiledialog1.SafeFileName + '"'
		$appnaam = '"' + $exe_packagenaam_textbox1.text + '"'
		$EXEPARSInput = $exe_parsUnInstall_textbox1.Text
		
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!AppName!!"', $appnaam)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!logdir!!', $logdir)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
		$exe_uninstallFile = $exe_uninstallFile.Replace('!!version!!', $versie)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEFile!!"', $EXEbestand)
		$exe_uninstallFile = $exe_uninstallFile.Replace('"!!EXEPARMS!!"', $EXEPARSInput)
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$outputDirectory = $config_packagefolder
		
		try
		{
			$exe_uninstallFile | Out-File "$outputDirectory\$exepnaam\$exeversie\source\uninstall.ps1" -Force -ErrorAction Stop
			$exe_output_textbox1.AppendText("`nUninstall.ps1 created `r`n")
		}
		catch
		{
			$exe_output_textbox1.AppendText("`nUbinstall.ps1 NOT created `r`n")
		}
	}
}

$exe_radiobutton3_CheckedChanged = {
	#TODO: Place custom script here
	if ($exe_radiobuttonUninstallEXEPath.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $true
		$exe_uninstall_exe_path_textbox2.Visible = $true
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobuttonGebruikZelfdeEXEAlsB.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_msiexecuninstall.Enabled = $false
		$exe_msiexecuninstall.Visible = $false
		
	}
	if ($exe_radiobutton3.Checked -eq $true)
	{
		$exe_uninstall_exe_path_textbox2.Enabled = $false
		$exe_uninstall_exe_path_textbox2.Visible = $false
		$exe_parsUnInstall_textbox1.Enabled = $false
		$exe_parsUnInstall_textbox1.Visible = $false
		$exe_msiexecuninstall.Enabled = $true
		$exe_msiexecuninstall.Visible = $true
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$exepnaam = $exe_packagenaam_textbox1.text
		$exeversie = $exe_versie_textbox1.text
		$appNaam = $exepnaam
		$versie = $exeversie
		#$msi_openfiledialog1.SafeFileName
		#klant variabelen
		$logdir = $config_logfoldertarget
		$RegisterDetectionroot = "Intune_" + $config_customername
		#Dyn vars
		$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
		$filenaamMSILog = $appNaam + $versie + "MSI"
		$logfileMSI = "$(Join-Path $logdir  "$filenaamMSILog.txt")"
		$exe_msiexecuninstall.Text = "msiexec /qn, /l*v $logfileMSI /x{PlaceProductIDhere}"
		
	}
	$exe_labelVoorbeeldUninstall.Visible = $false
	$exe_labelVoorbeeldUninstall.Enabled = $false
	$exe_test_uninstall_button1.Enabled = $true
	$exe_test_uninstall_button1.Visible = $true
	$exe_maak_uninstall_script_button1.Enabled = $true
	$exe_maak_uninstall_script_button1.Visible = $true
	
	
}

$exe_msiexecuninstall_TextChanged = {
	#TODO: Place custom script here
	
}

$tools_uninstallstring_search_button1_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
	
}

$tools_uninstallstring_search_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$buttonSearch32Bit_Click = {
	#TODO: Place custom script here
	$tools_uninstallstring_textbox2.Text = "Searching: `r`n"
	
	$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
	$wattezoeken = $tools_uninstallstring_search_textbox3.Text
	$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
	
	
	foreach ($ius in $InstallsUninstallString)
	{
		
		
		$tools_uninstallstring_textbox2.AppendText("`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayName: " + $ius.DisplayName + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("DisplayVersion: " + $ius.DisplayVersion + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("InstallDate: " + $ius.InstallDate + "`r`n")
		$tools_uninstallstring_textbox2.AppendText("Uninstallstring: " + $ius.UninstallString + "`r`n")
	}
}




$package_scheduledTask_Edit_script_test_install_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\install.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_test_uninstall_button1_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$package_scheduledTask_name = $powershell_package_name_textbox1.Text
	$package_scheduledTask_version = $powershell_package_version_textbox1.text
	powershell_ise "$config_packagefolder\$package_scheduledTask_name\$package_scheduledTask_version\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$package_scheduledTask_Edit_script_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msipnaam = $powershell_package_name_textbox1.Text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$package_ScheduledTask_output_textbox1.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$msipnaam\$msiversie\source\" -s "$outputDirectory\$msipnaam\$msiversie\source\install.ps1" -o "$outputDirectory\$msipnaam\$msiversie\output\" -q
	Rename-Item -Path "$outputDirectory\$msipnaam\$msiversie\output\install.intunewin" -NewName "$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin"
	$package_ScheduledTask_output_textbox1.AppendText("`nIntunewin file created: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\$msipnaam.intunewin")
	$package_ScheduledTask_output_textbox1.AppendText("`r`n")
	
	$package_ScheduledTask_output_textbox1.AppendText("Install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("un-install command is: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msipnaam\"
	$regkeyApp
	$package_ScheduledTask_output_textbox1.AppendText("$regkeyApp `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Method is: 'String Comparison' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: 'Versie' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Operator is: 'Equals' `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Detection Value is: $msiversie `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Please reopen tool to make another Intunewin package `r`n")
	
	class CSNIntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$CSNIntuneWinPackageConfig = $null;
	$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
			IntuneWinFile = "$msipnaam.intunewin"
			DisplayName   = $msipnaam
			Publisher	  = $config_customername
			AppVersion    = $msiversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$msipnaam\$msiversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$msipnaam\$msiversie\output\"
	$package_ScheduledTask_output_textbox1.AppendText("Config.csv written to: `r`n")
	$package_ScheduledTask_output_textbox1.AppendText("$outputDirectory\$msipnaam\$msiversie\output\config.csv")
	$package_ScheduledTask_output_textbox1.AppendText("  `r`n")
	$package_scheduledTask_Edit_script_UploadLogo_button1.Enabled = $true
	$package_scheduledTask_Edit_script_UploadLogo_button1.Visible = $true
	$package_ScheduledTask_output_textbox1.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
	$package_ScheduledTask_output_textbox1.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
}

$package_scheduledTask_Edit_script_UploadLogo_button1_Click = {
	#TODO: Place custom script here
	
	$msipnaam = $powershell_package_name_textbox1.text
	$msiversie = $powershell_package_version_textbox1.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if ([System.Windows.Forms.MessageBox]::Show("Click yes to open the upload screen. Then load the $outputDirectory\$msipnaam\$msiversie\output\config.csv file there", 'Upload Now?', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$package_ScheduledTask_tabcontrol2.Enabled = $false
		$package_ScheduledTask_tabcontrol2.Visible = $false
		
		
		$upload_intunewin_tabcontrol2.Enabled = $true
		$upload_intunewin_tabcontrol2.Visible = $true
		$upload_intunewin_tabcontrol2.Dock = 'Fill'
	}
	
}

$reloadToolStripMenuItem_Click = {
	#TODO: Place custom script here
	
}


$reopenIntunePrepToolToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$ReloadIntunePrepTool = @'
	Set-Location "C:\Program Files\IntunePrepTool\"
	taskkill.exe /F /IM "IntunePrepTool.exe"
	& "C:\Program Files\IntunePrepTool\IntunePrepTool.exe"
'@
	if (Test-Path "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1")
	{
		powershell.exe -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
	else
	{
		$ReloadIntunePrepTool | Out-File "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1" -Confirm:$false -Force
		Start-Sleep 1
		powershell -file "c:\Program Files\IntunePrepTool\IntunePrepToolReload.ps1"
	}
}

$buttonUser_folder_showInfo_Click = {
	#TODO: Place custom script here
	#$ClientID = "d1ddf0e4-d672-4dae-b554-9d5bdfd93547";
	#$RedirectUri = "urn:ietf:wg:oauth:2.0:oob"
	#$MsalToken = Get-MsalToken -TenantId 'CSNTestRink.onmicrosoft.com' -ClientId $ClientID -Scope 'https://graph.microsoft.com/.default' -RedirectUri $RedirectUri
	#$webbrowser1
}

$package_scheduledtask_usercontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtask_usercontext.Checked -eq $true)
	{
		#$package_scheduledTask_systemcontext.Checked = $false
		
		$package_scheduledTask_systemcontext.Enabled = $true
		$package_scheduledTask_systemcontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $true
		$package_scheduledtask_user_panel4.Visible = $true
		$package_scheduledtask_system_panel3.Enabled = $false
		$package_scheduledtask_system_panel3.Visible = $false
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
	}
	
}

$Package_scheduledtask_User_atlogon_checkbox_logon_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledTask_systemcontext_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledTask_systemcontext.Checked -eq $true)
	{
		#$package_scheduledtask_usercontext.Checked = $false
		$package_scheduledtask_usercontext.Enabled = $true
		$package_scheduledtask_usercontext.Visible = $true
		$package_scheduledtask_user_panel4.Enabled = $false
		$package_scheduledtask_user_panel4.Visible = $false
		$package_scheduledtask_system_panel3.Enabled = $true
		$package_scheduledtask_system_panel3.Visible = $true
		$package_ScheduledTask_create_scripts_button1.Enabled = $true
		$package_ScheduledTask_create_scripts_button1.Visible = $true
		
		
	}
	
}

$package_scheduledtask_system_panel3_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$package_scheduledtasK_user_schedule_checkbox_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
		
	}
	if ($package_scheduledtasK_user_schedule_checkbox.Checked -eq $false)
	{
		if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
}

$package_scheduledtasK_system_onschedule_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_system_onschedule.Checked -eq $true)
	{
		$package_scheduledtask_when_panel_schedule.Visible = $true
		$package_scheduledtask_when_panel_schedule.Enabled = $true
	}
	if ($package_scheduledtasK_system_onschedule.Checked -eq $false)
	{
		if ($package_scheduledtasK_user_schedule_checkbox.checked -eq $false)
		{
			$package_scheduledtask_when_panel_schedule.Visible = $false
			$package_scheduledtask_when_panel_schedule.Enabled = $false
		}
		else
		{
			$package_scheduledtask_when_panel_schedule.Visible = $true
			$package_scheduledtask_when_panel_schedule.Enabled = $true
		}
		
	}
	
	
	
}

$config_app_refresh_button1_Click = {
	#TODO: Place custom script here
	
}

$config_treeview3_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$customPrivacyURL = $custinfo.customPrivacyURL
				$config_tenant_info_CustomPrivacyURL_textbox3.Text = $customPrivacyURL
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
}

$addTenantToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $false
	$config_tenant_info_panel4.Visible = $false
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
	
	
	
	
}

$config_tenant_add_menustrip2_ItemClicked = [System.Windows.Forms.ToolStripItemClickedEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$config_app_regg_add_tenant_button2_Click = {
	#TODO: Place custom script here
	$config_add_Tenant_panel3.Enabled = $true
	$config_add_Tenant_panel3.Visible = $true
	
}

$treeview2_AfterSelect = [System.Windows.Forms.TreeViewEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	
}

$config_tenant_add_button2_Click = {
	#TODO: Place custom script here
	
	$tenantName = $config_tenant_name_textbox3.Text
	$tenantName  = $tenantName -replace (" ", "")
	
	$appRegName = $config_tenant_appRegName_textbox3.Text
	$appRegName = $appRegName -replace (" ", "")
	if ($config_tenant_checkboxYes.Checked -eq $true)
	{
		$customPrivacyURL = $config_tenant_customprivacy_textbox3.text
	}
	else
	{
		$customPrivacyURL = $null
	}
	
	Set-Location $PSScriptRoot
	
	if ([System.Windows.Forms.MessageBox]::Show('Please logon to the tenant with Global Admin rights. App registration will be added. Please wait a few seconds!', 'Logon to tenant', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		

		
		if ($config_tenant_checkboxYes.Checked -eq $true)
		{
			& 'C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe' -AppRegName $AppRegName -CustomerName $tenantName -CustomPrivacyUrl $CustomPrivacyUrl
		}
		else
		{
			& 'C:\Program Files\IntunePrepTool\AddAppRegPlainText.exe' -AppRegName $AppRegName -CustomerName $tenantName -CustomPrivacyUrl 'nvt'
		}
		
		
		
		
		
		
		if (($config_add_Tenant_radiobutton2.Checked -eq $false) -and ($config_add_Tenant_radiobutton1.Checked -eq $false))
		{
			([System.Windows.Forms.MessageBox]::Show('Please select Windows Credential Manager or Plain Text mode', 'Please select savingmode first', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
		}
		refreshTenants
		refreshTenantsUpload
		
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('All Done.', 'Customer added') # Casting the method to [void] suppresses the output. 
		
		
	}
	
	
	
}

$config_tenant_name_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_tenant_appRegName_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$tenanturl_label3_Click = {
	#TODO: Place custom script here
	
}

$package_scheduledtasK_option_Daily_checkbox1_CheckedChanged = {
	#TODO: Place custom script here
	if ($package_scheduledtasK_option_Daily_checkbox1.Checked -eq $true)
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $true
		$package_scheduledtask_daily_time_combobox1.Visible = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $true
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $true
	}
	else
	{
		$package_scheduledtask_daily_time_combobox1.Enabled = $false
		$package_scheduledtask_daily_time_combobox1.Visible = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_am_radiobutton.Visible = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Enabled = $false
		$package_scheduledtask_weekly_daily_pm_radiobutton.Visible = $false
	}
	
	
	
	
}

$package_scheduledtask_daily_time_combobox1_SelectedIndexChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_am_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$package_scheduledtask_weekly_daily_pm_radiobutton_CheckedChanged = {
	#TODO: Place custom script here
	
}

$infoToolStripMenuItem_Click = {
	#TODO: Place custom script here
	$config_tenant_info_panel4.Enabled = $true
	$config_tenant_info_panel4.Visible = $true
	$config_add_Tenant_panel3.Enabled = $false
	$config_add_Tenant_panel3.Visible = $false
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $checkCred.TargetName
				$tenantID = $tenantID.Split("_")[1]
				$AppRegName = $checkCred.TargetName
				$AppRegName = $AppRegName.Split("_")[0]
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $checkCred.UserName
				$config_tenant_info_secret_textbox3.Text = 'xxx'
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_tenant_name_textbox3.Text = $config_treeview3.SelectedNode.Name
				$tenantID = $custinfo.tenantID
				$appID = $custinfo.appId
				$AppRegName = $custinfo.appRegName
				$config_tenant_info_tenantID_textbox3.Text = $tenantID
				$config_tenant_info_appregName_textbox4.Text = $AppRegName
				$config_tenant_info_appID_textbox3.Text = $appID
				$config_tenant_info_secret_textbox3.Text = 'xxx'
				
			}
		}
		
	}
	
	
	
}

$labelTenantName_Click = {
	#TODO: Place custom script here
	
}



$removeToolStripMenuItem_Click = {
	
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$config_tenant_info_secret_show_button2_Click = {
	#TODO: Place custom script here
	$TenantsCSV = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_Tenantinfo.csv"
	foreach ($tInfo in $TenantsCSV)
	{
		if ($tInfo.customerName -eq $config_treeview3.SelectedNode.Name)
		{
			if ($tInfo.target -ne 'plain')
			{
				$checkCred = Get-StoredCredential -Target $tInfo.target -AsCredentialObject
				$config_tenant_info_secret_textbox3.Text = $checkCred.Password
			}
			else
			{
				$cust = $config_treeview3.SelectedNode.Name
				$custinfo = Import-Csv "c:\users\$env:username\.IntunePrepTool\$cust.csv"
				$config_tenant_info_secret_textbox3.Text = $custinfo.clientsecret
			}
		}
		
	}
}


$msix_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	if ($msixpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($msixversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$msixpnaam\$msixversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$msixpnaam\$msixversie\output"
			}
			$msix_output_textbox3.Text = "`nNew package direcotory created: `r`n"
			$msix_output_textbox3.AppendText("$outputDirectory\$msixpnaam\$msixversie\source")
			$msix_output_textbox3.AppendText("`r`n")
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
				$msix_buttonOpenSourceDirectory.Enabled = $true
				$msix_buttonOpenSourceDirectory.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			
			
			
			
		}
	}
}

$msix_packagename_textbox3_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # 
}

$msix_packageVersion_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$config_download_winget_MSIX_bundle_Click = {
	#TODO: Place custom script here
	$config_install_required_winget= @'
# Resolve Winget path
$ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
if ($ResolveWingetPath) {
    $WingetPath = $ResolveWingetPath[-1].Path
}
$wingetexe = $ResolveWingetPath

# Check Winget version
if (Test-path $wingetexe) {
    Write-Host "We are now checking the version of Winget"
    $wingetOption = 1
    $version = & $wingetexe --version
    Write-Host $version
} else {
    Write-Host "We are now checking the version of Winget"
    $wingetOption = 2
    $version = winget --version
    Write-Host $version
}

# Install Winget if needed
if ($version -notlike 'v1.11.430') {
    Write-Host "Winget Version does not match.. installing now"
    [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
    $msixUrl  = "https://github.com/microsoft/winget-cli/releases/download/v1.11.430/Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    $msixPath = "$($env:TEMP)\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    (New-Object System.Net.WebClient).DownloadFile($msixUrl, $msixPath)

    try {
        Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
        Write-Host "Winget installation completed successfully."
    } catch {
        if ($_.Exception.Message -match "Microsoft.VCLibs.140.00.UWPDesktop") {
            Write-Host "Now downloading: Missing dependency 'Microsoft.VCLibs.140.00.UWPDesktop'."
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            $dependencyURL = 'https://github.com/microsoft/winget-cli/releases/download/v1.11.430/DesktopAppInstaller_Dependencies.zip'
            $dependencyPath =  "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
            (New-Object System.Net.WebClient).DownloadFile($dependencyURL, $dependencyPath)
            unblock-file "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip"
            Expand-Archive -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies.zip" -DestinationPath "$($env:TEMP)\DesktopAppInstaller_Dependencies"
            write-host "Now installing dependency"
            try {
            Add-AppxPackage -Path "$($env:TEMP)\DesktopAppInstaller_Dependencies\x64\Microsoft.VCLibs.140.00.UWPDesktop_14.0.33728.0_x64.appx" -ErrorAction Stop
            write-host "Installing depedency done"
            }
            catch {
            Write-host "Installing depedency failed"
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
            }
            try {
            write-host "Now trying to install Winget again"
            Add-AppxPackage -Path $msixPath -Update -ForceApplicationShutdown -ErrorAction Stop
            write-host "Install winget done" 
            }
            catch {
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
            }
        } else {
            Write-Host "An unexpected error occurred: $($_.Exception.Message)"
        }
    }

    # Re-check Winget version after attempted install
    $ResolveWingetPath = Resolve-Path "C:\Program Files\WindowsApps\Microsoft.DesktopAppInstaller_*_x64__8wekyb3d8bbwe\winget.exe"
    if ($ResolveWingetPath) {
        $WingetPath = $ResolveWingetPath[-1].Path
    }
    $wingetexe = $ResolveWingetPath

    if (Test-path $wingetexe) {
        Write-Host "Re-checking Winget version..."
        $version = & $wingetexe --version
        Write-Host $version
    } else {
        Write-Host "Winget executable could not be found after installation attempt."
    }
} else {
    Write-Host "Winget is up to date."
}


'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installWinget.ps1" -PathType Leaf))
		{
			$config_install_required_winget | Out-File "C:\Program Files\IntunePrepTool\installWinget.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installWinget.ps1" -Confirm:$false -Force
			$config_install_required_winget | Out-File "C:\Program Files\IntunePrepTool\installWinget.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installWinget.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
	
	
	
	
	
	
	
	#Start-Process -FilePath "C:\Program Files\IntunePrepTool\MicrosoftDesktopApp.exe" -WindowStyle Normal
}

$MSIX_open_MSIX_button2_Click = {
	#TODO: Place custom script here
	$MSIX_openfiledialog1.ShowDialog()
	$msix_label4.Text = $msix_openfiledialog1.SafeFileName
	$msix_label4.Visible = $true;
	
}

$MSIX_CreateScripts_button2_Click = {
	
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		write-host "Package installed!"
		$excode = 0
	}
	else
	{
      	$MSIXName = $MSIXFile.Replace(".msixbundle", "")
        $PackageFullName = (Get-AppxPackage | where { $_.PackageFamilyName -like "*$MSIXName*" } | Select PackageFullName).PackageFullName
		Remove-AppxPackage -Package $PackageFullName -AllUsers -ErrorAction Stop
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}

if ($install -like "!!doe*")
{
	try
	{
		# Searches for start menu items created in the last 10 minutes
		$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($startmenuI in $startmenuItems)
		{
			Write-Host "`r`n"
			Write-Host "A start menu *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$startmenuI`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	} catch {
		Write-Host "Error looking for *.lnk files in start menu" -ForegroundColor Yellow
	}

	try {
		# Searches for Desktop items created in the last 10 minutes
		$desktopItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -Include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | Where-Object { $_.LastWriteTime -ge (Get-Date).AddMinutes(-10) }).VersionInfo.FileName
		foreach ($desktopItem in $desktopItems) {
			Write-Host "`r`n"
			Write-Host "A Desktop *.lnk file was created in the last 10 minutes." -ForegroundColor Yellow
			Write-Host "To remove this item in this package, please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
			Write-Host "Remove-Item `"$desktopItem`" -Confirm:`$false`" -ForegroundColor Green"
			Write-Host "`r`n"
		}
	}
	catch
	{
		Write-Host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
	}
		Write-Host "`r`n"
		Write-Host "Latest installed PackageFullName is:" -ForegroundColor Yellow
		$lastInstalledPackage = Get-AppxPackage | Sort-Object { $_.InstallDate } -Descending | Select-Object -Last 1
        #$lastInstalledPackage | Format-List
        $packageFullName = $lastInstalledPackage.PackageFullName
		Write-Host "$packageFullName" -ForegroundColor Green


}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -Force
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$msixpnaam\$msixversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	#$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	#$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test install using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_install_button.Enabled = $true
	$MSIX_test_install_button.Visible = $true
	#$MSIX_test_uninstall_button.Enabled = $true
	#$MSIX_test_uninstall_button.Visible = $true
	#$MSIX_Create_Package.Enabled = $true
	#$MSIX_Create_Package.Visible = $true
	$MSIX_packageFullName_textbox3.Enabled = $true
	$MSIX_packageFullName_textbox3.Visible = $true
	$MSIX_create_uninstall_Script_button2.Enabled = $true
	$MSIX_create_uninstall_Script_button2.Visible = $true
	$msix_fullPackageName_label5.Enabled = $true
	$msix_fullPackageName_label5.Visible = $true
	
	
	
	
}

$msix_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	Invoke-Item "$config_packagefolder\$msixpnaam\$msixversie\source\"
}

$MSIX_test_install_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msix_GotoBuildingBlocks_Button.Enabled = $true
	}
}

$MSIX_test_uninstall_button_Click = {
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?...This will open Powershell_ISE ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msixpnaam = $msix_packagename_textbox3.text
		$msixversie = $msix_packageVersion_textbox3.text
		
		powershell_ise -file "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1"
		Start-Sleep 1
		PowershellISEOnTop
		$msix_addBuildingBlokcsCSV_buttonOptionalAddBuildingB.Enabled = $true
	}
}

$MSIX_create_uninstall_Script_button2_Click = {
	#TODO: Place custom script here
	
	$installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.243
	 Created on:   	31-5-2024 14:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	MSIX Install / Uninstall
	===========================================================================
	.DESCRIPTION
		A script for installing or uninstalling an MSIX package.
#>

# Variables will be provided from IntunePrepTool
$MSIXFile = "!!msixfile!!"
$PackageFullName = "!!PackageFullName!!"
$DisplayName = "!!DisplayName!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
$versie = "!!versie!!"
$install = "!!doeinstall!!"

# Dynamic Variables
$regApp1 = $DisplayName
$logfile = Join-Path $logdir "$DisplayName$versie.txt"
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$regApp1"
$excode = $null

# Create log directory if needed
if (!(Test-Path -Path $logdir))
{
	New-Item -ItemType Directory -Path $logdir
}

# Create DLL directory if needed (for Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	New-Item -ItemType Directory -Path "$logdir\dll"
}

# Create root for detection in Registry
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | Out-Null
}

# Create registry application key
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | Out-Null
}

# Start PowerShell functions
function fDetectionInRegistry
{
	# Function to set version and success status in the registry
	param (
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie)
		{
			Set-ItemProperty -Path $regkeyApp -Name Versie -Value $versie
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Versie -Value $versie -PropertyType string
	}
	
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes)
		{
			Set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes
		}
	}
	catch
	{
		New-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}

Set-Location $PSScriptRoot

# Copy IntunePrepTool_msgfile.dll for custom event log
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	Copy-Item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}

# Create Registry IntunePrepTool for MSG file
if (!(Get-ChildItem -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select-Object Name | Where-Object { $_.Name -eq "IntunePrepTool" }))
{
	New-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupported.TypesSupported -ne 7)
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value 7 -PropertyType DWORD
}

try
{
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll")
	{
		Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll"
	}
}
catch
{
	New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}

# Create new event log if needed
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

# Start Transcript. Will be saved under $logdir.
Start-Transcript -Path $logfile
try
{
	if ($install -like "!!doe*")
	{
		Add-ProvisionedAppxPackage -Online -PackagePath $MSIXFile -SkipLicense -ErrorAction Stop
		$excode = 0
	}
	else
	{
		Get-AppxProvisionedPackage -Online | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxProvisionedPackage -Online -ErrorAction Stop
		Get-AppxPackage -AllUsers | Where-Object {$_.PackageFullName -like $PackageFullName} | Remove-AppxPackage -AllUsers -ErrorAction Stop
		write-host "Uninstall of $PackageFullName completed" -ForegroundColor Green
	}
}
catch
{
	Write-Host "Error installing or uninstalling $MSIXFile"
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
#### Place extra actions here:








Stop-Transcript

# Read the last run's log
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 32600)
{
	$lastRun = $lastRun.Substring(0, 32600) + "`n`n****OUTPUT TRUNCATED****"
}

# Log the result
if ($excode -eq 1)
{
	$warning = 'Error'
}
else
{
	$warning = 'Information'
	if ($install -like "!!doe*")
	{
		fDetectionInRegistry -Succes $true
	}
	else
	{
		Remove-Item $regkeyApp
	}
}

# Write to event log
if ($warning -like 'Information')
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Information, 0x3)
}
else
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, [System.Diagnostics.EventLogEntryType]::Error, 0x3)
}

# Copy event log if the directory exists
if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (Test-Path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf)
	{
		Remove-Item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false
	}
	Copy-Item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}

'@
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$MSIxNewname = $msix_openfiledialog1.FileName
	$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
	$MSIxNewname = $MSIxNewname.Replace(" ", "")
	$installfile = $installfile.Replace('!!msixfile!!', $MSIxNewname)
	$installfile = $installfile.Replace('!!DisplayName!!', $msixpnaam)
	$installfile = $installfile.Replace('!!logdir!!', $config_logfoldertarget)
	$installfile = $installfile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$installfile = $installfile.Replace('!!versie!!', $msixversie)
	$packageFullName = $MSIX_packageFullName_textbox3.Text
	$installfile = $installfile.Replace('!!PackageFullName!!', $packageFullName)
	$installfile = $installfile.Replace('!!doeinstall!!', "geeninstall")
	$installFile | Out-File "$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1" -Force
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\source\uninstall.ps1 created")
	$msix_output_textbox3.AppendText("`r`n")
	$msix_output_textbox3.AppendText("You can test uninstall using Powershell ISE (button in GUI)`r`n")
	$MSIX_test_uninstall_button.Enabled = $true
	$MSIX_test_uninstall_button.Visible = $true
	$MSIX_Create_Package.Enabled = $true
	$MSIX_Create_Package.Visible = $true
}

$download_winget_Search_store_Button_Click = {
	#TODO: Place custom script here
	$downloadWingetSearchText = $download_winget_search_textbox5.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements --source=msstore
	$download_winget_output_textbox3.Text = $null
	
	$download_winget_listbox1.Items.Clear()
	$download_winget_version_listbox1.Items.Clear()
	
	
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$table_download_winget.Rows.Add($row_download_winget);
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$download_winget_listbox1.Items.Add($download_winget_listboxInput)
			}
			## - Save changes to the table:
			$table_download_winget.AcceptChanges();
			
			#$download_datagridview1.DataSource = $table_download_winget
			
			#$download_winget_listboxInput = $table_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
			#$download_winget_listbox1.DataSource = $download_winget_listboxInput
			
			
			
		}
		
	}
	
}

$Download_MSSTORE_download_button_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$config_downloadpath = Get-Variable -Name 'config_downloadpath' -ValueOnly -Scope Script
	$download_MSStore_path = "$config_downloadpath\MSStore"
	$MSDownloadLink = $Download_MSSTORE_textbox3.Text
	$MSDownloadLink = $MSDownloadLink.Replace(" ", "")
	if (!(Test-Path -Path $download_MSStore_path))
	{
		
		New-Item -ItemType Directory -Path $download_MSStore_path
	}
	$download_MSSTore_package = @'
# Using: https://github.com/maxbakhub/winposh/blob/main/WindowsDesktopManagement/Download-AppxPackage.ps1
# Found on:
# https://woshub.com/how-to-download-appx-installation-file-for-any-windows-store-app/

function Download-AppxPackage {
[CmdletBinding()]
param (
  [string]$Uri,
  [string]$Path = "."
)
   
  process {
    $Path = (Resolve-Path $Path).Path
    #Get Urls to download
    $WebResponse = Invoke-WebRequest -UseBasicParsing -Method 'POST' -Uri 'https://store.rg-adguard.net/api/GetFiles' -Body "type=url&url=$Uri&ring=Retail" -ContentType 'application/x-www-form-urlencoded'
    $LinksMatch = $WebResponse.Links | where {$_ -like '*.appx*' -or $_ -like '*.appxbundle*' -or $_ -like '*.msix*' -or $_ -like '*.msixbundle*'} | where {$_ -like '*_neutral_*' -or $_ -like "*_"+$env:PROCESSOR_ARCHITECTURE.Replace("AMD","X").Replace("IA","X")+"_*"} | Select-String -Pattern '(?<=a href=").+(?=" r)'
    $DownloadLinks = $LinksMatch.matches.value 

    function Resolve-NameConflict{
    #Accepts Path to a FILE and changes it so there are no name conflicts
    param(
    [string]$Path
    )
        $newPath = $Path
        if(Test-Path $Path){
            $i = 0;
            $item = (Get-Item $Path)
            while(Test-Path $newPath){
                $i += 1;
                $newPath = Join-Path $item.DirectoryName ($item.BaseName+"($i)"+$item.Extension)
            }
        }
        return $newPath
    }
    #Download Urls
    foreach($url in $DownloadLinks){
        $FileRequest = Invoke-WebRequest -Uri $url -UseBasicParsing #-Method Head
        $FileName = ($FileRequest.Headers["Content-Disposition"] | Select-String -Pattern  '(?<=filename=).+').matches.value
        $FilePath = Join-Path $Path $FileName; $FilePath = Resolve-NameConflict($FilePath)
        [System.IO.File]::WriteAllBytes($FilePath, $FileRequest.content)
        echo $FilePath
    }
  }
}

Download-AppxPackage "!!MSStoreLink!!" "!!DLPath!!"
'@
	
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!MSStoreLink!!", "$MSDownloadLink")
	$download_MSSTore_package = $download_MSSTore_package.Replace("!!DLPath!!", "$download_MSStore_path")
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -PathType Leaf))
		{
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		else
		{
			Remove-Item -Path "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1" -Confirm:$false -Force
			$download_MSSTore_package | Out-File "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		}
		
		powershell_ise "C:\windows\temp\intunepreptoolMSStoreDownloadToLib.ps1"
		PowershellISEOnTop
	}
	
}


$MSIX_TIP_button2_Click = {
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://store.rg-adguard.net/'
}

$MSIX_Create_Package_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$msixpnaam = $msix_packagename_textbox3.text
	$msixversie = $msix_packageVersion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	$msix_output_textbox3.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$msixpnaam\$msixversie\source\" -s "$config_packagefolder\$msixpnaam\$msixversie\source\install.ps1" -o "$config_packagefolder\$msixpnaam\$msixversie\output\" -q
	Rename-Item -Path "$config_packagefolder\$msixpnaam\$msixversie\output\install.intunewin" -NewName "$config_packagefolder\$msixpnaam\$msixversie\output\$msixpnaam.intunewin"
	$msix_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msipnaam\$msixversie\output\$msixpnaam.intunewin")
	$msix_output_textbox3.AppendText("`r`n")
	
	$msix_output_textbox3.AppendText("Install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$msix_output_textbox3.AppendText("un-install command is: `r`n")
	$msix_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$msix_output_textbox3.AppendText("Detection registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$msixpnaam\"
	$regkeyApp
	$msix_output_textbox3.AppendText("$regkeyApp `r`n")
	$msix_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: 'Versie' `r`n")
	$msix_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$msix_output_textbox3.AppendText("Detection Value is: $msixversie `r`n")
	$msix_output_textbox3.AppendText("Please reopen tool to make another MSI package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$msixpnaam.intunewin"
			DisplayName   = $msixpnaam
			Publisher	  = $config_customername
			AppVersion    = $msixversie;
			reglocation   = $regkeyApp
			regValue	  = 'Versie'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$msixpnaam\$msixversie\output\"
	$msix_output_textbox3.AppendText("Config.csv written to: `r`n")
	$msix_output_textbox3.AppendText("$config_packagefolder\$msixpnaam\$msixversie\output\config.csv")
	$msix_output_textbox3.AppendText("  `r`n")
	$MSIX_UploadLogo_button.Enabled = $true
	$MSIX_UploadLogo_button.Visible = $true
	#.AppendText("First use Upload Logo to upload *.png file. `r`n")
	#$msix_output_textbox3.AppendText("Then use this file in the upload tab to upload package to Intune. `r`n")
	$buildingBlokcsCSV = $msix_buildingblocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$config_packagefolder\$msixpnaam\$msixversie\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$msixpnaam\BuildingBlocks.csv" -force -NoTypeInformation
		$msix_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$msix_output_textbox3.AppendText("$config_buildingblockspath\$msixpnaam\BuildingBlocks.csv `r`n")
		$msix_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$msix_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$msix_output_textbox3.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$msix_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
	
}

$MSIX_UploadLogo_button_Click = {
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $msix_packagename_textbox3.text
	$msiversie = $msix_packageVersion_textbox3.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
	
	
	
	
}


$powershell_open_install_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_install_OpenFIledialog1.ShowDialog()
	$powershell_install_Script_label5.Text = $Powershell_install_OpenFIledialog1.SafeFileName
	$powershell_install_Script_label5.Visible = $true;
	
	
}

$powershell_open_uninstall_ps_button2_Click = {
	#TODO: Place custom script here
	$Powershell_uninstall_OpenFIledialog1.ShowDialog()
	$powershell_uninstall_Script_label5.Text = $Powershell_uninstall_OpenFIledialog1.SafeFileName
	$powershell_uninstall_Script_label5.Visible = $true;
}

$powershell_create_packageDIR_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	#TODO: Place custom script here
	$fid = $config_packagefolder; $outputDirectory = $fid
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellpnaam = $powershellpnaam -replace (" ", "")
	$powershell_packagename_textbox.text = $powershellpnaam
	$powershellversie = $powershell_packageversion_textbox.Text
	
	if ($powershellpnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($powershellversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
			}
			$powershell_output_textbox5.Text = "`nNew package direcotory created: `r`n"
			$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("Now select Powershell script for install and uninstall first")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_output_textbox5.AppendText("when needed, Add extra files in Package directory by using the 'Open: Source Directory' button")
			$powershell_output_textbox5.AppendText("`r`n")
			$powershell_panel4.Enabled = $true
			$powershell_panel4.Visible = $true
			$powershell_opensource_button2.Enabled = $true
			$powershell_opensource_button2.Visible = $true
			<#
			$msix_output_textbox3.AppendText("`nMSIX file will now be copied`r`n")
			[string]$msix_org_path = $msix_openfiledialog1.FileNames
			try
			{
				Write-Host "$msix_org_path"
				Unblock-File -Path $msix_org_path -Confirm:$false
				$MSIxNewname = $msix_openfiledialog1.FileName
				
				$MSIxNewname = $MSIxNewname.Split("\")[$MSIxNewname.Split("\").Count - 1]
				$MSIxNewname = $MSIxNewname.Replace(" ", "")
				$MSIxbestand = "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname"
				#Write-Host $MSIbestand
				Copy-Item -Path $msix_org_path -Destination "$outputDirectory\$msixpnaam\$msixversie\source\$MSIxNewname" -ErrorAction Stop
				$msix_output_textbox3.AppendText("`nMSIX file copy done `r`n")
				$msix_output_textbox3.AppendText("`nIf you need additional files. Please use open source directory to place files `r`n")
				#$msi_panel1.Enabled = $true
				#$msi_panel1.Visible = $true
				$msix_opensource_button2.Enabled = $true
				$msix_opensource_button2.Visible = $true
				$MSIX_panel4.Enabled = $true
				$MSIX_panel4.Visible = $true
			}
			catch
			{
				$msix_output_textbox3.AppendText("`nfile copy failed. Please select file first  `r`n")
			}
			#>
			
			
			
		}
	}
}

$powershell_generateNEWPS_ps_button2_Click = {
	#TODO: Place custom script here
	if (($powershell_install_Script_label5.text -like "label5") -or ($powershell_uninstall_Script_label5.text -like "label5"))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Use button to select script', 'Please select install and / or uninstall source script first!')
	}
	else
	{
		if (($powershell_radiobutton2.Checked -eq $false) -and ($powershell_radiobutton1.Checked -eq $false))
		{
			[void][System.Windows.Forms.MessageBox]::Show('Select user or system context first', 'Please select user or system context first')
		}
		else
		{
			
			$powershell_output_textbox5.AppendText("`Generating install and uninstall powershell scripts...`r`n")
			
			$powershelll_user_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1  }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
			$powershelll_user_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1  }
else { remove-item $regkeyApp; exit 0 }
'@
			
if ($powershell_radiobutton2.Checked -eq $true)
	{
	$powershelll_installFile = $powershelll_user_installFile
	$powershell_uninstallFile = $powershelll_user_uninstallFile
	}
	if ($powershell_radiobutton1.Checked -eq $true) {
	$powershelll_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
#klant variabelen
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{

#PowershellInstallStart



}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
    $excode = 1
}
### Place extra actions here:







<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { fDetectionInRegistry -succes $true 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
			$powershell_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2023 v5.8.221
	 Created on:   	03-06-2024 21:00
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		Parameters will be filled by IntunePrepTool.
#>

$appNaam = "!!AppNaam!!"
$versie = "!!versie!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appnaam$versie.txt")
$filenaamMSILog = $appNaam + $versie + "MSI"
$logfileMSI = $(Join-Path $logdir  "$filenaamMSILog.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appNaam"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}

try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}

#Start Script
Start-Transcript -Path $logfile
try
{
#PowershellUninstallStart


}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript

$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1) { 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else { remove-item $regkeyApp 
[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs") {
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) {remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false } 
copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1  }
else { exit 0 }
'@
				
			}
			
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
			$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
			$powershellpnaam = $powershell_packagename_textbox.text
			$powershellversie = $powershell_packageversion_textbox.Text
			$fid = $config_packagefolder; $outputDirectory = $fid
			$logdir = $config_logfoldertarget
			$RegisterDetectionroot = "Intune_" + $config_customername
			[string]$powershell_install_org_path = $Powershell_install_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_install_org_path -Confirm:$false
			$powershellInputInstall = Get-Content -Path $powershell_install_org_path
			#Write-Host $powershellInputInstall
		
			$powershelll_installFile = $powershelll_installFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershelll_installFile = $powershelll_installFile.Replace('!!logdir!!', $logdir)
			$powershelll_installFile = $powershelll_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershelll_installFile = $powershelll_installFile.Replace('!!versie!!', $powershellversie)
			$powershelll_installFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			$powershelll_installFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Force
			foreach ($line in $powershelll_installFile)
			{
				if ($line -like "#PowershellInstallStart*")
				{
					
					foreach ($inputLine in $powershellInputInstall)
					{
						
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -Append
				}
				
				
			}
				
			
			copy-item "IntunePrepTool_msgfile.dll" -Destination "$outputDirectory\$powershellpnaam\$powershellversie\source\IntunePrepTool_msgfile.dll" -Confirm:$false
			
			
			
			
			
			
			[string]$powershell_uninstall_org_path = $Powershell_uninstall_OpenFIledialog1.FileNames
			Unblock-File -Path $powershell_UNinstall_org_path -Confirm:$false
			$powershellInputUNInstall = Get-Content -Path $powershell_UNinstall_org_path
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!AppNaam!!', "$powershellpnaam")
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!logdir!!', $logdir)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
			$powershell_uninstallFile = $powershell_uninstallFile.Replace('!!versie!!', $powershellversie)
			$powershell_uninstallFile | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			$powershell_uninstallFile = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
			"#Start" | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Force
			foreach ($line in $powershell_uninstallFile)
			{
				if ($line -like '#PowershellUninstallStart*')
				{
					
					foreach ($inputLine in $powershellInputUNInstall)
					{
						$inputLine | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
					}
				}
				else
				{
					$line | Out-File "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1" -Append
				}
				
				
			}
			$powershell_output_textbox5.AppendText("`New install.ps1 and uninstall.ps1 created!`r`n")
			$powershell_output_textbox5.AppendText("`nTest your script. If needed, save in Powershell_ISE directly. `r`n")
			$Powershell_testUnInstall_button2.Enabled = $true
			$Powershell_testUnInstall_button2.Visible = $true
			$Powershell_testInstall_button2.Enabled = $true
			$Powershell_testInstall_button2.Visible = $true
			$Powershell_CreateIntuneWIn_button2.Enabled = $true
			$Powershell_CreateIntuneWIn_button2.Visible = $true
			
		}
	}

}

$powershell_opensource_button2_Click = {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	Invoke-Item "$config_packagefolder\$powershellpnaam\$powershellversie\source\"
}

$powershell_install_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_uninstall_Script_label5_Click = {
	#TODO: Place custom script here
	
}

$powershell_packagename_textbox_TextChanged = {
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$Powershell_testInstall_button2_Click = {
	#TODO: Place custom script here
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$usercontext = 'In User context'
		$sysemcontext = $null;
		
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$usercontext = 'in Sytem context'
		$sysemcontext = 'Testing Sytem context as Elevated user;'
	}
	if ([System.Windows.Forms.MessageBox]::Show("Please test your script. After editing. Please use the save button in Powershell_ISE", "Openening Powershell_ISE in $32or64", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.Text
		$powershellversie = $powershell_packageversion_textbox.Text
		$installScript = Join-Path -Path $config_packagefolder -ChildPath "$powershellpnaam\$powershellversie\source\install.ps1"
		$ise32Path = "$env:windir\SysWOW64\WindowsPowerShell\v1.0\PowerShell_ISE.exe"
		$ise64Path = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe"
		if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
		{
				Start-Process -FilePath $ise32Path -ArgumentList $installScript
		}
		else
		{
				Start-Process -FilePath $ise64Path -ArgumentList $installScript
		}
		PowershellISEOnTop
		
	}
}

$Powershell_testUnInstall_button2_Click = {
	#TODO: Place custom script here
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$usercontext = 'In User context'
		$sysemcontext = $null;
		
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$usercontext = 'in Sytem context'
		$sysemcontext = 'Testing Sytem context as Elevated user;'
	}
	if ([System.Windows.Forms.MessageBox]::Show("Please test your script. After editing. Please use the save button in Powershell_ISE", "Openening Powershell_ISE in $32or64", [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$powershellpnaam = $powershell_packagename_textbox.Text
		$powershellversie = $powershell_packageversion_textbox.Text
		$installScript = Join-Path -Path $config_packagefolder -ChildPath "$powershellpnaam\$powershellversie\source\uninstall.ps1"
		$ise32Path = "$env:windir\SysWOW64\WindowsPowerShell\v1.0\PowerShell_ISE.exe"
		$ise64Path = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell_ise.exe"
		if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
		{
				Start-Process -FilePath $ise32Path -ArgumentList $installScript
		}
		else
		{
				Start-Process -FilePath $ise64Path -ArgumentList $installScript
		}
		PowershellISEOnTop
		
	}
}

$Powershell_CreateIntuneWIn_button2_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $false)
	{
		$32or64 = "32 Bit Mode"
	}
	else
	{
		$32or64 = "64 Bit Mode"
	}
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$powershellpnaam = $powershell_packagename_textbox.text
	$powershellversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder
	$RegisterDetectionroot = "Intune_" + $config_customername
	$powershell_output_textbox5.Text = "Creation of Intunewin file has started. Please wait."
	& .\IntuneWinAppUtil.exe -c "$outputDirectory\$powershellpnaam\$powershellversie\source\" -s "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1" -o "$outputDirectory\$powershellpnaam\$powershellversie\output\" -q
	Rename-Item -Path "$outputDirectory\$powershellpnaam\$powershellversie\output\install.intunewin" -NewName "$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin"
	$powershell_output_textbox5.AppendText("`nIntunewin file created: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\$powershellpnaam.intunewin")
	$powershell_output_textbox5.AppendText("`r`n")
	
	$powershell_output_textbox5.AppendText("Install command is: `r`n")
	if ($32or64 -like "32 Bit Mode")
	{
		$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
		$powershell_output_textbox5.AppendText("un-install command is: `r`n")
		$powershell_output_textbox5.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
		$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	}
	else
	{
		$powershell_output_textbox5.AppendText("%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1 `r`n")
		$powershell_output_textbox5.AppendText("un-install command is: `r`n")
		$powershell_output_textbox5.AppendText("%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file uninstall.ps1 `r`n")
		$powershell_output_textbox5.AppendText("Detection registry is: `r`n")
	}
	
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		if ($32or64 -like "32 Bit Mode")
		{
			$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		}
		else
		{
			$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\$RegisterDetectionroot\"
		}
		
		$regkeyApp = "$regkeyRoot$powershellpnaam"
	}
	$powershell_output_textbox5.AppendText("$regkeyApp `r`n")
	$powershell_output_textbox5.AppendText("Detection Method is: 'String Comparison' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: 'Version' `r`n")
	$powershell_output_textbox5.AppendText("Detection Operator is: 'Equals' `r`n")
	$powershell_output_textbox5.AppendText("Detection Value is: $powershellversie `r`n")
	$powershell_output_textbox5.AppendText("Please reopen tool to make another Powershell package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
		[string]$context
	}
	if ($powershell_radiobutton2.Checked -eq $true)
	{
		$context = 'user'
	}
	if ($powershell_radiobutton1.Checked -eq $true)
	{
		$context = 'system'
	}
	$IntuneWinPackageConfig = $null;
	if ($powershell_checkboxForce64bitPowershell.Checked -eq $true)
	{
		$icmd = '%SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1'
		$ucmd = 'SystemRoot%\Sysnative\WindowsPowerShell\v1.0\powershell.exe -executionpolicy bypass -file install.ps1'
	}
	else
	{
		$icmd = "powershell -executionpolicy bypass -file install.ps1"
		$ucmd = "powershell -executionpolicy bypass -file uninstall.ps1"
	}
	
	
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$powershellpnaam.intunewin"
			DisplayName   = $powershellpnaam
			Publisher	  = $config_customername
			AppVersion    = $powershellversie;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = $icmd
			uninstallCMD  = $ucmd
			context		  = $context
		})
	
	$IntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$outputDirectory\$powershellpnaam\$powershellversie\output\"
	$powershell_output_textbox5.AppendText("Config.csv written to: `r`n")
	$powershell_output_textbox5.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv")
	$powershell_output_textbox5.AppendText("  `r`n")
	$Powershell_upload_logo_button.Enabled = $true
	$Powershell_upload_logo_button.Visible = $true
	$powershell_output_textbox5.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
	$powershell_output_textbox5.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
}

$Powershell_upload_logo_button_Click = {
	#TODO: Place custom script here
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $powershell_packagename_textbox.text
	$msiversie = $powershell_packageversion_textbox.Text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
	
}


$updatepackage_msi_open_config_button1_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$updatepackage_msi_appname_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appname_new_textbox3.Text = $ConfigCSVImport.DisplayName
	$updatepackage_msi_appversion_textbox3.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$updatepackage_msi_appcustomer_textbox3.Text = $updatepackage_customername
	$updatepackage_msi_panel5.Enabled = $true
	$updatepackage_msi_panel5.Visible = $true
	$updatepackage_msi_panel4.Visible = $true
	$updatepackage_msi_panel4.Enabled = $true
}

$updatepackage_msi_label5_Click = {
	#TODO: Place custom script here
	
}

$labelAppName_Click = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_Yes_radiobutton1_CheckedChanged = {
	#TODO: Place custom script here
	if ($updatepackage_msi_Yes_radiobutton1.Checked -eq $true)
	{
		$updatepackage_msi_panel6.Enabled = $true
		$updatepackage_msi_panel6.Visible = $true
	}
	else
	{
		$updatepackage_msi_panel6.Enabled = $false
		$updatepackage_msi_panel6.Visible = $false
	}
}

$updatepackage_msi_clone_button_Click = {
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($updatepackage_msi_change_customer_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($updatepackage_msi_appversion_new_textbox3.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $updatepackage_msi_change_customer_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$updatepackage_msi_appname_new_textbox3.text = $powershellpnaam
		$powershellversie = $updatepackage_msi_appversion_new_textbox3.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_msi_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_msi_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $updatepackage_msi_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_msi_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$versie  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$versie  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$versie =*') -or ($lni -like '$appNaam =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_msi_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_msi_output_textbox4.AppendText("config.csv creation done; Please open new package source dir and change MSI file and other source files; Step 3")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("Replace MSI file for newer version with a. MSI file with the same name or b. change the Install parameters below")
		$updatepackage_msi_output_textbox4.AppendText("`r`n")
		$updatepackage_msi_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
	}
	
}


$updatepackage_msi_appname_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_appversion_new_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_panel5_Paint = [System.Windows.Forms.PaintEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$updatepackage_msi_installParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_open_source_dir_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	
}

$updatepackage_msi_testinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Add-Type -AssemblyName PresentationFramework
	$imagePath = "C:\Program Files\IntunePrepTool\update_package_msi_copy_uninstallstring.png"
	$window = New-Object system.windows.window
	$window.Title = "IntunePrepTool MSI uninstall command help"
	$window.Width = 603
	$window.Height = 700
	$window.WindowStartupLocation = 'CenterScreen'
	$dockPanel = New-Object System.Windows.Controls.DockPanel
	$image = New-Object System.Windows.Controls.Image
	$image.Source = [System.Windows.Media.Imaging.BitmapImage]::new([Uri]::new($imagePath))
	$image.Stretch = "Fill"
	$button = New-Object System.Windows.Controls.Button
	$button.Content = "Understood, open PowerShell_ISE now"
	$button.Width = 250
	$button.HorizontalAlignment = "Center"
	$button.VerticalAlignment = "Bottom"
	$button.Add_Click({
			powershell_ise -file "$newpackage_sourcepath\install.ps1"
			$window.Close() # Close the window after opening PowerShell ISE
		})
	[System.Windows.Controls.DockPanel]::SetDock($button, [System.Windows.Controls.Dock]::Bottom)
	$dockPanel.Children.Add($button)
	$dockPanel.Children.Add($image)
	$window.Content = $dockPanel
	$window.ShowDialog()
	
	
	$updatepackage_msi_panel66.Enabled = $true
}

$updatepackage_msi_saveinstallparemeters_button_Click = {
	#TODO: Place custom script here
	$updatepackage_msi_testinstall_button1.Enabled = $true
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_installParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\i.cmd" -encoding ascii -Force -ErrorAction Stop
}

$updatepackage_msi_testuninstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$jjmsii2 = $updatepackage_msi_uninstallParameters_textbox3.Text
	$jjmsii2 | Out-File "$newpackage_sourcepath\u.cmd" -encoding ascii -Force -ErrorAction Stop
	$updatepackage_msi_testuinstall_button1.Enabled = $true
}

$updatepackage_msi_uninstallParameters_textbox3_TextChanged = {
	#TODO: Place custom script here
	
}

$updatepackage_msi_testuinstall_button1_Click = {
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
	$updatepackage_msi_panel67.Enabled = $true
}

$updatepackage_msi_createIntuneWin_button1_Click = {
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $updatepackage_msi_appname_new_textbox3.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_msi_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_msi_output_textbox4.AppendText("`r`n")
	
	$updatepackage_msi_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_msi_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_msi_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
	
}



$exe_open_Azure_OpenAI_Example_button1_Click = {
	#TODO: Place custom script here
	
	if (!(Test-Path "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"))
	{
		[void][System.Windows.Forms.MessageBox]::Show("Go to config tab to configure Azure AI OpenAI Deployment", 'Please setup Azure AI Config first')
	}
	else
	{
		$OpenAICSV = Import-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv"
		
		
		$exe_appDname = $exe_packagenaam_textbox1.Text
		$EXEName = $exe_openfiledialog1.SafeFileName
		$apiKey = $OpenAICSV.Key
		$endpoint = $OpenAICSV.endpointURL
		$deployname = $OpenAICSV.deploymentName
		$uri = $endpoint + "openai/deployments/" + $deployname + "/chat/completions?api-version=2024-02-15-preview"
		$body = @"
{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Show example of silent install parameters for $exe_appDname EXE file: $EXEName"
        }
      ]
    }
  ],
  "temperature": 0.4,
  "top_p": 0.95,
  "max_tokens": 800
}
"@
		
		
		$headers = @{
			"Content-Type" = "application/json"
			"api-key"	   = $apiKey
		}
		try
		{
			$request = Invoke-RestMethod -Method POST -Uri $uri -ContentType "application/json" -Body $body -Headers $headers -ErrorAction Stop
			$text = $request.choices.message.content
			$startPattern = '```sh'
			$endPattern = '```'
			$start = $text.IndexOf($startPattern) + $startPattern.Length
			$end = $text.IndexOf($endPattern, $start)
			
			
			if ($start -ge 0 -and $end -gt $start)
			{
				$command = $text.Substring($start, $end - $start).Trim()
				
				$commandParts = $command -split " "
				$commandWithoutExe = $commandParts[1 .. ($commandParts.Length - 1)] -join " "
				
				$exe_parsInstall_textbox1.Text = "`"$commandWithoutExe`""
				$text = $text -replace '```sh', ""
				$text = $text -replace '`', ""
				$exe_richtextbox3.Text = $text
				$exe_panel5.Enabled = $true
				$exe_panel5.Visible = $true
				$exe_open_Azure_OpenAI_Example_button1.Text = "Retry Azure OpenAI"
				
			}
			
		}
		catch
		{
			
			if ($_.Exception.Message -like 'The remote server returned an error: (429) Too Many Requests.')
			{
				
				[void][System.Windows.Forms.MessageBox]::Show('Please wait 30 seconds before trying again', '(429) Too Many Requests.')
			}
			else
			{
				[void][System.Windows.Forms.MessageBox]::Show("($_.Exception.Message)", 'Error message')
			}
		}
	}
}

$config_openAI_save_button2_Click = {
	#TODO: Place custom script here
	class openAIAzure {
		[string]$key
		[string]$endpointURL
		[string]$deploymentName
		
	}
	$openAIAzure = $null;
	$openAIAzure += @([openAIAzure]@{
			key		       = $config_openAI_textbox6.Text
			endpointURL    = $config_openAI_textbox7.Text
			deploymentName = $config_openAI_textbox8.Text
			
		})
	
	$openAIAzure | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_azureOpenAI.csv" -NoTypeInformation -Force
	[void][System.Windows.Forms.MessageBox]::Show('U can use the Azure OpenAI button in the tool now', 'CSV file with config written to  c:\users\$env:USERNAME\.IntunePrepTool\')
	
}


$config_openAI_help_Click = {
	#TODO: Place custom script here
	Invoke-Item "C:\Program Files\IntunePrepTool\IntunePrepTool-AzureOpenAI-setup-Screenshots.pdf"

}




$config_openAI_textbox8_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox7_TextChanged = {
	#TODO: Place custom script here
	
}

$config_openAI_textbox6_TextChanged = {
	#TODO: Place custom script here
	
}

$powershell_radiobutton2_CheckedChanged={
	#TODO: Place custom script here
	
}

$updatePackageIntunewinToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}

$updatepackage_exe_open_config_button1_Click={
	#TODO: Place custom script here
	$update_exe_openfiledialog1.ShowDialog()
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$ConfigCSVImport = Import-Csv $config_csv_path
	$update_exe_appname_old_textbox5.Text = $ConfigCSVImport.DisplayName
	$update_exe_new_appname_textbox7.Text = $ConfigCSVImport.DisplayName
	$update_exe_appversion_old_textbox4.Text = $ConfigCSVImport.AppVersion
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	$llni = $null;
	foreach ($lni in $installps1)
	{
		if ($lni -like '$RegisterDetectionroot = "Intune*')
		{
			$llni = $lni
			
		}
		
	}
	$updatepackage_customername = $llni -replace '\$RegisterDetectionroot = "Intune_', '' -replace '"$', ''
	$update_exe_customer_old_textbox3.Text = $updatepackage_customername
	$updatepackage_EXE_panel6.Enabled = $true
	$updatepackage_EXE_panel6.Visible = $true
	$update_exe_panel4.Visible = $true
	$update_exe_panel4.Enabled = $true
}

$update_exe_buttonStep2CloneToNewDirec_Click={
	#TODO: Place custom script here
	$clonepackageOK = $false
	[string]$config_csv_path = $update_exe_openfiledialog1.FileNames
	$packageRoot = $config_csv_path -replace '\\output\\config.csv$', ''
	$installps1 = Get-Content "$packageRoot\source\install.ps1"
	
	
	
	if ($update_exe_listbox1.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select new customer first', 'Select new customer first')
		$clonepackageOK = $false
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$clonepackageOK = $true
	}
	
	
	if ($clonepackageOK -eq $true)
	{
		if ($update_exe_new_appversion_textbox6.Text -like $null)
		{
			#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
			[void][System.Windows.Forms.MessageBox]::Show('Fill in the app version of the new package please', 'Please choose new version name')
			$clonepackageOK = $false
		} # Casting the method to [void] suppresses the output. 
		else
		{
			$clonepackageOK = $true
		}
	}
	if ($clonepackageOK -eq $true)
	{
		$newpackagecustomername = $update_exe_listbox1.SelectedItem
		try
		{
			$config_import_csv = Import-Csv "c:\users\$env:username\.IntunePrepTool\config_customerinfo.csv" -ErrorAction Stop
		}
		catch
		{
			#Error handling here
		}
		
		foreach ($cis in $config_import_csv)
		{
			if ($cis.customername -eq $newpackagecustomername)
			{
				try
				{
					New-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_customername' -Value $cis.customername -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_logfoldertarget' -Value $cis.logfoldertarget -Scope Script
				}
				try
				{
					New-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script -ErrorAction Stop
				}
				catch
				{
					Set-Variable -Name 'newpackage_packagefolder' -Value $cis.packagefolder -Scope Script
				}
			}
		}
		$newpackage_packagefolder = Get-Variable -Name 'newpackage_packagefolder' -ValueOnly -Scope Script
		$newpackage_logfoldertarget = Get-Variable -Name 'newpackage_logfoldertarget' -ValueOnly -Scope Script
		$newpackage_customername = Get-Variable -Name 'newpackage_customername' -ValueOnly -Scope Script
		#TODO: Place custom script here
		$fid = $newpackage_packagefolder; $outputDirectory = $fid
		$powershellpnaam = $update_exe_new_appname_textbox7.text
		$powershellpnaam = $powershellpnaam -replace (" ", "")
		$update_exe_new_appname_textbox7.text = $powershellpnaam
		$powershellversie = $update_exe_new_appversion_textbox6.Text
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\source"
		}
		if (!(Test-Path -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"))
		{
			New-Item -ItemType Directory -Path "$outputDirectory\$powershellpnaam\$powershellversie\output"
		}
		$updatepackage_exe_output_textbox4.Text = "`nNew package direcotory created: `r`n"
		$updatepackage_exe_output_textbox4.AppendText("$outputDirectory\$powershellpnaam\$powershellversie\source")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("We will now copy package files to new direcotory; Please be patiant when it is a large package. Application will not respond while copying")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		[string]$old_config_csv_path = $update_exe_openfiledialog1.FileNames
		$old_packageRoot = $old_config_csv_path -replace '\\output\\config.csv$', ''
		$sourcePath = $old_packageRoot
		$destinationPath = "$outputDirectory\$powershellpnaam\$powershellversie"
		$excludedFiles = @("config.csv", "install.ps1", "uninstall.ps1")
		Get-ChildItem -Path $sourcePath -Recurse -File |
		Where-Object { $_.Extension -ne ".intunewin" -and $_.Name -notin $excludedFiles } |
		ForEach-Object {
			$dest = $_.FullName -replace [regex]::Escape($sourcePath), $destinationPath
			$destDir = Split-Path $dest
			if (-not (Test-Path $destDir))
			{
				New-Item -ItemType Directory -Path $destDir | Out-Null
			}
			Copy-Item -Path $_.FullName -Destination $dest
		}
		$updatepackage_exe_output_textbox4.AppendText("File copy done. We will now generate the new install.ps1 file")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_installps1 = Get-Content "$old_packageRoot\source\install.ps1"
		$newinstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		'#Updated package with IntunePrepTool' | Out-File $newinstallps1 -force
		foreach ($lni in $old_installps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appName =*') -or ($lni -like '$version  =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$version  =*')
				{
					$oudeversie = $lni.split("=")[1]
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newinstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newinstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newinstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Install.ps1 creation done. We will now create the new uninstall.ps1")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$old_uninstallps1 = Get-Content "$old_packageRoot\source\uninstall.ps1"
		$newuninstallps1 = "$outputDirectory\$powershellpnaam\$powershellversie\source\uninstall.ps1"
		foreach ($lni in $old_uninstallps1)
		{
			if (($lni -like '$RegisterDetectionroot = "Intune*') -or ($lni -like '$logdir =*') -or ($lni -like '$version =*') -or ($lni -like '$appNaam =*') -or ($lni -like '$appName =*') -or ($lni -like 'Versie =*'))
			{
				if ($lni -like '$RegisterDetectionroot = "Intune*')
				{
					$lni.split("=")[0] + "= " + '"Intune_' + $newpackage_customername + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$logdir =*')
				{
					$lni.split("=")[0] + "= " + '"' + $newpackage_logfoldertarget + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$version =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$versie =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellversie + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appName =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
				if ($lni -like '$appNaam =*')
				{
					$lni.split("=")[0] + "= " + '"' + $powershellpnaam + '"' | Out-File $newuninstallps1 -Append
				}
			}
			else
			{
				$lni | Out-File $newuninstallps1 -Append
			}
		}
		$updatepackage_exe_output_textbox4.AppendText("Uninstall.ps1 creation done. We will now create a new config.csv")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		
		$RegisterDetectionroot = "Intune_$newpackage_customername"
		$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
		$regkeyApp = "$regkeyRoot$powershellpnaam"
		$regkeyApp
		class CSNIntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
		}
		$CSNIntuneWinPackageConfig = $null;
		$CSNIntuneWinPackageConfig += @([CSNIntuneWinPackageConfig]@{
				IntuneWinFile = "$powershellpnaam.intunewin"
				DisplayName   = $powershellpnaam
				Publisher	  = $config_customername
				AppVersion    = $powershellversie;
				reglocation   = $regkeyApp
				regValue	  = 'Versie'
				installCMD    = "powershell -executionpolicy bypass -file install.ps1"
				uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
			})
		
		$CSNIntuneWinPackageConfig | Export-Csv "$outputDirectory\$powershellpnaam\$powershellversie\output\config.csv" -NoTypeInformation
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("Replace EXE file for newer version with a. EXE file with the same name or b. change the Install parameters below")
		$updatepackage_exe_output_textbox4.AppendText("`r`n")
		$updatepackage_exe_output_textbox4.AppendText("The logfile is already up to date with new version in the install parameters below")
		<#
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\i.cmd"
		$oudeversie = $oudeversie -replace '"', ''
		$oudeversie = $oudeversie -replace ' ', ''
		$oudeversie = $oudeversie + "MSI"
		Write-Host $oudeversie
		Write-Host $nieuweversie
		$nieuweversie = $powershellversie + "MSI"
		$installparameters2 = $installparameters -replace $oudeversie, $nieuweversie
		$updatepackage_msi_installParameters_textbox3.Text = $installparameters2
		$updatepackage_msi_panel65.Enabled = $true
		$updatepackage_msi_panel65.Visible = $true
		
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		#>
		$update_exe_panel6.Enabled = $true
		try
		{
			New-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script -ErrorAction Stop
		}
		catch
		{
			Set-Variable -Name 'newpackage_sourcepath' -Value "$outputDirectory\$powershellpnaam\$powershellversie\source\" -Scope Script
		}
		$installparameters = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\install.ps1"
		foreach ($lni2 in $installparameters)
		{
			if ($lni2 -like '$exeParameters =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exeparameters2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exeparameters2 = $null
				}
				$exeparameters2 = $exeparameters2 -replace "^ ", ""
				$exeparameters2 = $exeparameters2.split("#")[0]
				$update_exe_installPar_textbox3.Text = $exeparameters2
			}
			if ($lni2 -like '$exeFile =*')
			{
				$index = $lni2.IndexOf("=")
				if ($index -ne -1)
				{
					$exefilename2 = $lni2.Substring($index + 1)
				}
				else
				{
					$exefilename2 = $null
				}
				$exefilename2 = $exefilename2 -replace "^ ", ""
				
				$update_exe_Exefilename_textbox3.Text = $exefilename2
			}
			
		}

	
		$IsThisLineThereInUninstall = $old_uninstallps1 | ForEach-Object {
			if ($_ -match 'Please see u\.cmd for MSI parameters used by this script')
			{
				$_.Trim() 
			}
		} | Where-Object { $_ }
		if ($IsThisLineThereInUninstall)
		{
			Write-Host "De regel is aanwezig: $IsThisLineThereInUninstall"
			$update_exe_uninstall_panel6.Enabled = $false
			$update_exe_uninstall_panel6.Visible = $false
			$update_Exe_Uninstall_MSI_panel6.Enabled = $true
			$update_Exe_Uninstall_MSI_panel6.Visible = $true
			$update_exe_msi_uninstallcommandsOld = Get-Content "$outputDirectory\$powershellpnaam\$powershellversie\source\u.cmd"
			$udpdate_exe_msi_uninstall_textbox4.Text = $update_exe_msi_uninstallcommandsOld
			[void][System.Windows.Forms.MessageBox]::Show('See Find Uninstall String in the tools menu to search for new uninstall productcode and change the uninstall parameters after testing installation', 'Change uninstall string')
			
		}
		else
		{
			$oldInstallExeFilename = $old_installps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeFilename = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeFile\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			$oldUnInstallExeParameters = $old_uninstallps1 | ForEach-Object {
				if ($_ -match '^\$exeParameters\s*=\s*(.+)')
				{
					$matches[1].Trim()
				}
			} | Where-Object { $_ }
			
			#Write-Host "Old Install EXE Filename: $oldInstallExeFilename"
			#Write-Host "Old Uninstall EXE Filename: $oldUnInstallExeFilename"
			if ($oldInstallExeFilename -like $oldUnInstallExeFilename)
			{
				#Write-Host "Same EXE as install: $oldUnInstallExeFilename)"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
			Else
			{
				#Write-Host "Uninstall EXE path is $oldUnInstallExeFilename"
				$update_exe_uninstall_panel6.Enabled = $true
				$update_exe_uninstall_panel6.Visible = $true
				$update_Exe_Uninstall_MSI_panel6.Enabled = $false
				$update_Exe_Uninstall_MSI_panel6.Visible = $false
				$update_exe_filetpathUninstall_textbox3.Text = $oldUnInstallExeFilename
				$update_exe_uninstall_parameters_textbox3.Text = $oldUnInstallExeParameters
			}
		}
		
		
		
	}
}

$update_exe_buttonStep3OpenSourceDirec_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	Invoke-Item $newpackage_sourcepath
	$updatepackage_msi_saveinstallparemeters_button.Enabled = $true
	$update_exe_buttonStep4SaveInstallPara.Enabled = $true
}

$update_exe_buttonStep4SaveInstallPara_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$installparameters = Get-Content "$newpackage_sourcepath\install.ps1"
	Remove-Item "$newpackage_sourcepath\install.ps1"
	foreach ($lni2 in $installparameters)
	{
		if (($lni2 -like '$exeParameters =*') -or ($lni2 -like '$exeFile =*'))
		{
			
			
			if ($lni2 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_installPar_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
			if ($lni2 -like '$exeFile =*')
			{
				
				'$exeFile = ' + $update_exe_Exefilename_textbox3.Text | Out-File "$newpackage_sourcepath\install.ps1" -Append
			}
		}
		else
		{
			$lni2 | Out-File "$newpackage_sourcepath\install.ps1" -Append
		}
		
	}
	$update_exe_buttonStep5TestAndEditInst.Enabled = $true
}

$update_exe_buttonStep5TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\install.ps1"
	
}

$buttonStep7TestAndEditUnin_Click={
	#TODO: Place custom script here
	
}

$update_exe_uninstall_msi_save_button3_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$udpdate_exe_msi_uninstall_textbox4.Text | Out-File "$newpackage_sourcepath\u.cmd" -Force
	$update_exe_uninstall_MSI_Test_button2.Enabled = $true
}

$update_exe_uninstall_MSI_Test_button2_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$buttonStep6SaveUninstallPa_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$uninstall_exe_uninstall = Get-Content "$newpackage_sourcepath\uninstall.ps1"
	Remove-Item "$newpackage_sourcepath\uninstall.ps1" -Confirm:$false -Force
	foreach ($lni5 in $uninstall_exe_uninstall)
	{
		if (($lni5 -like '$exeFile =*') -or ($lni5 -like '$exeParameters =*'))
		{
			if ($lni5 -like '$exeFile =*')
			{
				'$exeFile = ' + $update_exe_filetpathUninstall_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
			if ($lni5 -like '$exeParameters =*')
			{
				'$exeParameters = ' + $update_exe_uninstall_parameters_textbox3.Text | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			}
		}
		else
		{
			$lni5 | Out-File "$newpackage_sourcepath\uninstall.ps1" -Append
			
		}
		
	}
	$update_exe_testuninstall_exe_buttonStep7TestAndEditInst.Enabled = $true
	
}

$update_exe_testuninstall_exe_buttonStep7TestAndEditInst_Click={
	#TODO: Place custom script here
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	powershell_ise -file "$newpackage_sourcepath\uninstall.ps1"
}

$update_exe_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	$newpackage_sourcepath = Get-Variable -Name 'newpackage_sourcepath' -ValueOnly -Scope Script
	$newpackage_outputpath = $newpackage_sourcepath -replace '(.*)source', '${1}output'
	Write-Host $newpackage_outputpath
	$powershellpnaam = $update_exe_new_appname_textbox7.text
	[void][System.Windows.Forms.MessageBox]::Show('IntunePrepTool will not respond until the Intunewinfile is finished', 'Creating Intunewin file now')
	& .\IntuneWinAppUtil.exe -c $newpackage_sourcepath -s "$newpackage_sourcepath\install.ps1" -o $newpackage_outputpath -q
	Rename-Item -Path "$newpackage_outputpath\install.intunewin" -NewName "$newpackage_outputpath\$powershellpnaam.intunewin"
	[void][System.Windows.Forms.MessageBox]::Show("Use can use the upload function in the IntunePrepTool; Config.csv is located in: $newpackage_outputpath", 'Intunewin file finished')
	
	$IntunePreptToolInfoForIntune = Import-Csv "$newpackage_outputpath\config.csv"
	$reglocation = $IntunePreptToolInfoForIntune.reglocation
	$AppVersion = $IntunePreptToolInfoForIntune.AppVersion
	$updatepackage_exe_output_textbox4.AppendText("`nIntunewin file created: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$newpackage_outputpath\$powershellpnaam.intunewin")
	$updatepackage_exe_output_textbox4.AppendText("`r`n")
	
	$updatepackage_exe_output_textbox4.AppendText("Install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("un-install command is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection registry is: `r`n")
	$updatepackage_exe_output_textbox4.AppendText("$reglocation `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Method is: 'String Comparison' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: 'Versie' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Operator is: 'Equals' `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Detection Value is: $AppVersion `r`n")
	$updatepackage_exe_output_textbox4.AppendText("Please reopen tool to make another Powershell package `r`n")
}


$tools_choco_search_button2_Click={
	#TODO: Place custom script here
	
	
	function chocoSearch
	{
		param (
			[Parameter(Mandatory = $true)]
			[string]$name,
			[bool]$approvedOnly = $false
		)
		
		$chocoSearch = choco find $name --order-by-popularity
		if ($chocoSearch.Count -gt 2)
		{
			$chocoSearch = $chocoSearch[1 .. ($chocoSearch.Count - 2)]
		}
		
		$results = @()
		
		foreach ($ch in $chocoSearch)
		{
			$splitLine = $ch.Split(" ", 3, [System.StringSplitOptions]::RemoveEmptyEntries)
			if ($splitLine.Count -lt 2)
			{
				continue
			}
			
			$currentName = $splitLine[0]
			$currentVersion = $splitLine[1]
			$remaining = ""
			if ($splitLine.Count -eq 3)
			{
				$remaining = $splitLine[2]
			}
			if ($ch -match 'found|know|Learn')
			{
				continue
			}
			$isApproved = ($remaining -match '\[Approved\]')
			if ($approvedOnly -and -not $isApproved)
			{
				continue
			}
			$obj = [pscustomobject]@{
				Name	 = $currentName
				Version  = $currentVersion
				Approved = $isApproved
			}
			
			$results += $obj
		}
		
		return $results
	}
	$sChoco = $tools_choco_search_textbox3.Text
	
	
	if ($tools_choco_checkbox1.Checked -eq $true)
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $true
	}
	else
	{
		$chocoOutput = chocoSearch -name $sChoco -approvedOnly $false
	}
	try
	{
		New-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'chocoOutput2' -Value $chocoOutput -Scope Script
	}
	

	$tools_choco_treeview2.BeginUpdate()
	$tools_choco_treeview2.Refresh()
	$tools_choco_treeview2.Nodes.Clear()
	#$tools_choco_treeview2.CheckBoxes = $true
	$Root = $tools_choco_treeview2.Nodes.Add("Choco Packages")
	foreach ($p in $chocoOutput)
	{
		#$upload_treeview2.Nodes.Add($tenantCSV.customername)
		$node = $Root.Nodes.Add($p.Name)
		
		$node.ContextMenuStrip = $tools_choco_contextmenustrip1
		#$node.Tag = $tenantCSV.target
		$node.Name = $p.Name
		
		
	}
	$Root.Expand()
	$tools_choco_treeview2.EndUpdate()
}

$config_tenants_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}



$tools_choco_contextmenustrip1_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_contextmenustrip1_Opening=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$choco_toolstripmenuitem1_Click= {
	#TODO: Place custom script here
	

}
$tools_choco_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	
}

$tools_choco_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$chocoAll = Get-Variable -Name 'chocoOutput2' -Scope Script -ValueOnly
	$tools_choco_details_richtextbox1.text = ""
	
	foreach ($ch1 in $chocoAll)
	{
		if ($ch1.Name -eq $tools_choco_treeview2.SelectedNode.Name)
		{
			$tools_choco_panel6.Enabled = $true
			$tools_choco_selected_label6.Enabled = $true
			$tools_choco_selected_label6.Visible = $true
			$tools_choco_selected_label6.Text = $ch1.Name
			$chocoDetails = choco find $ch1.Name --exact --detail
			foreach ($ch2 in $chocoDetails)
			{
				$tools_choco_details_richtextbox1.AppendText("`r`n")
				$tools_choco_details_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}



$tools_choco_createdir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$fid = $config_packagefolder; $outputDirectory = $fid
	
	$exepnaam = $tools_choco_displayname_textbox3.text
	$exeversie = $tools_choco_appversion_textbox3.text
	$exepnaam = $exepnaam -replace (" ", "")
	$tools_choco_displayname_textbox3.text = $exepnaam
	if ($exepnaam -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Name textbox', 'Please choose Package Name first')
	}
	else
	{
		if ($exeversie -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package Version textbox', 'Please choose Package Version first')
		}
		else
		{
			
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\source"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\source"
			}
			if (!(Test-Path -Path "$outputDirectory\$exepnaam\$exeversie\output"))
			{
				
				New-Item -ItemType Directory -Path "$outputDirectory\$exepnaam\$exeversie\output"
			}
			$tools_choco_output_textbox3.Text = "`nNew package directory created: `r`n"
			$tools_choco_output_textbox3.AppendText("$outputDirectory\$exepnaam\$exeversie\source")
			$tools_choco_output_textbox3.AppendText("`r`n")
			$tools_choco_panel7.Enabled = $true
			$tools_choco_open_PackageDir_button2.Enabled = $true
			$tools_choco_buttonOpenPackageDirectory.Enabled = $true
			$tools_choco_buttonOpenPackageDirectory.Visible = $true
		}
	}
}
$tools_choco_displayname_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_appversion_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$tools_choco_createscriots_button2_Click={
	#TODO: Place custom script here
	$choco_installFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:19
	 Created by:   	Rink Turksma
	 Organization: 	https://githhub.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"
$paramsChoco = "!!paramsChocho!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
if (!(test-path -Path "$env:programdata\chocolatey"))
	{
		write-host "Installing Chocolatey"
		[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
	}


write-host "Now installing: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green
try
{
	write-host "Choco installation started" -ForegroundColor Green
	if ($paramsChoco -eq 'false')
	{
		choco install $chocoName --exact --yes --force
	}
	else
	{
		choco install $chocoName --exact --params $paramsChoco --yes --force
	}
	write-host "Installation success" -ForegroundColor Green
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	write-host "Now creating weekly scheduled task to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -Weekly -DaysOfWeek Monday -At 10:00
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}

if ($startupUpdateTask -eq 'true')
{
	write-host "Now creating scheduled task at startup to update this application" -ForegroundColor Green
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	$trigger1 = New-ScheduledTaskTrigger -AtStartup
	$principal = New-ScheduledTaskPrincipal -UserID "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries -StartWhenAvailable
	$action = New-ScheduledTaskAction -Execute "C:\ProgramData\chocolatey\choco.exe" -Argument "upgrade $appname -y"
	try
	{
		Register-ScheduledTask -Action $action -Trigger $trigger1 -Principal $principal -TaskName $taskName -Settings $settings -Description $taskName -Force -ErrorAction Stop
		write-host "Scheduled Task created for $appname" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task creation failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}


try
{
	#Searches for startmenu items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a startmenu *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files in startmenu" -ForegroundColor Yellow
	
}
try
{
	#Searches for Desktop items created the last 10 minutes
	$startmenuItems = (Get-ChildItem "C:\Users\Public\Desktop" -Recurse -include *.lnk | Sort-Object LastWriteTime -ErrorAction Stop | where { $_.LastWriteTime -ge (get-date).AddMinutes(-10) }).VersionInfo.FileName
	foreach ($startmenuI in $startMenuItems)
	{
		write-host "`r`n"
		write-host "The last 10 minutes a Desktop *.lnk file was created." -ForegroundColor Yellow
		write-host "To remove this item in this package please add the following to your install.ps1 under the comment 'Place extra actions here:'" -ForegroundColor Yellow
		write-host "remove-item `"$startmenuI`" -confirm:`$false"` -ForegroundColor Green
		write-host "`r`n"
		
	}
}
catch
{
	write-host "Error looking for *.lnk files on the Desktop" -ForegroundColor Yellow
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\i.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}

### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000) + "`n`n MSIEXEC log complete: $logfileMSI"
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	fDetectionInRegistry -succes $true
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }

'@
	$choco_uninstallFile = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2024 v5.8.251
	 Created on:   	23-12-2024 13:25
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$appName = "!!AppName!!"
$version = "!!version!!"
$chocoName = "!!chocoName!!"
$installChoco = "!!installChoco!!"
$WeeklyUpdateTask = "!!weeklyUpdateTask!!"
$startupUpdateTask = "!!startupUpdateTask!!"

#Customer variables.
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "$appName$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 
	#### HKEY_LOCAL_MACHINE\SOFTWARE\Intune_Customer\Test
	### With Versie value en een [BOOL]Succes waarde
	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Versie -ErrorAction Stop
		if ($AppRegVersie.Versie -ne $versie) { set-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Versie -Value $Versie -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot
#Copies IntunePrepTool_msgfile.dll For custom eventLog
if (!(Test-Path -Path "$logdir\dll\IntunePrepTool_msgfile.dll" -PathType Leaf))
{
	copy-item "IntunePrepTool_msgfile.dll" -Destination "$logdir\dll\IntunePrepTool_msgfile.dll" -Confirm:$false
}
## Creates Registry IntunePrepTool for MSG file
if (Get-ChildItem -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" | Select Name | where { $_.Name -eq "IntunePrepTool" } -eq $null)
{
	New-Item -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\" -Name "IntunePrepTool" -ErrorAction SilentlyContinue
}
try
{
	
	$TypesSupported = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -ErrorAction Stop
	if ($TypesSupportede.TypesSupported -ne "7") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name TypesSupported -Value "7" -PropertyType DWORD
}
try
{
	
	$EventMessageFile = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -ErrorAction Stop
	if ($EventMessageFile.EventMessageFile -ne "$logdir\dll\IntunePrepTool_msgfile.dll") { set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" }
	
}
catch
{
	new-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\IntunePrepTool" -Name EventMessageFile -Value "$logdir\dll\IntunePrepTool_msgfile.dll" -PropertyType string
}
#New EventLog when needed.
try
{
	$checkEventLog = Get-EventLog -LogName "IntunePrepTool" -Source "IntunePrepTool" -ErrorAction Stop
}
catch
{
	New-EventLog -MessageResourceFile "$logdir\dll\IntunePrepTool_msgfile.dll" -LogName "IntunePrepTool" -Source "IntunePrepTool"
	[System.Diagnostics.EventLog]::CreateEventSource("IntunePrepTool", "IntunePrepTool")
}
#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
get-date
write-host "Now uninstalling: $appName " -ForegroundColor Green
write-host "With version: $version" -ForegroundColor Green
write-host "Choconame: $chocoName" -ForegroundColor Green
if ($installChoco -eq 'true') { write-host "Option selected to automatically install Choco when needed." -ForegroundColor Green }
else { write-host "No automatic Choco installation was selected. Please ensure the Choco dependency is properly set up in your Intune configuration." -ForegroundColor Green }
if ($WeeklyUpdateTask -eq 'true') { write-host "A weekly update task will be created for this application." -ForegroundColor Green }
else { write-host "No weekly update task will be created for this application." -ForegroundColor Green }
if ($startupUpdateTask -eq 'true') { write-host "A startup update task will be created for this application." -ForegroundColor Green }
else { write-host "No startup update task will be created for this application." -ForegroundColor Green }
write-host "Transcript log created: $logfile" -ForegroundColor Green




try
{
	write-host "Choco uninstallation started" -ForegroundColor Green
	choco uninstall $chocoName --exact --yes --force
	write-host "UnInstallation success" -ForegroundColor Green
}
catch
{
	Write-Host "Uninstallation failed" -ForegroundColor Red -BackgroundColor Blue
	Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}
if ($WeeklyUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "Choco Weekly update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
}
if ($startupUpdateTask -eq 'true')
{
	$appName = $chocoName
	$taskName = "CHoco Startup update task for $appname"
	try
	{
		Unregister-ScheduledTask -TaskName $taskName -Confirm:$false -ErrorAction Stop
		write-host "scheduled task unregister complete" -ForegroundColor Green
	}
	catch
	{
		Write-Host "Scheduled task unregister failed" -ForegroundColor Red -BackgroundColor Blue
		Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	}
	
	
}
if (Test-Path 'BuildingBlocks\System') {
    $originalLocation = Get-Location
    Write-Host "BuildBlocks folder detected"

    $allBuildingBlocks = Get-ChildItem 'BuildingBlocks\System'
    foreach ($bb in $allBuildingBlocks) {
        $bbScriptLocation = 'BuildingBlocks\System\' + $bb.Name + "\u.ps1"

        if (Test-Path $bbScriptLocation -PathType Leaf) {
            Write-Host "Now running Building Blocks Script $bbScriptLocation"
            & $bbScriptLocation
            Set-Location $originalLocation
        }
    }
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
$split = [regex]::Escape("**********************")
$lastRun = ((Get-Content $logfile -Raw) -split ($split))[-3]
if ($lastRun.Length -gt 30000)
{
	$lastRun = $lastRun.Substring(0, 30000)
}

if ($excode -eq 1)
{
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Error", 0x3)
}
else
{
	remove-item $regkeyApp
	[System.Diagnostics.EventLog]::WriteEntry("IntunePrepTool", $lastRun, "Information", 0x3)
}

#Copy IntunePrepTool.evtx to IntuneManagementExtension\Logs
if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs")
{
	if (test-path "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -PathType Leaf) { remove-item "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Confirm:$false }
	copy-item "c:\windows\System32\Winevt\Logs\IntunePrepTool.evtx" "C:\ProgramData\Microsoft\IntuneManagementExtension\Logs\IntunePrepTool.evtx" -Force -Confirm:$false
}
if ($excode -eq 1) { exit 1 }
else { exit 0 }
'@
	
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$RegisterDetectionroot = "Intune_" + $config_customername
	$appVersion = $tools_choco_appversion_textbox3.text
	$appName = '"' + $tools_choco_displayname_textbox3.text + '"'
	$appName2 = $tools_choco_displayname_textbox3.text
	$chocoName = $tools_choco_selected_label6.Text
	
	$choco_installFile  = $choco_installFile.Replace('"!!AppName!!"', $appName)
	$choco_installFile  = $choco_installFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_installFile  = $choco_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_installFile  = $choco_installFile.Replace('!!version!!', $appVersion)
	$choco_installFile = $choco_installFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true' 
	$choco_installFile = $choco_installFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_installFile = $choco_installFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true) { $paramschoco = $tools_choco_parammstextbox3.Text; $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', $paramschoco) }
	else { $choco_installFile = $choco_installFile.Replace('!!paramsChocho!!', 'false') }
	try
	{
		$choco_installFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\install.ps1" -Force -ErrorAction Stop
		copy-item "IntunePrepTool_msgfile.dll" -Destination "$config_packagefolder\$appName2\$appVersion\source\IntunePrepTool_msgfile.dll" -Confirm:$false
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nInstall.ps1 NOT created `r`n")
	}
	$choco_uninstallFile = $choco_uninstallFile.Replace('"!!AppName!!"', $appName)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!version!!', $appVersion)
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!chocoName!!', $chocoName)
	$installchoco = 'true'
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!installChoco!!', $installchoco)
	if ($tools_choco_addUpdatetask_checkbox1.Checked -eq $true) { $weeklyUpdate = 'true' }
	else { $weeklyUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!weeklyUpdateTask!!', $weeklyUpdate)
	if ($tools_choco_addUpdatetask_checkbox2.Checked -eq $true) { $startUoUpdate = 'true' }
	else { $startUoUpdate = 'false' }
	$choco_uninstallFile = $choco_uninstallFile.Replace('!!startupUpdateTask!!', $startUoUpdate)
	try
	{
		$choco_uninstallFile | Out-File "$config_packagefolder\$appName2\$appVersion\source\uninstall.ps1" -Force -ErrorAction Stop
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 created `r`n")
		$tools_choco_test_panel.Enabled = $true
		$tools_choco_panel11.Enabled = $true
	}
	catch
	{
		$tools_choco_output_textbox3.AppendText("`nUnInstall.ps1 NOT created `r`n")
	}
}

$tools_choco_open_PackageDir_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$AppVersion = $tools_choco_appversion_textbox3.text
	Invoke-Item "$config_packagefolder\$appName\$appVersion\"
}

$tools_choco_testinstall_button2_Click={
	#TODO: Place custom script here
	if ([System.Windows.Forms.MessageBox]::Show('Do you want to test?... ', 'Test', [System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$appName = $tools_choco_displayname_textbox3.text
		$appVersion = $tools_choco_appversion_textbox3.text
		powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\install.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$tools_choco_testUNinstall_button2_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	powershell_ise -file "$config_packagefolder\$appName\$appVersion\source\uninstall.ps1"
	Start-Sleep 1
	PowershellISEOnTop
	$tools_choco_addBuildingBlocksCSVButton.Enabled = $true
}

$config_download_Choco_MSIX_bundle_Click={
	#TODO: Place custom script here
	
	$config_install_required_chocolatey = @'
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installChocolatey.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey| Out-File "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installChocolatey.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$picturebox1_Click={
	#TODO: Place custom script here
	
}

$tools_choco_AddParams_checkbox1_CheckedChanged={
	#TODO: Place custom script here
	if ($tools_choco_AddParams_checkbox1.Checked -eq $true)
	{
		$tools_choco_parammstextbox3.Enabled = $true
		$tools_choco_parammstextbox3.Visible = $true
	}
	else
	{
		$tools_choco_parammstextbox3.Enabled = $false
		$tools_choco_parammstextbox3.Visible = $false
	}
}

$tools_choco_create_intunewin_button2_Click={
	#TODO: Place custom script here
	Set-Location $PSScriptRoot
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('The IntunePrepTool will not respond until packaging is ready. When creating large packages. Please wait', 'Press ok to continue') # Casting the method to [void] suppresses the output. 
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$appName = $tools_choco_displayname_textbox3.text
	$appVersion = $tools_choco_appversion_textbox3.text
	$RegisterDetectionroot = "Intune_" + $config_customername
	& .\IntuneWinAppUtil.exe -c "$config_packagefolder\$appName\$appVersion\source\" -s "$config_packagefolder\$appName\$appVersion\source\install.ps1" -o "$config_packagefolder\$appName\$appVersion\output\" -q
	Rename-Item -Path "$config_packagefolder\$appName\$appVersion\output\install.intunewin" -NewName "$config_packagefolder\$appName\$appVersion\output\$appName.intunewin"
	$tools_choco_output_textbox3.AppendText("`nIntunewin file created: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\$appName.intunewin")
	$tools_choco_output_textbox3.AppendText("`r`n")
	
	$tools_choco_output_textbox3.AppendText("Install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file install.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("un-install command is: `r`n")
	$tools_choco_output_textbox3.AppendText("powershell -executionpolicy bypass -file uninstall.ps1 `r`n")
	$tools_choco_output_textbox3.AppendText("Detection in registry is: `r`n")
	$regkeyRoot = "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\$RegisterDetectionroot\"
	$regkeyApp = "$regkeyRoot$appName\"
	$regkeyApp
	$tools_choco_output_textbox3.AppendText("$regkeyApp `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Method is: 'String Comparison' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: 'Version' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Operator is: 'Equals' `r`n")
	$tools_choco_output_textbox3.AppendText("Detection Value is: $appVersion `r`n")
	$tools_choco_output_textbox3.AppendText("Please reopen tool to make another Chocolatey package `r`n")
	
	class IntuneWinPackageConfig {
		[string]$IntuneWinFile
		[string]$DisplayName
		[string]$Publisher
		[string]$AppVersion
		[string]$reglocation
		[string]$regValue
		[string]$installCMD
		[string]$uninstallCMD
	}
	$IntuneWinPackageConfig = $null;
	$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
			IntuneWinFile = "$appName.intunewin"
			DisplayName   = $appName
			Publisher	  = $config_customername
			AppVersion    = $appVersion;
			reglocation   = $regkeyApp
			regValue	  = 'Version'
			installCMD    = "powershell -executionpolicy bypass -file install.ps1"
			uninstallCMD  = "powershell -executionpolicy bypass -file uninstall.ps1"
		})
	
	$IntuneWinPackageConfig | Export-Csv "$config_packagefolder\$appName\$appVersion\output\config.csv" -NoTypeInformation
	$config_csv_openfiledialog1.InitialDirectory = "$config_packagefolder\$appName\$appVersion\output\"
	$tools_choco_output_textbox3.AppendText("Config.csv written to naar: `r`n")
	$tools_choco_output_textbox3.AppendText("$config_packagefolder\$appName\$appVersion\output\config.csv")
	$tools_choco_output_textbox3.AppendText("  `r`n")
	$buildingBlokcsCSV = $choco_buildingBlocksCSVtextbox3.Text
	if ($buildingBlokcsCSV -notlike $null)
	{
		$buildingBlocksCSVImport = Import-Csv $buildingBlokcsCSV
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		if ($buildingBlocksCSVImport.usercontext -like 'true')
		{
			$usercontext = $true
		}
		else
		{
			$usercontext = $false
		}
		$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
				packageinprogress		     = $buildingBlocksCSVImport.packageinprogress
				systemcontext			     = $buildingBlocksCSVImport.systemcontext
				usercontext				     = $usercontext
				systemcontextconfig		     = "$config_packagefolder\$appName\$appVersion\output\config.csv";
				systembuildingblockslocation = $buildingBlocksCSVImport.systembuildingblockslocation
				usercontextconfig		     = $buildingBlocksCSVImport.usercontextconfig
				userbuildingblockslocation   = $buildingBlocksCSVImport.userbuildingblockslocation
			})
		$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appName\BuildingBlocks.csv" -force -NoTypeInformation
		$tools_choco_output_textbox3.AppendText("New BuildingBlocks.csv written to: `r`n")
		$tools_choco_output_textbox3.AppendText("$config_buildingblockspath\$appName\BuildingBlocks.csv `r`n")
		$tools_choco_output_textbox3.AppendText("Please go to the upload menu and upload by selecting the BuildingBlocks.csv")
		$tools_choco_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
		
	}
	else
	{
		$tools_choco_output_textbox3.AppendText("Use the config.csv file on the Upload tab to upload the package to Intune.`r`n")
		$tools_choco_output_textbox3.AppendText("Before continuing, you can upload a logo for the Company Portal using the Upload Logo button and selecting a PNG, JPG/JPEG, or WEBP file.`r`n")
	}
	
	
}

$tools_choco__upload_logo_button2_Click={
	#TODO: Place custom script here
	[string]$logo_org_path = $UploadLogo_openfiledialog1.FileNames
	$msipnaam = $tools_choco_displayname_textbox3.text
	$msiversie = $tools_choco_appversion_textbox3.text
	$outputDirectory = $config_packagefolder_textbox.text
	$outputDirectory = $outputDirectory + "\$msipnaam" + "\$msiversie" + '\output\'
	$outputDirectory = $outputDirectory -replace ("\\", "\")
	$dlg = $upload_logo_openfiledialog1.ShowDialog()
	if ($dlg -ne [System.Windows.Forms.DialogResult]::OK) { return }
	[string]$logoPath = $upload_logo_openfiledialog1.FileName
	if (-not (Test-Path -LiteralPath $logoPath)) { [void][System.Windows.Forms.MessageBox]::Show('Logo file not found.'); return }
	$destPng = Join-Path $outputDirectory 'logo.png'
	# Size check (≤ 1 MB)
	$fi = Get-Item -LiteralPath $logoPath
	if ($fi.Length -gt 1MB)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please select a PNG or WEBP smaller than 1 MB', 'File too large')
		return
	}
	$ext = [System.IO.Path]::GetExtension($logoPath).ToLowerInvariant()
	
	switch ($ext)
	{
		'.webp' {
			$dwebp = 'C:\Program Files\IntunePrepTool\libwebp\libwebp-1.6.0-windows-x64\bin\dwebp.exe'
			if (-not (Test-Path -LiteralPath $dwebp)) { $dwebp = 'C:\Program Files\IntunePrepTool\dwebp.exe' }
			
			if (-not (Test-Path -LiteralPath $dwebp))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion tool not found.`r`nClick the 'Install libwebp Image converter (Powershell_ISE)' Button in the Start / Config menu", 'Missing dwebp.exe')
				return
			}
			
			
			$out = & $dwebp "`"$logoPath`"" -o "`"$destPng`"" 2>&1
			if ($LASTEXITCODE -ne 0 -or -not (Test-Path -LiteralPath $destPng))
			{
				[void][System.Windows.Forms.MessageBox]::Show("WEBP conversion failed:`r`n$($out | Out-String)", 'Error')
				return
			}
		}
		'.png' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		'.jpeg' {
			Copy-Item -LiteralPath $logoPath -Destination $destPng -Force
		}
		default {
			[void][System.Windows.Forms.MessageBox]::Show('Unsupported type. Please select a PNG, JPG / JPEG or WEBP file.', 'Invalid file')
			return
		}
	}
	
	[void][System.Windows.Forms.MessageBox]::Show("Logo saved to:`r`n$destPng", 'Success')
	
	$tools_choco_output_textbox3.AppendText("`r`n")
	$tools_choco_output_textbox3.AppendText("Logo.PNG now available in Output Directory`r`n")
}

$winget_search_button2_Click={
	$downloadWingetSearchText = $winget_search_textbox3.Text
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$downloadwingetsearch = winget search --name $downloadWingetSearchText --accept-source-agreements
	$winget_output_textbox3.Text = $null
	$table_download_winget = New-Object System.Data.DataTable;
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "ID";
	$table_download_winget.Columns.Add($column_download_winget);
	$column_download_winget = New-Object System.Data.DataColumn;
	$column_download_winget.DataType = [System.Type]::GetType("System.String");
	$column_download_winget.ColumnName = "Name";
	$table_download_winget.Columns.Add($column_download_winget);
	
	$winget_search_treeview2.BeginUpdate()
	$winget_search_treeview2.Refresh()
	$winget_search_treeview2.Nodes.Clear()
	$Root = $winget_search_treeview2.Nodes.Add("Winget Packages")
	$wingetOutp1 = @()
	
	foreach ($wsearch_l in $downloadwingetsearch)
	{
		
		if ($wsearch_l -like "Name*")
		{
			$wsearch_IdStart = $wsearch_l.IndexOf("Id")
			$wsearch_VersionStart = $wsearch_l.IndexOf("Version")
			$wsearch_MatchStart = $wsearch_l.IndexOf("Match")
			$wsearch_SourceStart = $wsearch_l.IndexOf("Source")
			
		}
		
		if (($wsearch_l -notlike "Name*") -and ($wsearch_l -notlike "---*") -and ($wsearch_l -notlike "   -*"))
		{
			
			$row_download_winget = $table_download_winget.NewRow();
			$download_winget_extraStrip = $wsearch_l.substring(0, $wsearch_IdStart)
			$download_winget_extraStrip = $download_winget_extraStrip.TrimEnd()
			$row_download_winget["Name"] = $download_winget_extraStrip
			$split = $wsearch_VersionStart - $wsearch_IdStart
			$row_download_winget["ID"] = $wsearch_l.substring($wsearch_IdStart, $split).Split('', [System.StringSplitOptions]::RemoveEmptyEntries) -join ''
			
			if ($row_download_winget["ID"] -notlike $null)
			{
				$download_winget_listboxInput = $row_download_winget | Select Name, ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$wingetOutp2 = $row_download_winget | Select ID | ConvertTo-Csv -NoTypeInformation | select -skip 1
				$wingetOutp1 += [PSCustomObject]@{ ID = $wingetOutp2 }
				$node = $Root.Nodes.Add($download_winget_listboxInput)
				$node.Name = $wingetOutp2
			}
			$table_download_winget.AcceptChanges();	
			
		}
		
	}
	$Root.Expand()
	$winget_search_treeview2.EndUpdate()
	try
	{
		New-Variable -Name 'wingetOutput' -Value $wingetOutp1 -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'wingetOutput' -Value $wingetOutp1 -Scope Script
	}
	
	
}

$winget_search_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$wingetAll = Get-Variable -Name 'wingetOutput' -Scope Script -ValueOnly
	$winget_show_info_richtextbox1.text = $null;
	foreach ($ch1 in $wingetAll.ID)
	{
		if ($ch1 -eq $winget_search_treeview2.SelectedNode.Name)
		{
			#$tools_choco_panel6.Enabled = $true
			#$tools_choco_selected_label6.Enabled = $true
			#$tools_choco_selected_label6.Visible = $true
			#$tools_choco_selected_label6.Text = $ch1.Name
			#$winget_settings_panel7.Enabled = $true;
			$winget_selected_panel7.Enabled = $true
			$winget_createPackageDIR_panel7.Enabled = $true
			$wingetDetails = winget show --id $ch1
			$ch1 = $ch1.Replace('"','')
			$winget_WingetID_textbox1.Text = $ch1
			foreach ($ch2 in $wingetDetails)
			{
				$winget_show_info_richtextbox1.AppendText("`r`n")
				$winget_show_info_richtextbox1.AppendText($ch2)
				
			}
			
		}
		
	}
}

$winget_CreatePackageDir_button2_Click= {
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$winget_displayname_textbox1.text = $DisplayName
	if ($DisplayName -like $null)
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package name textbox', 'Please choose Package name first')
	}
	else
	{
		$version = $versie_textbox2.Text
		if ($version -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please fill the Package version textbox', 'Please choose Package version first')
		}
		else
		{
		
			if (!(Test-Path -Path "$config_packagefolder\$DisplayName\$version\source"))
			{
				
				New-Item -ItemType Directory -Path "$config_packagefolder\$DisplayName\$version\source"
			}
			if (!(Test-Path -Path "$config_packagefoldery\$DisplayName\$version\output"))
			{
				
				New-Item -ItemType Directory -Path "$config_packagefolder\$DisplayName\$version\output"
			}
			$winget_open_package_dir_button3.Enabled = $true
			$winget_settings_panel7.Enabled = $true
			$winget_buttonAddCustomDescription.Enabled = $true
			$winget_buttonAddCustomDescription.Visible = $true
			
		}
	}
}
$winget_open_package_dir_button3_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$DisplayName = $winget_displayname_textbox1.text
	$DisplayName = $DisplayName -replace (" ", "")
	$version = $versie_textbox2.Text
	Invoke-Item "$config_packagefolder\$DisplayName\$version"
}

$checkbox1_CheckedChanged={
	#TODO: Place custom script here
	
}

$radiobutton64Bit_CheckedChanged={
	#TODO: Place custom script here
	
}

$config_version_label1_Click={
	#TODO: Place custom script here
	
}

$config_install_sandbox_buttonInstallSanboxPowersh_Click={
	#TODO: Place custom script here
	$config_install_required_chocolatey = @'
Enable-WindowsOptionalFeature -FeatureName "Containers-DisposableClientVM" -All -Online
'@
	
	
	if (!(Test-Path "C:\Program Files\IntunePrepTool\" -PathType Container))
	{
		[void][System.Windows.Forms.MessageBox]::Show('Please use winget to install IntunePrepTool: "winget install rink-turksma.IntunePrepTool" or use MSI file from Github (Releases) ', 'IntunePrep Tool install location not found')
	}
	else
	{
		if (!(Test-Path "C:\Program Files\IntunePrepTool\installSandbox.ps1" -PathType Leaf))
		{
			$config_install_required_chocolatey | Out-File "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		}
		else
		{
			Remove-Item -Path "C:\Program Files\IntunePrepTool\installSandbox.ps1" -Confirm:$false -Force
			$config_install_required_chocolatey | Out-File "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		}
		
		powershell_ise -file "C:\Program Files\IntunePrepTool\installSandbox.ps1"
		Start-Sleep 1
		PowershellISEOnTop
	}
}

$config_add_Tenant_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}



$registryToolStripMenuItem_Click={
	#TODO: Place custom script here
	
}


$capture_registry_loadTreeview_button2_Click={
	#TODO: Place custom script here

		

	
	
}

$Registry_capture_panel7_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$capture_registry_treeview2_NodeMouseClick=[System.Windows.Forms.TreeNodeMouseClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeNodeMouseClickEventArgs]
	#TODO: Place custom script here
	#Source https://www.sapien.com/forums/viewtopic.php?t=11679
	if ($_.Node.Nodes.Count -eq 0)
	{
		foreach ($keyName in ($_.Node.Tag.GetSubkeyNames()))
		{
			Try
			{
				$regKey = $_.Node.Tag.OpenSubKey($keyName)
				$n = New-Object System.Windows.Forms.TreeNode
				$n.Name = $regKey.PsPath
				$n.Text = $keyName
				$n.Tag = $regKey
				$_.Node.Nodes.Add($n)
			}
			Catch
			{
				Write-Host $_
			}
		}
	}

}

$registry_capture_tabpage5_Click={
	#TODO: Place custom script here
	
}

$Registry_Capture_Step2_CreateBackup_button2_Click = {
	if ($registry_name_textbox3.Text -notlike $null)
	{
		
		$node = $capture_registry_treeview2.SelectedNode
		$nodeTexts = @()
		while ($node)
		{
			$nodeTexts += $node.Text
			$node = $node.Parent
		}
		$reversedNodeTexts = @()
		for ($i = $nodeTexts.Count - 1; $i -ge 0; $i--)
		{
			$reversedNodeTexts += $nodeTexts[$i]
		}
		$rootHive = ""
		$allNodesString = $rootHive + ($reversedNodeTexts -join "\")
		
		$RegistryCaptureScript = @'
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	22-3-2025 20:35
	 Created by:   	Rink Turksma
	 Organization: 	
	 Filename:     	regcompare.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>
$regexportpath = "!!regexportpath!!"
$backupFolder = "!!backupFolder!!"
if (!(Test-Path $backupFolder))
{
	New-Item -Path $backupFolder -ItemType Directory | Out-Null
}
$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$preBackupPath = Join-Path $backupFolder "PreChanges_$timeStamp.reg"
$postBackupPath = Join-Path $backupFolder "PostChanges_$timeStamp.reg"
$DiffRegName = "!!DiffRegName!!"
$diffPath = Join-Path $backupFolder "$DiffRegName`_$timeStamp.reg"

Write-Host "Exporting registry from: $regExportPath"  
Write-Host "Creating first registry backup (pre-changes)..."  
reg export "$regExportPath" "$preBackupPath" /y | Out-Null
Write-Host "  Pre-changes backup saved to: $preBackupPath`n"
Write-Host "Make any desired changes to your registry/application now." -ForegroundColor Green
Write-Host "Press ENTER when finished..." -ForegroundColor Green
Read-Host
Write-Host "`nCreating second registry backup (post-changes)..."  
reg export "$regExportPath" "$postBackupPath" /y | Out-Null
Write-Host "  Post-changes backup saved to: $postBackupPath`n"  
Write-Host "Now comparing backups to find differences..."  

function Compare-RegFiles
{
	param (
		[string]$OldRegPath,
		[string]$NewRegPath,
		[string]$DiffOutPath
	)
	
	$oldLines = [System.IO.File]::ReadAllLines($OldRegPath)
	$newLines = [System.IO.File]::ReadAllLines($NewRegPath)
	$oldHashSet = [System.Collections.Generic.HashSet[string]]::new($oldLines)
	$differences = New-Object System.Collections.Specialized.OrderedDictionary
	$currentKey = $null
	foreach ($line in $newLines)
	{
		if ($line -match '^\[\S+\]$')
		{
			$currentKey = $line
			continue
		}
		if ($line -match '^\S+=' -and $currentKey)
		{
			if (-not $oldHashSet.Contains($line))
			{
				if (-not $differences.Contains($currentKey))
				{
					$differences[$currentKey] = [System.Collections.Generic.List[string]]::new()
				}
				$differences[$currentKey].Add($line)
			}
		}
	}
	if ($differences.Count -gt 0)
	{
		Set-Content -Path $DiffOutPath -Value "Windows Registry Editor Version 5.00`r`n"
		foreach ($key in $differences.Keys)
		{
			Add-Content -Path $DiffOutPath -Value "`r`n$key"
			foreach ($val in $differences[$key])
			{
				Add-Content -Path $DiffOutPath -Value $val
			}
		}
		Write-Host "Differences found! Saved to: $DiffOutPath" -ForegroundColor Green
		$DiffOutPath | out-file "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt" -force
	}
	else
	{
		Write-Host "No differences detected."  
		if (Test-Path $DiffOutPath)
		{
			Remove-Item $DiffOutPath -ErrorAction SilentlyContinue
		}
	}
}

Compare-RegFiles -OldRegPath $preBackupPath `
				 -NewRegPath $postBackupPath `
				 -DiffOutPath $diffPath


Write-Host "`nRemoving the two backup files..."  
Remove-Item -Path $preBackupPath -ErrorAction SilentlyContinue
Remove-Item -Path $postBackupPath -ErrorAction SilentlyContinue

Write-Host "`nAll done. Please close this Powershell_ISE window and continue in the IntunePrepTool"


'@
		if (Get-Process -Name "powershell_ise" -ErrorAction SilentlyContinue)
		{
			[void][System.Windows.Forms.MessageBox]::Show('Please close any existing Powershell_ISE windows, When done.. Start again', 'Please close existing Powershell_ISE windows')
		}
		else
		{
			
			if ($registry_name_textbox3.text -like $null)
			{
				[void][System.Windows.Forms.MessageBox]::Show('Please select Name first, When done.. Start again', 'Please select Name first')
			}
			else
			{
				if ($Registry_HKLM_radiobutton1.Checked -eq $true)
				{
					$regName = "HKLM_"
				}
				if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
				{
					$regName = "HKCU_"
				}
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!regexportpath!!", $allNodesString)
				$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
				$BackupLocation = $config_packagefolder + '\' + "0_BuildingBlocks\Registry"
				$BackupLocation = $BackupLocation -replace ("\\", "\")
				$regName2 = $regName + $registry_name_textbox3.text
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!DiffRegName!!", $regName2)
				
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!backupFolder!!", $BackupLocation)
				$RegistryCaptureScript = $RegistryCaptureScript -replace ("!!DiffRegName!!", $regName2)
				
				
				
				if (!(Test-Path "C:\Program Files\IntunePrepTool\regcompare.ps1" -PathType Leaf))
				{
					$RegistryCaptureScript | Out-File "C:\Program Files\IntunePrepTool\regcompare.ps1"
					powershell_ise -file "C:\Program Files\IntunePrepTool\regcompare.ps1"
					Start-Sleep 1
					PowershellISEOnTop
				}
				else
				{
					try
					{
						Remove-Item "C:\Program Files\IntunePrepTool\regcompare.ps1" -Confirm:$false -ErrorAction Stop
						$RegistryCaptureScript | Out-File "C:\Program Files\IntunePrepTool\regcompare.ps1"
						powershell_ise -file "C:\Program Files\IntunePrepTool\regcompare.ps1"
						Start-Sleep 1
						PowershellISEOnTop
					}
					catch
					{
						[void][System.Windows.Forms.MessageBox]::Show('When done.. Start again', 'Please close existing Powershell_ISE windows')
					}
					
					
				}
			}
		}
	}
	else
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Enter name and start again please', 'Please enter Name first')
	}
	
	
	
}



$Registry_load_button2_Click={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		$capture_registry_treeview2.Refresh()
		$capture_registry_treeview2.Nodes.Clear()
		$capture_registry_treeview2.Refresh()
		if ($Registry_HKLM_radiobutton1.Checked -eq $true)
		{
			$regKey = Get-Item HKLM:\ -ErrorAction SilentlyContinue
		}
		if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
		{
			$regKey = Get-Item HKCU:\
		}
		
		$n = New-Object System.Windows.Forms.TreeNode
		$n.Name = $regKey.PsPath
		$n.Text = $regKey.Name
		$n.Tag = $regKey
		$capture_registry_treeview2.Nodes.Add($n)
		
		
	
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$toolstripstatuslabel1.Text = "Selected Customer: $config_customername"
	}
	
}

$registry_capture_label5_Click={
	#TODO: Place custom script here
	
}

$registry_name_textbox3_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
}

$registry_button2_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show('Please remove all irrelevant items and then click Save in Notepad.', 'Edit .reg file in Notepad')
	$regfile = Get-Content "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt"
	notepad $regfile
	
}

$buttonStep6AddBuildingBloc_Click={
	#TODO: Place custom script here
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$BackupLocation = $config_packagefolder + '\' + "1_BuildingBlocksPackages\Registry"
	$BackupLocation = $BackupLocation -replace ("\\", "\")
	$regfile = Get-Content "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt"
	
	if ($Registry_HKLM_radiobutton1.Checked -eq $true)
	{
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	if([System.Windows.Forms.MessageBox]::Show('In this case, a separate package is not needed. You can also add the created .reg file to your existing MSI, MSIX, or EXE package. Do you want to continue creating a separate package?', 'HKLM selected',[System.Windows.Forms.MessageBoxButtons]::YesNo) -eq 'Yes')
	{
			$systemoruser = "system"
			$regName = "HKLM_"
			$registry_output_textbox3.Text = "Creating Building Block Package in the System context"
			$registry_output_textbox3.AppendText("  `r`n")
			$BuildingBlockRegistrySystem = @'
if (Test-Path 'hklm.reg') {
    Write-Host "hklm.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hklm.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}

'@
			$BackupLocation = $BackupLocation + "\system\"
			$regName2 = $regName + $registry_name_textbox3.text
			$BackupLocation = $BackupLocation + $regName2
			if (!(Test-Path $backupLocation))
			{
				New-Item -Path $backupLocation -ItemType Directory -Force | Out-Null
				$registry_output_textbox3.AppendText("$backupLocation created")
				$registry_output_textbox3.AppendText("  `r`n")
			}
			else
			{
				$registry_output_textbox3.AppendText("$backupLocation already exists")
				$registry_output_textbox3.AppendText("  `r`n")
			}
			$BuildingBlockRegistrySystem | Out-File "$BackupLocation\BuildingBlock.ps1"
			$registry_output_textbox3.AppendText("BuildingBlock.ps1 created")
			$registry_output_textbox3.AppendText("  `r`n")
			Copy-Item $regfile "$backupLocation\hklm.reg"
			$registry_output_textbox3.AppendText("hklm.reg created")
			$registry_output_textbox3.AppendText("  `r`n")
			$registry_output_textbox3.AppendText("You can use this Building Block with other Building Blocks by selecting the System Context when creating the Intunewin file using the 'Building Blocks → Intunewin' function.")
			$registry_buidingblocksfiledir_textbox3.Text = $BackupLocation
			
		}
	}
	if ($registry_hkcu_radiobuttonHKCU.Checked -eq $true)
	{
		$systemoruser = "user"
		$regName = "HKCU_"
		$registry_output_textbox3.Text = "Creating Building Block Package in the User context"
		$registry_output_textbox3.AppendText("  `r`n")
		$BuildingBlockRegistryUser = @'
if (Test-Path 'hkcu.reg') {
    Write-Host "hkcu.reg detected.. Now importing" -ForegroundColor Green

    # Run reg import, capturing stdout/stderr in $output
    $output = reg import "hkcu.reg" /reg:64 2>&1

    # reg.exe sets a process exit code. 0 = success
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
'@
		$BackupLocation = $BackupLocation + "\User\"
		$regName2 = $regName + $registry_name_textbox3.text
		$BackupLocation = $BackupLocation + $regName2
		if (!(Test-Path $backupLocation))
		{
			New-Item -Path $backupLocation -ItemType Directory -Force | Out-Null
			$registry_output_textbox3.AppendText("$backupLocation created")
			$registry_output_textbox3.AppendText("  `r`n")
		}
		else
		{
			$registry_output_textbox3.AppendText("$backupLocation already exists")
			$registry_output_textbox3.AppendText("  `r`n")
		}
		$BuildingBlockRegistryUser | Out-File "$BackupLocation\BuildingBlock.ps1"
		$registry_output_textbox3.AppendText("BuildingBlock.ps1 created")
		$registry_output_textbox3.AppendText("  `r`n")
		Copy-Item $regfile "$BackupLocation\hkcu.reg"
		$registry_output_textbox3.AppendText("hkcu.reg created")
		$registry_output_textbox3.AppendText("  `r`n")
		$registry_output_textbox3.AppendText("You can use this Building Block with other Building Blocks by selecting the User Context when creating the Intunewin file using the 'Building Blocks → Intunewin' function.")
		#$registry_buidingblocksfiledir_textbox3.Text = $BackupLocation
		
		
	}
	
	

	
	
	
	
}

$msi_addBuildBlock_regHKLM_Click={
	#TODO: Place custom script here
	<#
	$msi_add_HKLM_openfiledialog1.ShowDialog()
	$msi_reg_hklm_label5.Text = $msi_add_HKLM_openfiledialog1.SafeFileName
	$msi_reg_hklm_label5.Visible = $true
	$msi_reg_hklm_label5.Enabled = $true
	$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
	$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
	$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
	$paname = $msi_packagenaam_textbox1.text
	$paversion = $msi_versie_textbox1.text
	$selectedpadir = "$config_packagefolder\$paname\$paversion\source"
	$msi_output_textbox1.AppendText("`n.reg file will now be copied`r`n")
	[string]$msi_reg_hklm_org_path = $msi_add_HKLM_openfiledialog1.FileNames
	Copy-Item -Path $msi_reg_hklm_org_path -Destination "$selectedpadir\hklm.reg"
	$msi_output_textbox1.AppendText("`n.reg file copy done to HKLM.reg `r`n")
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("There`'s no need to recreate your install.ps1 script when already created. The created install.ps1 already checks for a file named 'hklm.reg' and imports it when available.", 'HKLM.reg file added') # Casting the method to [void] suppresses the output. 
	#>
}

$buttonOptionalOpenRegedit_Click={
	#TODO: Place custom script here
	regedit
}

$capture_registry_treeview2_AfterSelect=[System.Windows.Forms.TreeViewEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.TreeViewEventArgs]
	#TODO: Place custom script here
	$node = $capture_registry_treeview2.SelectedNode
	$nodeTexts = @()
	while ($node)
	{
		$nodeTexts += $node.Text
		$node = $node.Parent
	}
	$reversedNodeTexts = @()
	for ($i = $nodeTexts.Count - 1; $i -ge 0; $i--)
	{
		$reversedNodeTexts += $nodeTexts[$i]
	}
	$rootHive = ""
	$allNodesString = $rootHive + ($reversedNodeTexts -join "\")
	$registry_selected_textbox3.Text = $allNodesString
}

$Registry_OpenBuildingBLockLocationbutton2_Click={
	#TODO: Place custom script here
	explorer $registry_buidingblocksfiledir_textbox3.Text
}

$file_loadFolder_button2_Click={
	#TODO: Place custom script here
	$file_folderbrowsermoderndialog2.ShowDialog()
	$file_selected_source_folder_textbox3.Text = $file_folderbrowsermoderndialog2.SelectedPath
	$file_folder_destination_textbox3.Text = $file_folderbrowsermoderndialog2.SelectedPath
}

$hscrollbar1_Scroll=[System.Windows.Forms.ScrollEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ScrollEventArgs]
	#TODO: Place custom script here
	
}

$addFolderToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-BuildingBlocksFilesAndFolders_psf) -eq 'OK')
	{
		
	}
	
	<#
	$file_folder_panel8.Enabled = $true
	$file_folder_panel8.Visible = $true
	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
#>
	}

$file_folder_cancel_buttonAdd_Click={
	#TODO: Place custom script here
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false

}

$file_folder_add_button2_Click={
	#TODO: Place custom script here
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false
	
	if ($file_folder_skip_checkbox1.Checked -eq $true) {
		$file_folder_SKIP = $true
	}
	if ($file_folder_skip_checkbox1.Checked -eq $FALSE)
	{
		$file_folder_SKIP = $false
	}
	
	if ($file_folder_overwrite_checkbox1.Checked -eq $true)
	{
		$file_folder_overwrite = $true
	}
	if ($file_folder_overwrite_checkbox1.Checked -eq $FALSE)
	{
		$file_folder_overwrite = $false
	}
	
	
	$row = $table.NewRow();
	$row["Sort"] = 'folder';
	$row["Source"] = $file_selected_source_folder_textbox3.text;
	$row["Destination"] = $file_folder_destination_textbox3.Text;
	$row["Skip"] = $file_folder_SKIP;
	$row["Overwrite"] = $file_folder_overwrite;
	$table.Rows.Add($row);
	
	## - Save changes to the table:
	$table.AcceptChanges();
	## - Display custom data created:
	#$files_folders_datagridview1.DataSource = $table;
	
	
}

$config_tenant_info_secret_delete_button2_Click={
	#TODO: Place custom script here
	
	$checkCred = Get-StoredCredential -Target $config_treeview3.SelectedNode.Tag -AsCredentialObject
	$appID = $checkCred.UserName
	$targetName = $checkCred.TargetName
	$customername = $config_treeview3.SelectedNode.Name
	Remove-StoredCredential -Target $targetName
	class config_customerinfo {
		[string]$customername
		[string]$target
	}
	$csvImport = import-csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv"
	foreach ($c in $csvImport)
	{
		if ($c.customername -notlike $customername)
		{
			$config_customerinfo += @([config_customerinfo]@{
					customername = $c.customername
					target	     = $c.target
					
				})
			
		}
		
		
	}
	$config_customerinfo | Export-Csv "c:\users\$env:USERNAME\.IntunePrepTool\config_tenantinfo.csv" -NoTypeInformation -Force
	refreshTenants
	refreshTenantsUpload
	$appregistration = $targetName.Split("_")[0]
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Appregname: $appregistration", 'Remove App registration in EntraID if needed') # Casting the method to [void] suppresses the output. 
}

$file_file_cancel_buttonAdd_Click={
	#TODO: Place custom script here
	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
}

$addFileToolStripMenuItem_Click={
	#TODO: Place custom script here
	$file_file_panel8.Enabled = $true
	$file_file_panel8.Visible = $true
	$file_folder_panel8.Enabled = $false
	$file_folder_panel8.Visible = $false
}

$file_loadFile_button2_Click={
	#TODO: Place custom script here
	$file_file_openfiledialog1.ShowDialog()
	$file_selected_source_file_textbox3.Text = $file_file_openfiledialog1.FileNames
	$file_file_destination_textbox3.Text = $file_file_openfiledialog1.FileNames
}

$file_file_add_button2_Click={
	#TODO: Place custom script here
	if ($file_file_skip_checkbox1.Checked -eq $true)
	{
		$file_file_SKIP = $true
	}
	if ($file_file_skip_checkbox1.Checked -eq $FALSE)
	{
		$file_file_SKIP = $false
	}
	
	if ($file_file_overwrite_checkbox1.Checked -eq $true)
	{
		$file_file_overwrite = $true
	}
	if ($file_file_overwrite_checkbox1.Checked -eq $FALSE)
	{
		$file_file_overwrite = $false
	}
	
	
	$row = $table.NewRow();
	$row["Sort"] = 'file';
	$row["Source"] = $file_selected_source_file_textbox3.text;
	$row["Destination"] = $file_file_destination_textbox3.Text;
	$row["Skip"] = $file_file_SKIP ;
	$row["Overwrite"] = $file_file_overwrite;
	$table.Rows.Add($row);
	
	## - Save changes to the table:
	$table.AcceptChanges();

	$file_file_panel8.Enabled = $false
	$file_file_panel8.Visible = $false
}

$showCompleteToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-ChildForm_psf) -eq 'OK')
	{
		
	}
}

$addRegistryToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-BuildingBlocksRegistry_psf) -eq 'OK')
	{
		
	}
}

$file_folder_tablelayoutpanel1_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$toolstripstatuslabel1_Click={
	#TODO: Place custom script here
	
}

$statusbar1_PanelClick=[System.Windows.Forms.StatusBarPanelClickEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.StatusBarPanelClickEventArgs]
	#TODO: Place custom script here
	
}

$user_folder_context_system_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	
}

$BuildingBlocks_datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
	#TODO: Place custom script here
	
}

$building_blocks_show_Refresh_button1_Click={
	#TODO: Place custom script here
	
}

$buttonAddFileOrFolder_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage5
	if ((Show-BuildingBlocksFilesAndFolders_psf) -eq 'OK')
	{
		
	}
}

$buildingblocks_buttonAddRegistryCapture_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage6
	if ((Show-BuildingBlocksRegistry_psf) -eq 'OK')
	{
		
	}
}

$buildingBlocks_clear_button1_Click={
	#TODO: Place custom script here
	$BuildingBlocksTable.Clear()
	$BuildingBlocks_datagridview1.DataSource = $BuildingBlocksTable;
	$BuildingBlocksTable2.Clear()
	$BuildingBlocks_datagridview2.DataSource = $BuildingBlocksTable2;
	$BuildingBlocksTable3.Clear()
	$BuildingBlocks_datagridview3.DataSource = $BuildingBlocksTable3;
	
	#$buildingBlocks_panel85.Enabled = $false;
	$bb_usePackageInProgress_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $true
	$bb_usePackageInProgress_radiobutton1.Enabled = $true
	$buildingblocks_Name_textbox4.Text = $null
	$buildingblocks_version_textbox3.Text = $null
}

$tablelayoutpanel9_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$buildingblocks_add_Shortcuts_button1_Click={
	#TODO: Place custom script here
	$building_blocks_Action_list_tabcontrol1.SelectedTab = $building_blocks_Action_list_tabpage7
	if ((Show-BuildingBlocksShortcut_psf) -eq 'OK')
	{
		
	}
}

$buttonBuild_Click={
	#TODO: Place custom script here
	if ($buildingblocks_Name_textbox4.Text -like $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Select name and try again please!", 'Please select a name for Building Blocks first') # Casting the method to [void] suppresses the output.
	}
	else
	{
		class IntuneWinPackageConfig {
			[string]$IntuneWinFile
			[string]$DisplayName
			[string]$Publisher
			[string]$AppVersion
			[string]$reglocation
			[string]$regValue
			[string]$installCMD
			[string]$uninstallCMD
			[string]$context
		}
		class BuildingBlocksConfig {
			[bool]$packageinprogress
			[bool]$systemcontext
			[bool]$usercontext
			[string]$systemcontextconfig
			[string]$systembuildingblockslocation
			[string]$usercontextconfig
			[string]$userbuildingblockslocation
		}
		$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
		if ($config_buildingblockspath -like $null)
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please add Building Blocks location for your customer in the Start / Config menu first", 'Building Blocks location missing!')
		}
		else
		{
			$BBAppName = $buildingblocks_Name_textbox4.Text
			if (Test-Path "$config_buildingblockspath\$BBAppName")
			{
				[void][System.Windows.Forms.MessageBox]::Show("Please remove $config_buildingblockspath\$BBAppName before you can continue", 'Location Already exists')
			}
			else
			{
				$bbSystemContext = $false
				$bbUserContext = $false
				$newNameBuildingBlocks = $buildingblocks_Name_textbox4.Text
				$newNameBuildingBlocks = $newNameBuildingBlocks -replace (' ', '')
				$buildingblocks_Name_textbox4.Text = $newNameBuildingBlocks
				$buildingblocks_output_textbox5.Text = "Building Block Name: $newNameBuildingBlocks"
				$buildingblocks_output_textbox5.AppendText("  `r`n")
				$BuildingBlocksSystemLocation = $config_buildingblockspath + '\' + $newNameBuildingBlocks + "\System"
				$BuildingBlocksSystemLocation = $BuildingBlocksSystemLocation -replace ("\\", "\")
				$BuildingBlocksUserLocation = $config_buildingblockspath + '\' + $newNameBuildingBlocks + "\User" + "\BuildingBlocksData"
				$BuildingBlocksUserLocation = $BuildingBlocksUserLocation -replace ("\\", "\")
				$buildingBlockFolder = $config_buildingblockspath + '\' + $newNameBuildingBlocks
				$buildingBlockFolder = $buildingBlockFolder -replace ("\\", "\")
				#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
				[void][System.Windows.Forms.MessageBox]::Show("IntunePrepTool may temporarily become unresponsive while creating the building blocks.", 'Please wait while the building block(s) are being created.') # Casting the method to [void] suppresses the output.
				$is = 1;
				$iu = 1;
				
				
				
				if ($BuildingBlocksTable -notlike $null)
				{
					
					foreach ($r in $BuildingBlocksTable)
					{
						$BuildingBlocksFilesAndFolders = @'
$sort = "!!sort!!"
$source = "!!source!!"
$destination = "!!destination!!"
$skip = "!!skip!!"
$overwrite = "!!overwrite!!"
#Replace when needed
$destination = $destination -replace("%USERPROFILE%", $env:USERPROFILE)
$destination = $destination -replace("%APPDATA%", $env:APPDATA)
$destination = $destination -replace("%LOCALAPPDATA%", $env:LOCALAPPDATA)
Set-Location $PSScriptRoot

if (($skip -eq $true) -and ($overwrite -eq $true))
{
	Write-Host "Overwrite takes precedence over skip."
	$skip = $false
}

if (($skip -eq $false) -and ($overwrite -eq $false))
{
	Write-Host "No Skip or Overwrite selected; Overwrite takes precedence over skip."
	$overwrite = $true
}

if ($overwrite -eq $true)
{
	if ($sort -like 'folder')
	{
		if (-not (Test-Path $destination))
		{
			New-Item -ItemType Directory -Path $destination | Out-Null
		}
		Get-ChildItem -Path "Data" -Recurse | ForEach-Object {
			$targetPath = Join-Path $destination $_.FullName.Substring((Get-Item "Data").FullName.Length)
			
			if ($_.PSIsContainer)
			{
				if (-not (Test-Path $targetPath))
				{
					New-Item -ItemType Directory -Path $targetPath | Out-Null
				}
			}
			else
			{
				try
				{
					Copy-Item $_.FullName -Destination $targetPath -Force -ErrorAction Stop
					$fn = $_.FullName
					Write-Host "Copy from $fn to  $targetPath done!"
				}
				catch
				{
					$fn = $_.FullName
					Write-Error "Copy from $fn to  $targetPath failed!"
				}
				
			}
		}
	}
	
	if ($sort -like 'file')
	{
		$parentfolder = Split-Path $destination -Parent
		if (-not (Test-Path $parentfolder))
		{
			New-Item -ItemType Directory -Path $parentfolder | Out-Null
		}
		try
		{
			Copy-Item $source -Destination $destination -Force -ErrorAction Stop
			Write-Host "Copy from $source to  $destination done!"
		}
		catch
		{
			Write-Error "Copy from $source to  $destination failed!"
		}
		
	}
}

if ($skip -eq $true)
{
	if ($sort -like 'folder')
	{
		if (-not (Test-Path $destination))
		{
			New-Item -ItemType Directory -Path $destination | Out-Null
		}
		Get-ChildItem -Path "Data" -Recurse | ForEach-Object {
			$targetPath = Join-Path $destination $_.FullName.Substring((Get-Item "Data").FullName.Length)
			
			if ($_.PSIsContainer)
			{
				if (-not (Test-Path $targetPath))
				{
					New-Item -ItemType Directory -Path $targetPath | Out-Null
				}
			}
			else
			{
				if (-not (Test-Path $targetPath))
				{
					try
					{
						Copy-Item $_.FullName -Destination $targetPath -ErrorAction Stop
						$fn = $_.FullName
						Write-Host "Copy from $fn to $targetPath done!"
					}
					catch
					{
						Write-Error "Copy from $fn to $targetPath failed!"
					}
					
				}
			}
		}
	}
	
	if ($sort -like 'file')
	{
		$parentfolder = Split-Path $destination -Parent
		if (-not (Test-Path $parentfolder))
		{
			New-Item -ItemType Directory -Path $parentfolder | Out-Null
		}
		if (-not (Test-Path $destination))
		{
			try
			{
				Copy-Item $source -Destination $destination -ErrorAction Stop
				Write-Host "Copy from $source to $destination done!"
			}
			catch
			{
				Write-Host "Copy from $source to $destination failed!"
			}
			
		}
	}
}
'@
						$BuildingBlocksFilesAndFoldersUninstall = @'
$sort = "!!sort!!"
$destination = "!!destination!!"
#Replace when needed
$destination = $destination -replace("%USERPROFILE%", $env:USERPROFILE)
$destination = $destination -replace("%APPDATA%", $env:APPDATA)
$destination = $destination -replace("%LOCALAPPDATA%", $env:LOCALAPPDATA)
Set-Location $PSScriptRoot
if ($sort -like 'folder') {
remove-item $destination -recurse -confirm:$false -force
}
if ($sort -like 'file') {
remove-item $destination -confirm:$false -force
}
write-host "Uninstall file or folder action done!"
'@
						
						if ($r["Context"] -like 'system')
						{
							$bbSystemContext = $true
							$buildingblocks_output_textbox5.AppendText('File or folder actions in the system context will now be added.')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\data"
							$BuildingBlocksISLocation = $BuildingBlocksISLocation -replace ("\\", "\")
							
							if (!(test-Path $BuildingBlocksISLocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksISLocation
							}
							$sourceIs = $($r["Source"])
							$sourceIs = $sourceIs -replace ("\\", "\")
							$sort = $r["Sort"]
							$source = $r["Source"]
							if ($sort -like 'file')
							{
								$newsourcevar = $source.Split('\')[-1]
								$newsourcevar = "Data\$newsourcevar"
							}
							if ($sort -like 'folder')
							{
								$newsourcevar = "Data\*"
								
							}
							$buildingblocks_output_textbox5.AppendText("Data is being copied to the Building Blocks location.`r`n")
							if ($sort -like 'file')
							{
								$sourcefilename = $sourceIs.Split('\')[-1]
								$dest = $BuildingBlocksISLocation + "\$sourcefilename"
								Copy-Item $sourceIs -Destination $dest
							}
							if ($sort -like 'folder')
							{
								Write-Host "Copy $sourceIs to $BuildingBlocksISLocation"
								Copy-Item "$sourceIs\*" -Destination "$BuildingBlocksISLocation" -Recurse -Container
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!source!!", $newsourcevar)
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!skip!!", $r["Skip"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!overwrite!!", $r["Overwrite"])
							$instfile = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\i.ps1"
							
							$BuildingBlocksFilesAndFolders | Out-File $instfile -force
							if ($r["Uninstall"] -like $true)
							{
								$uninstfile = $BuildingBlocksSystemLocation + "\FileFolder$is" + "\u.ps1"
								$BuildingBlocksFilesAndFoldersUninstall | Out-File $uninstfile -force
							}
							
							$is = $is + 1
						}
						if ($r["Context"] -like 'user')
						{
							$bbUserContext = $true;
							$buildingblocks_output_textbox5.AppendText('File or folder actions in the user context will now be added.')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							$BuildingBlocksIULocation = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\data"
							if (!(test-Path $BuildingBlocksIULocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksIULocation
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$sourceIu = $($r["Source"])
							$sort = $r["Sort"]
							$source = $r["Source"]
							if ($sort -like 'file')
							{
								$newsourcevar = $source.Split('\')[-1]
								$newsourcevar = "Data\$newsourcevar"
							}
							if ($sort -like 'folder')
							{
								$newsourcevar = "Data\*"
								
							}
							$buildingblocks_output_textbox5.AppendText("Data is being copied to the Building Blocks location.`r`n")
							
							if ($sort -like 'file')
							{
								$sourcefilename = $sourceIu.Split('\')[-1]
								$dest = $BuildingBlocksIULocation + "\$sourcefilename"
								Copy-Item $sourceIu -Destination $dest
							}
							if ($sort -like 'folder')
							{
								Copy-Item "$sourceIU\*" -Destination $BuildingBlocksIULocation -Recurse
								
							}
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!sort!!", $r["Sort"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!source!!", $newsourcevar)
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFoldersUninstall = $BuildingBlocksFilesAndFoldersUninstall -replace ("!!destination!!", $r["Destination"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!skip!!", $r["Skip"])
							$BuildingBlocksFilesAndFolders = $BuildingBlocksFilesAndFolders -replace ("!!overwrite!!", $r["Overwrite"])
							$instfile = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\i.ps1"
							$BuildingBlocksFilesAndFolders | Out-File $instfile -force
							if ($r["Uninstall"] -like $true)
							{
								$uninstfile = $BuildingBlocksUserLocation + "\FileFolder$iu" + "\u.ps1"
								$BuildingBlocksFilesAndFoldersUninstall | Out-File $uninstfile -force
							}
							
							
							$iu = $iu + 1
						}
						
					}
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No file or folder activity detected.")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				if ($BuildingBlocksTable3 -notlike $null)
				{
					foreach ($r3 in $BuildingBlocksTable3)
					{
						
						$BuildingBlockRegistryScript = @'
Set-Location $PSScriptRoot
$regfilename = "!!regfilename!!"
if (Test-Path $regfilename) {
    $output = reg import $regfilename /reg:64 2>&1
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Registry Import succeeded!" -ForegroundColor Green
    } else {
        Write-Host "Registry Import failed with exit code $LASTEXITCODE" -ForegroundColor Red
        Write-Host "Output was: $output"
    }
}
'@
						$is = 1;
						$iu = 1;
						if ($r3["Context"] -like 'system')
						{
							$bbSystemContext = $true
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\Registry$is"
							$sourceReg = $($r3["Source"])
							if (!(test-Path $BuildingBlocksISLocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksISLocation
							}
							$buildingblocks_output_textbox5.AppendText('Registry file is now being copied to Building Block Location')
							$buildingblocks_output_textbox5.AppendText("  `r`n")
							try
							{
								Copy-Item $sourceReg -Destination "$BuildingBlocksISLocation\hklm.reg" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks done!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks failed!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$BuildingBlockRegistryScript = $BuildingBlockRegistryScript -replace ("!!regfilename!!", 'hklm.reg')
							try
							{
								$BuildingBlockRegistryScript | Out-File "$BuildingBlocksISLocation\i.ps1" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("i.ps1 created!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("failed to create i.ps1")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							
							$is = $is + 1
						}
						if ($r3["Context"] -like 'user')
						{
							$bbUserContext = $true
							$BuildingBlocksIULocation = $BuildingBlocksUserLocation + "\Registry$iu"
							$sourceReg = $($r3["Source"])
							if (!(test-Path $BuildingBlocksIULocation))
							{
								New-Item -ItemType Directory -Path $BuildingBlocksIULocation
							}
							try
							{
								Copy-Item $sourceReg -Destination "$BuildingBlocksIULocation\hkcu.reg" -force
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks done!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("Copy $sourceReg to Building Blocks failed!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$BuildingBlockRegistryScript = $BuildingBlockRegistryScript -replace ("!!regfilename!!", 'hkcu.reg')
							try
							{
								$BuildingBlockRegistryScript | Out-File "$BuildingBlocksIULocation\i.ps1" -Force -ErrorAction Stop
								$buildingblocks_output_textbox5.AppendText("i.ps1 created!")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							catch
							{
								$buildingblocks_output_textbox5.AppendText("failed to create i.ps1")
								$buildingblocks_output_textbox5.AppendText("  `r`n")
							}
							$iu = $iu + 1
						}
						
						
						
						
					}
					$buildingblocks_output_textbox5.AppendText("Registry done")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No Registry actions found")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				if ($BuildingBlocksTable2 -ne $Null)
				{
					$i = 1;
					foreach ($r2 in $BuildingBlocksTable2)
					{
						$BuildingBlockShortcutScript = @'	
$Context = "!!context!!"
$Name = "!!name!!"
$TargetLocation = "!!targetlocation!!"
$Arguments = "!!arguments!!"
$ICOFile = "!!icofile!!" ; $ICOFile = $ICOFile + ".ico"
$Subfolder = "!!subfolder!!"
$Desktop = "!!desktop!!"
$StartMenu = "!!startmenu!!"

Set-Location $PSScriptRoot
if ($Context -like 'user') {
    $folderPath = Join-Path $env:AppData "IntunePrepTool\ICONS"
    if (-not (Test-Path $folderPath)) {
        New-Item -ItemType Directory -Path $folderPath -Force | Out-Null
    }
    $destinationFile = Join-Path $folderPath (Split-Path $ICOFile -Leaf)
    Copy-Item -Path $ICOFile -Destination $destinationFile -Force
}
elseif ($Context -like 'system') {
    $folderPath = Join-Path $env:ProgramData "IntunePrepTool\ICONS"
    if (-not (Test-Path $folderPath)) {
        New-Item -ItemType Directory -Path $folderPath -Force | Out-Null
    }
    $destinationFile = Join-Path $folderPath (Split-Path $ICOFile -Leaf)
    Copy-Item -Path $ICOFile -Destination $destinationFile -Force
}


function fCreateShortcut
{
    <#
    .SYNOPSIS
    Creates a shortcut in the Desktop and/or Start Menu, for user or system context.

    .PARAMETER TargetFile
    The path to the executable or file the shortcut should point to.

    .PARAMETER ShortcutName
    The name of the shortcut (without .lnk extension).

    .PARAMETER Icon
    (Optional) Path to the icon file.

    .PARAMETER ShortcutArguments
    (Optional) Arguments to pass to the target.

    .PARAMETER Location
    One or more of 'Desktop' and/or 'StartMenu'.

    .PARAMETER Scope
    'User' or 'System' (default is 'User').

    .PARAMETER Subfolder
    (Optional) Subfolder within the Desktop or Start Menu path.
    #>
	
	param (
		[Parameter(Mandatory = $true)]
		[string]$TargetFile,
		[Parameter(Mandatory = $true)]
		[string]$ShortcutName,
		[string]$Icon = "",
		[string]$ShortcutArguments = "",
		[Parameter(Mandatory = $true)]
		[ValidateSet("Desktop", "StartMenu")]
		[string[]]$Location,
		[ValidateSet("User", "System")]
		[string]$Scope = "User",
		[string]$Subfolder = ""
	)
	
	$WorkingDir = Split-Path -Path $TargetFile -Parent
	
	foreach ($loc in $Location)
	{
		switch ($Scope)
		{
			'User' {
				$BasePath = switch ($loc)
				{
					'Desktop'   { [Environment]::GetFolderPath("Desktop") }
					'StartMenu' { [Environment]::GetFolderPath("StartMenu") }
				}
			}
			'System' {
				$BasePath = switch ($loc)
				{
					'Desktop'   { "$env:PUBLIC\Desktop" }
					'StartMenu' { "$env:ProgramData\Microsoft\Windows\Start Menu\Programs" }
				}
			}
		}
		
		$FullPath = if ($Subfolder)
		{
			Join-Path -Path $BasePath -ChildPath $Subfolder
		}
		else
		{
			$BasePath
		}
		if (-not (Test-Path $FullPath))
		{
			New-Item -Path $FullPath -ItemType Directory -Force | Out-Null
		}
		$ShortcutPath = Join-Path -Path $FullPath -ChildPath "$ShortcutName.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutPath)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.WorkingDirectory = $WorkingDir
		if ($Icon)
		{
			$Shortcut.IconLocation = $Icon
		}
		if ($ShortcutArguments)
		{
			$Shortcut.Arguments = $ShortcutArguments
		}
		$Shortcut.Save()
	}
}

if ($Desktop -like 'true') {
    fCreateShortcut -TargetFile $TargetLocation `
                    -Scope $Context `
                    -ShortcutName $Name `
                    -Location Desktop `
                    -Icon $destinationFile `
                    -ShortcutArguments $Arguments `
                    -Subfolder $Subfolder
Write-Host "Shortcut created successfully in: Desktop"
}

if ($StartMenu -like 'true') {
    fCreateShortcut -TargetFile $TargetLocation `
                    -Scope $Context `
                    -ShortcutName $Name `
                    -Location StartMenu `
                    -Icon $destinationFile `
                    -ShortcutArguments $Arguments

}
Write-Host "Shortcut created successfully in: Startmenu"
'@
						$BuildingBlockUninstallShortcutScript = @'	
$Context = "!!context!!"
$Name = "!!name!!"
$TargetLocation = "!!targetlocation!!"
$Arguments = "!!arguments!!"
$ICOFile = "!!icofile!!" ; $ICOFile = $ICOFile + ".ico"
$Subfolder = "!!subfolder!!"
$Desktop = "!!desktop!!"
$StartMenu = "!!startmenu!!"

Set-Location $PSScriptRoot

$Locations = @()
if ($Desktop)   { $Locations += 'Desktop' }
if ($StartMenu) { $Locations += 'StartMenu' }

foreach ($loc in $Locations)
{
    switch ($Context) {
        'User' {
            $BasePath = switch ($loc) {
                'Desktop'   { [Environment]::GetFolderPath('Desktop') }
                'StartMenu' { [Environment]::GetFolderPath('StartMenu') }
            }
        }
        'System' {
            $BasePath = switch ($loc) {
                'Desktop'   { Join-Path $env:Public 'Desktop' }
                'StartMenu' { Join-Path $env:ProgramData 'Microsoft\Windows\Start Menu\Programs' }
            }
        }
    }
    $FullPath = if ($Subfolder) {
        Join-Path -Path $BasePath -ChildPath $Subfolder
    }
    else {
        $BasePath
    }
    $ShortcutPath = Join-Path -Path $FullPath -ChildPath ("$Name.lnk")
    if (Test-Path $ShortcutPath) {
        Remove-Item $ShortcutPath -Force
        Write-Host "Removed shortcut: $ShortcutPath"
    }
    if ((Test-Path $FullPath) -and !(Get-ChildItem -Path $FullPath -Force)) {
        Remove-Item $FullPath -Force
        Write-Host "Removed empty folder: $FullPath"
    }
}
if ($ICOFile)
{
    if ($Context -like 'user') {
        $iconFolderPath = Join-Path $env:AppData ".IntunePrepTool\ICONS"
    }
    elseif ($Context -like 'system') {
        $iconFolderPath = Join-Path $env:ProgramData ".IntunePrepTool\ICONS"
    }
    $destinationFile = Join-Path $iconFolderPath (Split-Path $ICOFile -Leaf)
    if (Test-Path $destinationFile) {
        Remove-Item $destinationFile -Force
        Write-Host "Removed icon: $destinationFile"
    }
}

Write-Host "`nUninstall script completed."
'@
						
						
						
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!context!!", $r2["Context"])
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!context!!", $r2["Context"])
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!name!!", $($r2["Name"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!name!!", $($r2["Name"]))
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!targetlocation!!", $($r2["Target location"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!targetlocation!!", $($r2["Target location"]))
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!arguments!!", $($r2["Arguments"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!arguments!!", $($r2["Arguments"]))
						
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!subfolder!!", $($r2["Subfolder"]))
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!subfolder!!", $($r2["Subfolder"]))
						if ($r2["Desktop"] -like 'true')
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!desktop!!", $true)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!desktop!!", $true)
						}
						else
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!desktop!!", $false)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!desktop!!", $false)
						}
						if ($r2["Startmenu"] -like 'true')
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!startmenu!!", $true)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!startmenu!!", $true)
						}
						else
						{
							$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!startmenu!!", $false)
							$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!startmenu!!", $false)
						}
						if ($r2["Context"] -like 'system')
						{
							$bbSystemContext = $true;
							$BuildingBlocksISLocation = $BuildingBlocksSystemLocation + "\BuildingBlocksData" + "\shortcut$i"
						}
						if ($r2["Context"] -like 'user')
						{
							$bbUserContext = $true;
							$BuildingBlocksISLocation = $BuildingBlocksUserLocation + "\shortcut$i"
						}
						
						
						if (!(test-Path $BuildingBlocksISLocation))
						{
							New-Item -ItemType Directory -Path $BuildingBlocksISLocation
						}
						$icoName = -join (
							(97 .. 122) |
							Get-Random -Count 6 |
							ForEach-Object { [char]$_ }
						)
						$icoName = 'shortcut-' + $icoName
						$buildingblocks_output_textbox5.AppendText("Shortcut actions found!")
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						Copy-Item $($r2["ICO File"]) "$BuildingBlocksISLocation\$icoName.ico" -Force
						$buildingblocks_output_textbox5.AppendText('The ICO file (shortcut) is now being copied to the Building Block location.')
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						$BuildingBlockShortcutScript = $BuildingBlockShortcutScript -replace ("!!icofile!!", $icoName)
						$BuildingBlockUninstallShortcutScript = $BuildingBlockUninstallShortcutScript -replace ("!!icofile!!", $icoName)
						$buildingblocks_output_textbox5.AppendText('Scripts (shortcuts) are now being copied to the Building Block location.')
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						$BuildingBlockShortcutScript | Out-File "$BuildingBlocksISLocation\i.ps1" -Force
						$BuildingBlockUninstallShortcutScript | Out-File "$BuildingBlocksISLocation\u.ps1" -Force
						$buildingblocks_output_textbox5.AppendText("done!")
						$buildingblocks_output_textbox5.AppendText("  `r`n")
						
						
						
						
						$i = $i + 1
					}
					
					
				}
				else
				{
					$buildingblocks_output_textbox5.AppendText("No Shortcut actions found")
					$buildingblocks_output_textbox5.AppendText("  `r`n")
				}
				
				
				$buildingblocks_output_textbox5.AppendText("Building Blocks created: $buildingBlockFolder")
				$buildingblocks_output_textbox5.AppendText("  `r`n")
				#$buildingBlocks_panel85.Enabled = $true;
				if ($bbUserContext -like $true)
				{
					$userContext_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!" ; $version = $version + "user"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextInstall_$appname$version.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 

	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\i.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
		
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1 }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
					$userContext_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!" ; $version = $version + "user"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextUninstall_$appname$version.txt")
$regkeyRoot = "HKCU:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
	
	
}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1 }
else { remove-item $regkeyApp; exit 0 }
'@
					$buildingblocks_output_textbox5.AppendText("`Generating install and uninstall powershell scripts for the User Context Package...`r`n")
					$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
					$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
					$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
					$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
					$appname = $buildingblocks_Name_textbox4.text
					$appversion = $buildingblocks_version_textbox3.Text
					$RegisterDetectionroot = "Intune_" + $config_customername
					$userContext_installFile = $userContext_installFile.Replace('!!AppName!!', "$appname")
					$userContext_installFile = $userContext_installFile.Replace('!!logdir!!', $config_logfoldertarget)
					$userContext_installFile = $userContext_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
					$userContext_installFile = $userContext_installFile.Replace('!!version!!', $appversion)
					$userContext_installFile | Out-File "$config_buildingblockspath\$appname\User\install.ps1" -Force
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!AppName!!', "$appname")
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
					$userContext_uninstallFile = $userContext_uninstallFile.Replace('!!version!!', $appversion)
					$userContext_uninstallFile | Out-File "$config_buildingblockspath\$appname\User\uninstall.ps1" -Force
					$buildingblocks_output_textbox5.AppendText("`install.ps1 and uninstall.ps1 created! `r`n")
					#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
					[void][System.Windows.Forms.MessageBox]::Show(
						'The IntunePrepTool will not respond until packaging is complete. Large packages may take several minutes. Please wait.',
						'Creating User Context Package'
					) # Casting the method to [void] suppresses the output. 
					if (!(Test-Path "$config_buildingblockspath\$appname\output-UserContext\"))
					{
						mkdir "$config_buildingblockspath\$appname\output-UserContext\" -Force
					}
					
					
					& .\IntuneWinAppUtil.exe -c "$config_buildingblockspath\$appname\User\" -s "$config_buildingblockspath\$appname\User\install.ps1" -o "$config_buildingblockspath\$appname\output-UserContext\" -q
					Rename-Item -Path "$config_buildingblockspath\$appname\output-UserContext\install.intunewin" -NewName "$config_buildingblockspath\$appname\output-UserContext\$appname.intunewin"
					$buildingblocks_output_textbox5.AppendText("`nIntunewin file created: `r`n")
					$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-UserContext\$appname.intunewin")
					$buildingblocks_output_textbox5.AppendText("`r`n")
					
					$context = 'user'
					$icmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File install.ps1"
					$ucmd = "powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File uninstall.ps1"
					$regkeyRoot = "HKEY_CURRENT_USER\Software\$RegisterDetectionroot\"
					$regkeyApp = "$regkeyRoot$appname"
					$usercontextVersion = $appversion + "user"
					$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
							IntuneWinFile = "$appname.intunewin"
							DisplayName   = $appname
							Publisher	  = $config_customername
							AppVersion    = $usercontextVersion;
							reglocation   = $regkeyApp
							regValue	  = 'Version'
							installCMD    = $icmd
							uninstallCMD  = $ucmd
							context	      = $context
						})
					$IntuneWinPackageConfig | Export-Csv "$config_buildingblockspath\$appname\output-UserContext\config.csv" -NoTypeInformation
					$buildingblocks_output_textbox5.AppendText("`Config.csv created: `r`n")
					$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-UserContext\config.csv")
					$buildingblocks_output_textbox5.AppendText("`r`n")
					if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
					{
						if ($bbSystemContext -like $false)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $false
									usercontext				     = $true
									systemcontextconfig		     = $null;
									systembuildingblockslocation = $null;
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv";
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
							
						}
						
					}
					else
					{
						if ($bbSystemContext -like $false)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $false
									systemcontext			     = $false
									usercontext				     = $true
									systemcontextconfig		     = $null;
									systembuildingblockslocation = $null;
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv";
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Building Blocks - Standalone Package Info')
							
						}
					}
					
				}
				if ($bbSystemContext -like $true)
				{
					$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
					$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
					$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
					$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
					$appname = $buildingblocks_Name_textbox4.text
					$appversion = $buildingblocks_version_textbox3.Text
					
					if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
					{
						if ($bbUserContext -like $true)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $true
									usercontext				     = $true
									systemcontextconfig		     = $null
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig		     = "$config_buildingblockspath\$appname\output-UserContext\config.csv"
									userbuildingblockslocation   = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
						}
						else
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress		     = $true
									systemcontext			     = $true
									usercontext				     = $false
									systemcontextconfig		     = $null;
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig		     = $null;
									userbuildingblockslocation   = $null;
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Please finish your package (Press the 'Go back to Package in Progress button') first by testing the uninstall. Then click 'Add BuildingBlocks.csv' and load $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - In-Progress Package Info')
						}
					}
					else
					{
						
						
						$systemContext_installFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	install.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksSystemContextInstall_$appname$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


##Create log direcotry if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
##Create registry root if needed
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates application Key in registry
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

<# Begin Powershell Functions.
#>


function fDetectionInRegistry
{
	### This function handles the detection method in the registry.
	### It will create a key in the registry with the name of the application. 

	### Usage: fDetectionInRegistry -succes $False of fDetectionInRegistry -succes $true
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}



<# End Powershell Functions #>
#Setup Script Location
Set-Location $PSScriptRoot

#Start; Write Log file
Start-Transcript -Path $logfile
Set-Location $PSScriptRoot
try
{
	
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\i.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
		
}
catch
{
	Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	$excode = 1
}
### Place extra actions here:









<#----Enf of extra actions--#>
#Stop; Write Log file
Stop-Transcript
if ($excode -eq 1) { exit 1 }
else { fDetectionInRegistry -succes $true; exit 0 }


'@
						$systemContext_uninstallFile = @'	
<#	
	.NOTES
	===========================================================================
	 Created with: 	SAPIEN Technologies, Inc., PowerShell Studio 2025 v5.9.253
	 Created on:   	18-4-2025 15:50
	 Created by:   	Rink Turksma
	 Organization: 	https://github.com/rink-turksma/IntunePrepTool
	 Filename:     	uninstall.ps1
	===========================================================================
	.DESCRIPTION
		A description of the file.
#>

$appName = "!!AppName!!"
$version = "!!version!!"
$logdir = "!!logdir!!"
$RegisterDetectionroot = "!!RegisterDetectionroot!!"
#Dyn vars
$logfile = $(Join-Path $logdir  "BuildingBlocksUserContextUninstall_$appname$version.txt")
$regkeyRoot = "HKLM:\Software\$RegisterDetectionroot"
$regkeyApp = "$regkeyRoot\$appName"
$excode = $null;


#Creates Log directory if needed.
if (!(Test-Path -Path $logdir))
{
	
	New-Item -ItemType Directory -Path $logdir
}
#Creates DLL directory if needed. (For Message Log Definitions, IntunePrepToo_msgfile.dll)
if (!(Test-Path -Path "$logdir\dll"))
{
	
	New-Item -ItemType Directory -Path "$logdir\dll"
}
#Creates Registry Root if needed.
if (!(Test-Path -Path $regkeyRoot))
{
	New-Item $regkeyRoot -ItemType Key -Force | out-null
}
#Creates Registry App if needed.
if (!(Test-Path -Path $regkeyApp))
{
	New-Item $regkeyApp -ItemType Key -Force | out-null
}

#Function for Detection in Registry

function fDetectionInRegistry
{
	param
	(
		[Parameter(Mandatory = $true)]
		[bool]$Succes
	)
	
	try
	{
		$AppRegVersie = Get-ItemProperty -Path $regkeyApp -Name Version -ErrorAction Stop
		if ($AppRegVersie.Version -ne $version) { set-ItemProperty -Path $regkeyApp -Name Version -Value $Version }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Version -Value $Version -PropertyType string
	}
	try
	{
		$AppRegSucces = Get-ItemProperty -Path $regkeyApp -Name Succes -ErrorAction Stop
		if ($AppRegSucces.Succes -ne $Succes) { set-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes }
	}
	catch
	{
		new-ItemProperty -Path $regkeyApp -Name Succes -Value $Succes -PropertyType string
	}
}


#Setup Script Location
Set-Location $PSScriptRoot


#Start Script
Start-Transcript -Path $logfile
try
{
	if (Test-Path 'BuildingBlocksData')
	{
		$originalLocation = Get-Location
		Write-Host "BuildBlocks folder detected"
		
		$allBuildingBlocks = Get-ChildItem 'BuildingBlocksData'
		foreach ($bb in $allBuildingBlocks)
		{
			$bbScriptLocation = 'BuildingBlocksData\' + $bb.Name + "\u.ps1"
			
			if (Test-Path $bbScriptLocation -PathType Leaf)
			{
				Write-Host "Now running Building Blocks Script $bbScriptLocation"
				& $bbScriptLocation
				Set-Location $originalLocation
			}
		}
	}
	
	
}
catch
{
	$_.Exception | Format-List -Force
	$_.Exception.InnerException
	Write-Host "Uninstall failed" --ForegroundColor Red -BackgroundColor Blue
	$excode = 1
}


#End Script
Stop-Transcript


if ($excode -eq 1) { exit 1 }
else { remove-item $regkeyApp; exit 0 }
'@
						$buildingblocks_output_textbox5.AppendText("`Generating install and uninstall powershell scripts for the System Context Package...`r`n")
						$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
						$config_buildingblockspath = Get-Variable -Name 'config_buildingblockspath' -ValueOnly -Scope Script
						$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
						$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
						$appname = $buildingblocks_Name_textbox4.text
						$appversion = $buildingblocks_version_textbox3.Text
						$RegisterDetectionroot = "Intune_" + $config_customername
						$systemContext_installFile = $systemContext_installFile.Replace('!!AppName!!', "$appname")
						$systemContext_installFile = $systemContext_installFile.Replace('!!logdir!!', $config_logfoldertarget)
						$systemContext_installFile = $systemContext_installFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
						$systemContext_installFile = $systemContext_installFile.Replace('!!version!!', $appversion)
						$systemContext_installFile | Out-File "$config_buildingblockspath\$appname\System\install.ps1" -Force
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!AppName!!', "$appname")
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!logdir!!', $config_logfoldertarget)
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!RegisterDetectionroot!!', $RegisterDetectionroot)
						$systemContext_uninstallFile = $systemContext_uninstallFile.Replace('!!version!!', $appversion)
						$systemContext_uninstallFile | Out-File "$config_buildingblockspath\$appname\System\uninstall.ps1" -Force
						$buildingblocks_output_textbox5.AppendText("`install.ps1 and uninstall.ps1 created! `r`n")
						#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
						[void][System.Windows.Forms.MessageBox]::Show(
							'The IntunePrepTool will not respond until packaging is complete. Large packages may take several minutes. Please wait.',
							'Creating System Context Package'
						) # Casting the method to [void] suppresses the output. 
						if (!(Test-Path "$config_buildingblockspath\$appname\output-SystemContext\"))
						{
							mkdir "$config_buildingblockspath\$appname\output-SystemContext\" -Force
						}
						
						
						& .\IntuneWinAppUtil.exe -c "$config_buildingblockspath\$appname\System\" -s "$config_buildingblockspath\$appname\System\install.ps1" -o "$config_buildingblockspath\$appname\output-SystemContext\" -q
						Rename-Item -Path "$config_buildingblockspath\$appname\output-SystemContext\install.intunewin" -NewName "$config_buildingblockspath\$appname\output-SystemContext\$appname.intunewin"
						$buildingblocks_output_textbox5.AppendText("`nIntunewin file created: `r`n")
						$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-SystemContext\$appname.intunewin")
						$buildingblocks_output_textbox5.AppendText("`r`n")
						
						$context = 'system'
						$icmd = "powershell -executionpolicy bypass -file install.ps1"
						$ucmd = "powershell -executionpolicy bypass -file uninstall.ps1"
						$regkeyRoot = "HKEY_LOCAL_MACHINE\Software\$RegisterDetectionroot\"
						$regkeyApp = "$regkeyRoot$appname"
						$IntuneWinPackageConfig = $null;
						$IntuneWinPackageConfig += @([IntuneWinPackageConfig]@{
								IntuneWinFile = "$appname.intunewin"
								DisplayName   = $appname
								Publisher	  = $config_customername
								AppVersion    = $appversion;
								reglocation   = $regkeyApp
								regValue	  = 'Version'
								installCMD    = $icmd
								uninstallCMD  = $ucmd
								context	      = $context
							})
						$IntuneWinPackageConfig | Export-Csv "$config_buildingblockspath\$appname\output-SystemContext\config.csv" -NoTypeInformation
						$buildingblocks_output_textbox5.AppendText("`Config.csv created: `r`n")
						$buildingblocks_output_textbox5.AppendText("$config_buildingblockspath\$appname\output-SystemContext\config.csv")
						$buildingblocks_output_textbox5.AppendText("`r`n")
						
						if ($bbUserContext -like $true)
						{
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress   = $false
									systemcontext	    = $true
									usercontext		    = $true
									systemcontextconfig = "$config_buildingblockspath\$appname\output-SystemContext\config.csv"
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig   = "$config_buildingblockspath\$appname\output-UserContext\config.csv"
									userbuildingblockslocation = "$config_buildingblockspath\$appname\User";
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Building Blocks - Standalone Package Info')
						}
						else
						{
							
							$BuildingBlocksConfig += @([BuildingBlocksConfig]@{
									packageinprogress   = $false
									systemcontext	    = $true
									usercontext		    = $false
									systemcontextconfig = "$config_buildingblockspath\$appname\output-SystemContext\config.csv"
									systembuildingblockslocation = "$config_buildingblockspath\$appname\System";
									usercontextconfig   = $null
									userbuildingblockslocation = $null;
								})
							$BuildingBlocksConfig | export-csv "$config_buildingblockspath\$appname\BuildingBlocks.csv" -force -NoTypeInformation
							[void][System.Windows.Forms.MessageBox]::Show("Go to the Upload Menu -> Intunewin and then click the 'Open BuildingBlocks.csv' button and Select $config_buildingblockspath\$appname\BuildingBlocks.csv", 'Adding Building Blocks - Standalone Package Info')
							
						}
					}
				}
				
			}
		}
	}
	
	
}

$buildingblocks_Name_textbox4_TextChanged={
	#TODO: Place custom script here
	if ($config_listbox.SelectedItem -eq $null)
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show('Please select Customer in the Config Tab page.', 'Select Customer first')
	} # Casting the method to [void] suppresses the output. 
	else
	{
		
	}
}

$config_buildingBlocksBrowse_button1_Click={
	#TODO: Place custom script here
	if ($config_buildingBlcoks_folderbrowsermoderndialog3.ShowDialog() -eq 'OK')
	{
		$config_buildingblocks_textbox3.Text = $config_buildingBlcoks_folderbrowsermoderndialog3.SelectedPath
	}
}

$config_install_orca_buttonInstallOrcaPowershel_Click={
	#TODO: Place custom script here
$installOrca = @'



[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
$WinSDKSetup = "C:\windows\Temp\winsdksetup.exe"
try {
Invoke-WebRequest -Uri "https://go.microsoft.com/fwlink/?linkid=2313119" -OutFile $WinSDKSetup -ErrorAction Stop
Write-Host "Downloaded winsdksetup.exe to $WinSDKSetup"
}
catch {
Write-Error "Failed downloading winsdksetup.exe"
}

$exeParameters = '/layout "C:\Program Files\IntunePrepTool" /q /features OptionId.MSIInstallTools /quiet /norestart'

try
{
	Start-Process -FilePath $WinSDKSetup -ArgumentList $exeParameters -Wait -NoNewWindow -ErrorAction Stop
	write-host "Installation completed of $WinSDKSetup" -ForegroundColor Green
	
	
}
catch
{
	write-host "Error executing "C:\windows\Temp\winsdksetup.exe"" -ForegroundColor Yellow
	Write-Host "installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
	
	
}

try
{
	$startPMSI = Start-Process msiexec.exe `
    -ArgumentList '/i', '"C:\Program Files\IntunePrepTool\Installers\Orca-x86_en-us.msi"', '/qn', '/l*v', '"C:\Windows\Temp\OrcaMSI.txt"' `
    -Wait `
    -NoNewWindow `
    -ErrorAction Stop

	write-host $startPMSI
	$msilog = get-content 'c:\windows\temp\OrcaMSI.txt'
	if ($msilog -eq $null) { write-error "Can't read MSIEXEC logs Use: /l*v $logfileMSI in msiexec commando" }
	Else
	{
		foreach ($ml in $msilog)
		{
			if ($ml -like "*APPCOMPAT: looking for appcompat database entry with ProductCode*")
			{
				$msiUninstallcode = $ml.Split('{')[1].Split('}')[0]
			}
		}
		write-host "Install done!" -ForegroundColor Green
		write-host "Possible uninstall command is:" -ForegroundColor Green
		write-host ""
		write-host "msiexec /x {$msiuninstallcode} /qn" -ForegroundColor Green

	}
	
}
catch
{
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Error message: $($_.Exception.Message)" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "MSIEXEC Log start:.:" -ForegroundColor Red -BackgroundColor Blue
    Write-Host $logfileMSI -ForegroundColor Red -BackgroundColor Blue
    $MSILOGS = get-content 'c:\windows\temp\OrcaMSI.txt'
    $MSILOGS
    Write-Host "See what this means: https://learn.microsoft.com/en-us/windows/win32/msi/error-codes" -ForegroundColor Red -BackgroundColor Blue
    Write-Host "Installation failed" -ForegroundColor Red -BackgroundColor Blue
}
write-host "Cleaning temp install files now" -ForegroundColor Green
Remove-Item $WinSDKSetup -Confirm:$false
Remove-Item -Path "C:\Program Files\IntunePrepTool\Installers" -Recurse -Force -Confirm:$false
Remove-Item  "C:\Windows\Temp\OrcaMSI.txt" -Confirm:$false

'@

	
	if (!(Test-Path "c:\program files\IntunePrepTool\installOrca.ps1" -PathType Leaf))
	{
		$installOrca  | Out-File "c:\program files\IntunePrepTool\installOrca.ps1"
	}
	else
	{
		Remove-Item -Path "c:\program files\IntunePrepTool\installOrca.ps1" -Confirm:$false -Force
		$installOrca | Out-File "c:\program files\IntunePrepTool\installOrca.ps1"
	}
	
	powershell_ise -file "c:\program files\IntunePrepTool\installOrca.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$msi_open_Orca_button1_Click={
	#TODO: Place custom script here
	if (Test-Path "C:\Program Files (x86)\Orca\Orca.exe" -Type Leaf)
	{
		$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
		$config_logfoldertarget = Get-Variable -Name 'config_logfoldertarget' -ValueOnly -Scope Script
		$config_customername = Get-Variable -Name 'config_customername' -ValueOnly -Scope Script
		$msipnaam = $msi_packagenaam_textbox1.text
		$msiversie = $msi_versie_textbox1.text
		$MSINewname = $msi_openfiledialog1.FileName
		$MSINewname = $MSINewname.Split("\")[$MSINewname.Split("\").Count - 1]
		$MSINewname = $MSINewname.Replace(" ", "")
		$MSIbestand = "$config_packagefolder\$msipnaam\$msiversie\source\$MSINewname"
		Start-Process "C:\Program Files (x86)\Orca\Orca.exe" -ArgumentList $MSIbestand
	}
	else
	{
		#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
		[void][System.Windows.Forms.MessageBox]::Show("Use the Install Orca (PowerShell_ISE) button in the Start/Config menu.", 'Please install Orca first') # Casting the method to [void] suppresses the output.
		
	}
	
}

$msi_gotobuildingblocks_button2TestInstallPowershe_Click={
	#TODO: Place custom script here
	
}

$msi_buttonOptionalGoToBuilding_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'msi'| Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'msi' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $msi_packagenaam_textbox1.text
	$buildingblocks_version_textbox3.text = $msi_versie_textbox1.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
	
	
}

$msi_addBuildingBlocksSystemContextbutton5CreateIntunewinFile_Click= {
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $msi_packagenaam_textbox1.text
			$PacVersion = $msi_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$MSI_buildigblocks_Package_InProgresstextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			$MSI_buildigblocks_Package_InProgresstextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
		}
	}
}

$bb_gobackToPackageInProgress_button1_Click={
	#TODO: Place custom script here
	if (!(Test-Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Type Leaf))
	{
		
	}
	else
	{
		$BBWheretoGoBack = get-content 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt'
		if ($BBWheretoGoBack -like 'msi')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $true
			$package_msi_tabcontrol2.Visible = $true
			$package_msi_tabcontrol2.Dock = 'Fill'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'exe')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $true
			$package_exe_tabcontrol2.Visible = $true
			$package_exe_tabcontrol2.Dock = 'Fill'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'msix')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'Fill'
			$MSIX_tabcontrol1.Enabled = $true
			$MSIX_tabcontrol1.Visible = $true
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'choco')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $true
			$tools_chocolatey_tabcontrol1.Visible = $true
			$tools_chocolatey_tabcontrol1.Dock = 'Fill'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $false
			$package_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Dock = 'None'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
		if ($BBWheretoGoBack -like 'winget')
		{
			$file_tabcontrol1.Enabled = $false
			$file_tabcontrol1.Visible = $False
			$file_tabcontrol1.Dock = 'None'
			$tools_chocolatey_tabcontrol1.Enabled = $false
			$tools_chocolatey_tabcontrol1.Visible = $false
			$tools_chocolatey_tabcontrol1.Dock = 'None'
			$updatepackage_exe_tabcontrol1.Enabled = $false
			$updatepackage_exe_tabcontrol1.Visible = $false
			$updatepackage_exe_tabcontrol1.Dock = 'None'
			$updatepackage_msi_tabcontrol1.Enabled = $false
			$updatepackage_msi_tabcontrol1.Visible = $false
			$updatepackage_msi_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Dock = 'None'
			$MSIX_tabcontrol1.Enabled = $false
			$MSIX_tabcontrol1.Visible = $false
			$download_tabcontrol1.Enabled = $false
			$download_tabcontrol1.Visible = $False
			$download_tabcontrol1.Dock = 'None'
			$tools_uninstallstring_tabcontrol1.Dock = 'none'
			$tools_uninstallstring_tabcontrol1.Enabled = $false
			$tools_uninstallstring_tabcontrol1.Visible = $false
			$tools_winget_searchtabcontrol1.Dock = 'None'
			$tools_winget_searchtabcontrol1.Enabled = $false
			$tools_winget_searchtabcontrol1.Visible = $false
			$upload_intunewin_tabcontrol2.Dock = 'None'
			$upload_intunewin_tabcontrol2.Enabled = $false
			$upload_intunewin_tabcontrol2.Visible = $false
			$package_ScheduledTask_tabcontrol2.Dock = 'None'
			$package_ScheduledTask_tabcontrol2.Enabled = $false
			$package_ScheduledTask_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Dock = 'None'
			$package_weblink_tabcontrol2.Visible = $false
			$package_weblink_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Dock = 'None'
			$Remediations_winget_tabcontrol2.Enabled = $false
			$Remediations_winget_tabcontrol2.Visible = $false
			$package_winget_tabcontrol2.Enabled = $true
			$package_winget_tabcontrol2.Visible = $true
			$package_winget_tabcontrol2.Dock = 'Fill'
			$config_tabpage.Enabled = $false
			$config_tabpage.Visible = $false
			$config_tabpage.Dock = 'None'
			$package_exe_tabcontrol2.Enabled = $false
			$package_exe_tabcontrol2.Visible = $false
			$package_exe_tabcontrol2.Dock = 'None'
			$package_msi_tabcontrol2.Enabled = $false
			$package_msi_tabcontrol2.Visible = $false
			$package_msi_tabcontrol2.Dock = 'None'
			$download_MSSTore_tabcontrol1.Enabled = $false
			$download_MSSTore_tabcontrol1.Visible = $false
			$download_MSSTore_tabcontrol1.Dock = 'None'
			$Powershell.Enabled = $False
			$Powershell.Visible = $false
			$Powershell.Dock = 'None'
		}
	}
	
}

$bb_standalone_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($bb_standalone_radiobutton1.Enabled -eq $true)
	{
		#$bb_usePackageInProgress_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $true
		$buildingblocks_version_textbox3.Enabled = $true
	}
	if ($bb_standalone_radiobutton1.Enabled -eq $false)
	{
		#$bb_usePackageInProgress_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $false
		$buildingblocks_version_textbox3.Enabled = $false
		
	}
	
}

$bb_usePackageInProgress_radiobutton1_CheckedChanged={
	#TODO: Place custom script here
	if ($bb_usePackageInProgress_radiobutton1.Enabled -eq $true)
	{
		#$bb_standalone_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $false
		$buildingblocks_version_textbox3.Enabled = $false
		
		
	}
	if ($bb_usePackageInProgress_radiobutton1.Enabled -eq $false)
	{
		#$bb_standalone_radiobutton1.Enabled = $false
		$buildingblocks_Name_textbox4.Enabled = $true
		$buildingblocks_version_textbox3.Enabled = $true
	}
	if ($bb_usePackageInProgress_radiobutton1.Checked -eq $true)
	{
		if (($buildingblocks_Name_textbox4.Text -like $Null) -or ($buildingblocks_version_textbox3.Text -like $Null))
		{
			[void][System.Windows.Forms.MessageBox]::Show(
				"Please go to your MSI, MSIX, EXE, Chocolatey or Winget package. After testing install, then use the '(Optional) Go to Building Blocks' button",
				"Button '(Optional) Go to Building Blocks' not used!"
			)
		}
	}
	
	
}

$buildingblocks_add_script_buttonAddShotcut_Click={
	#TODO: Place custom script here
	
}

$exe_open_withqquestion_button1_Click={
	#TODO: Place custom script here
	[void][System.Windows.Forms.MessageBox]::Show(
		"If the EXE file supports this, a popup will open with all the install parameters. If the EXE file does not support it, it might launch the setup. In that case, please close it before continuing.",
		'Testing opening EXE file with /?'
	)
	[string]$exe_org_path = $exe_openfiledialog1.FileNames
	Unblock-File -Path $exe_org_path -Confirm:$false
	Start-Process $exe_org_path -ArgumentList '/?' -WindowStyle Normal
	
}

$exe_test_done_button1CreateInstallScript_Click={
	#TODO: Place custom script here
	$exe_preBackupPath64 = Get-Variable -Name exe_preBackupPath64 -ValueOnly -Scope Script
	$exe_preBackupPath32 = Get-Variable -Name exe_preBackupPath32 -ValueOnly -Scope Script
	$backupFolder = "$env:LOCALAPPDATA\temp"
	$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$PostBackupPath64 = Join-Path $backupFolder "PostChanges64_$timeStamp.reg"
	$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$PostBackupPath32 = Join-Path $backupFolder "PostChanges32_$timeStamp.reg"
	$regexportpath = "HKLM\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
	reg export "$regExportPath" "$PostBackupPath32" /y | Out-Null
	$regexportpath = "HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall"
	reg export "$regExportPath" "$PostBackupPath64" /y | Out-Null
	$timeStamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
	$regDiffFile64 = Join-Path $backupFolder "Difffile64_$timeStamp.reg"
	$regDiffFile32 = Join-Path $backupFolder "Difffile32_$timeStamp.reg"
	function Compare-RegFiles
	{
		param (
			[string]$OldRegPath,
			[string]$NewRegPath,
			[string]$DiffOutPath
		)
		
		$oldLines = [System.IO.File]::ReadAllLines($OldRegPath)
		$newLines = [System.IO.File]::ReadAllLines($NewRegPath)
		$oldHashSet = [System.Collections.Generic.HashSet[string]]::new($oldLines)
		$differences = New-Object System.Collections.Specialized.OrderedDictionary
		$currentKey = $null
		foreach ($line in $newLines)
		{
			if ($line -match '^\[\S+\]$')
			{
				$currentKey = $line
				continue
			}
			if ($line -match '^\S+=' -and $currentKey)
			{
				if (-not $oldHashSet.Contains($line))
				{
					if (-not $differences.Contains($currentKey))
					{
						$differences[$currentKey] = [System.Collections.Generic.List[string]]::new()
					}
					$differences[$currentKey].Add($line)
				}
			}
		}
		if ($differences.Count -gt 0)
		{
			Set-Content -Path $DiffOutPath -Value "Windows Registry Editor Version 5.00`r`n"
			foreach ($key in $differences.Keys)
			{
				Add-Content -Path $DiffOutPath -Value "`r`n$key"
				foreach ($val in $differences[$key])
				{
					Add-Content -Path $DiffOutPath -Value $val
				}
			}
			$DiffOutPath | out-file "C:\windows\temp\LatestRegOutPathIntunePrepTool.txt" -force
		}
		else
		{
			if (Test-Path $DiffOutPath)
			{
				Remove-Item $DiffOutPath -ErrorAction SilentlyContinue
			}
		}
	}
	
	Compare-RegFiles -OldRegPath $exe_preBackupPath64 `
					 -NewRegPath $PostBackupPath64 `
					 -DiffOutPath $regDiffFile64
	
	Compare-RegFiles -OldRegPath $exe_preBackupPath32 `
					 -NewRegPath $PostBackupPath32 `
					 -DiffOutPath $regDiffFile32
	Remove-Item $PostBackupPath64 -Confirm:$false
	Remove-Item $exe_preBackupPath64 -Confirm:$false
	Remove-Item $PostBackupPath32 -Confirm:$false
	Remove-Item $exe_preBackupPath32 -Confirm:$false
	
	foreach ($file in @($regDiffFile64, $regDiffFile32))
	{
		if (Test-Path $file -PathType Leaf)
		{
			$regString = Get-Content $file
			$regInfo = @{ }
			
			foreach ($line in $regString)
			{
				if ($line -match '^\s*\"(?<key>.+?)\"=\"(?<value>.*)\"')
				{
					$regInfo[$matches['key']] = $matches['value']
				}
				elseif ($line -match '^\s*\"(?<key>.+?)\"=dword:(?<value>.+)')
				{
					$regInfo[$matches['key']] = [Convert]::ToInt32($matches['value'], 16)
				}
				elseif ($line -match '^\s*\"(?<key>.+?)\"=(?<value>.+)')
				{
					$regInfo[$matches['key']] = $matches['value'].Trim().Trim('"')
				}
			}
			
			$exe_output_textbox1.AppendText("`r`n")
			$exe_output_textbox1.AppendText("DisplayName: " + $regInfo["DisplayName"] + "`r`n")
			$exe_output_textbox1.AppendText("DisplayVersion: " + $regInfo["DisplayVersion"] + "`r`n")
			$exe_output_textbox1.AppendText("InstallDate: " + $regInfo["InstallDate"] + "`r`n")
			$exe_output_textbox1.AppendText("UninstallString: " + $regInfo["UninstallString"] + "`r`n")
			$InstallsUninstallString = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
			$wattezoeken = $regInfo["DisplayName"]
			$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
			if ($InstallsUninstallString -notlike $null)
			{
				
				foreach ($ius in $InstallsUninstallString)
				{
					$exe_output_textbox1.AppendText("Another possible uninstall string: " + $ius.UninstallString + "`r`n")
					$uninststr = $ius.UninstallString
					if ($uninststr -like '*.exe*') { $exe_uninstall_exe_path_textbox2.Text = $uninststr; $exe_radiobuttonUninstallEXEPath.Checked = $true; $exe_parsUnInstall_textbox1.Text = $exe_parsInstall_textbox1.Text }
					if ($uninststr -like '*{*')
					{
						$newuni = $uninststr.Split("{")[1]
						$newuni = $newuni.Split("}")[0]
						$exe_radiobutton3.Checked = $true
						$MSIXECUninstall = $exe_msiexecuninstall.Text
						$MSIXECUninstall = $MSIXECUninstall -replace ("PlaceProductIDhere", $newuni)
						$exe_msiexecuninstall.Text = $MSIXECUninstall;
					}
				}
			}
			$InstallsUninstallString = Get-ItemProperty HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate, UninstallString | Sort-Object InstallDate
			$wattezoeken = $regInfo["DisplayName"]
			$InstallsUninstallString = $InstallsUninstallString | where-object { $_.DisplayName -contains $wattezoeken -or $_.DisplayName -match $wattezoeken }
			if ($InstallsUninstallString -notlike $null)
			{
				
				foreach ($ius in $InstallsUninstallString)
				{
					$exe_output_textbox1.AppendText("Another possible uninstall string: " + $ius.UninstallString + "`r`n")
					$uninststr = $ius.UninstallString
					if ($uninststr -like '*.exe*') { $exe_uninstall_exe_path_textbox2.Text = $uninststr; $exe_radiobuttonUninstallEXEPath.Checked = $true; $exe_parsUnInstall_textbox1.Text = $exe_parsInstall_textbox1.Text  }
					if ($uninststr -like '*{*')
					{
						$newuni = $uninststr.Split("{")[1]
						$newuni = $newuni.Split("}")[0]
						$exe_radiobutton3.Checked = $true
						$MSIXECUninstall = $exe_msiexecuninstall.Text
						$MSIXECUninstall = $MSIXECUninstall -replace("PlaceProductIDhere", $newuni)
						$exe_msiexecuninstall.Text = $MSIXECUninstall;
						 }
				}
			}
			
		}
	}
	
	
}

$tablelayoutpanel3_Paint=[System.Windows.Forms.PaintEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.PaintEventArgs]
	#TODO: Place custom script here
	
}

$config_buttonOpenReleaseNotesOnIn_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/updates/intunepreptool-1-7-0-0/'
}


$exe_gotobuildingblocksButton_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'exe' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'exe' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $exe_packagenaam_textbox1.text
	$buildingblocks_version_textbox3.text = $exe_versie_textbox1.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$tools_choco_gotoBuildingBlocks_Button_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'choco' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'choco' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $tools_choco_displayname_textbox3.text
	$buildingblocks_version_textbox3.text = $tools_choco_appversion_textbox3.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$msix_GotoBuildingBlocks_Button_Click={
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'msix' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'msix' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $msix_packagename_textbox3.text
	$buildingblocks_version_textbox3.text = $msix_packageVersion_textbox3.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$winget_gotobuildingBlocks_buttonTestInstallPowershel_Click={
	#TODO: Place custom script here
	
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("After clicking the Build button in the Building Blocks menu go Back to finish this package.", 'Create your Building Blocks') # Casting the method to [void] suppresses the output.
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt" -PathType Leaf))
	{
		'winget' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Force
	}
	else
	{
		Remove-Item -Path 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -Confirm:$false -Force
		'winget' | Out-File 'c:\program files\IntunePrepTool\PackageLatestBuildingBlock.txt' -force
	}
	$buildingblocks_Name_textbox4.text = $winget_displayname_textbox1.text
	$buildingblocks_version_textbox3.text = $versie_textbox2.Text
	$bb_usePackageInProgress_radiobutton1.Checked = $true
	$bb_standalone_radiobutton1.Checked = $false
	$bb_standalone_radiobutton1.Enabled = $false
	
	$file_tabcontrol1.Enabled = $false
	$file_tabcontrol1.Visible = $False
	$file_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Dock = 'None'
	$MSIX_tabcontrol1.Enabled = $false
	$MSIX_tabcontrol1.Visible = $false
	$download_tabcontrol1.Enabled = $false
	$download_tabcontrol1.Visible = $False
	$download_tabcontrol1.Dock = 'None'
	$tools_uninstallstring_tabcontrol1.Dock = 'none'
	$tools_uninstallstring_tabcontrol1.Enabled = $false
	$tools_uninstallstring_tabcontrol1.Visible = $false
	$tools_winget_searchtabcontrol1.Dock = 'None'
	$tools_winget_searchtabcontrol1.Enabled = $false
	$tools_winget_searchtabcontrol1.Visible = $false
	$upload_intunewin_tabcontrol2.Dock = 'None'
	$upload_intunewin_tabcontrol2.Enabled = $false
	$upload_intunewin_tabcontrol2.Visible = $false
	$package_ScheduledTask_tabcontrol2.Dock = 'None'
	$package_ScheduledTask_tabcontrol2.Enabled = $false
	$package_ScheduledTask_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Dock = 'None'
	$package_weblink_tabcontrol2.Visible = $false
	$package_weblink_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Dock = 'None'
	$Remediations_winget_tabcontrol2.Enabled = $false
	$Remediations_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Enabled = $false
	$package_winget_tabcontrol2.Visible = $false
	$package_winget_tabcontrol2.Dock = 'None'
	$package_msi_tabcontrol2.Enabled = $false
	$package_msi_tabcontrol2.Visible = $false
	$package_msi_tabcontrol2.Dock = 'None'
	$package_exe_tabcontrol2.Enabled = $false
	$package_exe_tabcontrol2.Visible = $false
	$package_exe_tabcontrol2.Dock = 'None'
	$config_tabpage.Enabled = $false
	$config_tabpage.Visible = $false
	$config_tabpage.Dock = 'None'
	$download_MSSTore_tabcontrol1.Enabled = $false
	$download_MSSTore_tabcontrol1.Visible = $false
	$download_MSSTore_tabcontrol1.Dock = 'None'
	$Powershell.Enabled = $False
	$Powershell.Visible = $false
	$Powershell.Dock = 'None'
	$updatepackage_msi_tabcontrol1.Enabled = $false
	$updatepackage_msi_tabcontrol1.Visible = $false
	$updatepackage_msi_tabcontrol1.Dock = 'None'
	$updatepackage_exe_tabcontrol1.Enabled = $False
	$updatepackage_exe_tabcontrol1.Visible = $False
	$updatepackage_exe_tabcontrol1.Dock = 'None'
	$tools_chocolatey_tabcontrol1.Enabled = $false
	$tools_chocolatey_tabcontrol1.Visible = $false
	$tools_chocolatey_tabcontrol1.Dock = 'None'
	
	$file_tabcontrol1.Enabled = $true
	$file_tabcontrol1.Visible = $true
	$file_tabcontrol1.Dock = 'Fill'
}

$exe_addBuildingBlocksCSVButton_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $exe_packagenaam_textbox1.text
			$PacVersion = $exe_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$exe_buildingblockscsv_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
			$exe_buildingblockscsv_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$msix_addBuildingBlokcsCSV_buttonOptionalAddBuildingB_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $msix_packageVersion_textbox3.text
			$PacVersion = $msi_versie_textbox1.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$msix_buildingblocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added')
			$msix_buildingblocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$tools_choco_addBuildingBlocksCSVButton_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $tools_choco_displayname_textbox3.text
			$PacVersion = $tools_choco_appversion_textbox3.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$choco_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
			$choco_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$winget_addBuildingBlocksCSVbuttonOptionalAddBuildingB_Click={
	#TODO: Place custom script here
	#TODO: Place custom script here
	$BBSystemContextfolder = $null;
	#TODO: Place custom script here
	#Add-Type -AssemblyName "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
	[void][System.Windows.Forms.MessageBox]::Show("Please open BuildingBlocks.csv", 'Select BuildingBlocks.csv') # Casting the method to [void] suppresses the output.
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		
		if ($BuildingBlocksCSVContent.systemcontext -like $true)
		{
			$BBSystemContextfolder = $BuildingBlocksCSVContent.systembuildingblockslocation
			$config_packagefolder = Get-Variable -Name 'config_packagefolder' -ValueOnly -Scope Script
			$PacName = $winget_displayname_textbox1.text
			$PacVersion = $versie_textbox2.text
			if (!(Test-Path "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks"))
			{
				mkdir "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Force
			}
			try
			{
				[void][System.Windows.Forms.MessageBox]::Show("Depending on the size of the Building Blocks, this may take a while.", 'Please wait while the Building Blocks are being copied to the package source directory.')
				Copy-Item $BBSystemContextfolder "$config_packagefolder\$PacName\$PacVersion\source\BuildingBlocks" -Recurse -ErrorAction Stop
				[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
				$winget_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
			}
			catch
			{
				[void][System.Windows.Forms.MessageBox]::Show("Cannot copy System context Building Blocks to current package", 'Error')
			}
		}
		else
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please click create Intunewin to continue", 'Building Blocks added') # Casting the method to [void] suppresses the output.
			$winget_buildingBlocksCSVtextbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		}
	}
}

$upload_LoadBuildingBlocksg_button1_Click={
	#TODO: Place custom script here
	$upload2_IntuneWinFile_textbox1.Text = $null;
	$upload2_DisplayName_textbox2.Text = $null;
	$upload2_Publisher_textbox1.Text = $null;
	$upload2_AppVersion_textbox1.Text = $null;
	$upload2_reglocation_textbox2.Text = $null;
	$upload2_regValue_textbox1.Text = $null;
	$upload2_installCMD_textbox1.Text = $null;
	$upload2_uninstallCMD_textbox1.Text = $null;
	$upload2_context_textbox1.Text = $null;
	
	if ($BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.ShowDialog() -eq 'OK')
	{
		[string]$BuildingBlocksCSV = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		$upload_configLoaded_textbox3.Text = $BuildingBlaocks_OpenBuildingBLocksCSVopenfiledialog1.FileNames
		$upload_checkboxSetupAssignmentLikeP.Enabled = $false
		try
		{
			$BuildingBlocksCSVContent = import-csv $BuildingBlocksCSV -ErrorAction Stop
		}
		catch
		{
			[void][System.Windows.Forms.MessageBox]::Show("Please try again", 'Error loading BuildingBlocks.csv')
		}
		
	}
	if ($BuildingBlocksCSVContent -ne $null)
	{
		$systemcsvLOC = $BuildingBlocksCSVContent.systemcontextconfig
		$usercsvLOC = $BuildingBlocksCSVContent.usercontextconfig
		if (($BuildingBlocksCSVContent.usercontext -like $true) -and ($BuildingBlocksCSVContent.systemcontext -like $true))
		{
			$upload_panel2.Enabled = $true
			$upload_panel2.Visible = $true
			$ConfigCSVImport = $null
			$ConfigCSVImport = Import-Csv $systemcsvLOC
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $systemcsvLOC.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload_context_textbox1.Text = $context
			$ConfigCSVImport = $null
			$ConfigCSVImport = Import-Csv $usercsvLOC
			$itwnf = $ConfigCSVImport.IntuneWinFile
			$filepath = $usercsvLOC.TrimEnd("config.csv")
			$itwnffilepath = $filepath + $itwnf
			$upload2_IntuneWinFile_textbox1.Text = $itwnffilepath
			
			$upload2_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
			$upload2_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
			$upload2_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
			$upload2_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
			$upload2_regValue_textbox1.Text = $ConfigCSVImport.regValue
			$upload2_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
			$upload2_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
			if ($ConfigCSVImport.context)
			{
				$context = $ConfigCSVImport.context
			}
			else
			{
				$context = 'system'
			}
			$upload2_context_textbox1.Text = $context
	
			if (!(test-path "$filepath\Logo.png" -PathType Leaf))
			{
				[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
				$upload_logo_button2.Enabled = $true
				$upload_logo_button2.Visible = $true
				
			}
			
		}
		else
		{
			
			if ($systemcsvLOC -like $null)
			{
				$ConfigCSVImport = $null
				$ConfigCSVImport = Import-Csv $usercsvLOC
				$itwnf = $ConfigCSVImport.IntuneWinFile
				$filepath = $usercsvLOC.TrimEnd("config.csv")
				$itwnffilepath = $filepath + $itwnf
				$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
				
				$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
				$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
				$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
				$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
				$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
				$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
				$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
				if ($ConfigCSVImport.context)
				{
					$context = $ConfigCSVImport.context
				}
				else
				{
					$context = 'system'
				}
				$upload_context_textbox1.Text = $context
				
				if (!(test-path "$filepath\Logo.png" -PathType Leaf))
				{
					[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
					$upload_logo_button2.Enabled = $true
					$upload_logo_button2.Visible = $true
					
				}
			}
			else
			{
				$ConfigCSVImport = $null
				$ConfigCSVImport = Import-Csv $systemcsvLOC
				$itwnf = $ConfigCSVImport.IntuneWinFile
				$filepath = $systemcsvLOC.TrimEnd("config.csv")
				$itwnffilepath = $filepath + $itwnf
				$upload_IntuneWinFile_textbox1.Text = $itwnffilepath
				
				$upload_DisplayName_textbox2.Text = $ConfigCSVImport.DisplayName
				$upload_Publisher_textbox1.Text = $ConfigCSVImport.Publisher
				$upload_AppVersion_textbox1.Text = $ConfigCSVImport.AppVersion
				$upload_reglocation_textbox2.Text = $ConfigCSVImport.reglocation
				$upload_regValue_textbox1.Text = $ConfigCSVImport.regValue
				$upload_installCMD_textbox1.Text = $ConfigCSVImport.installCMD
				$upload_uninstallCMD_textbox1.Text = $ConfigCSVImport.uninstallCMD
				if ($ConfigCSVImport.context)
				{
					$context = $ConfigCSVImport.context
				}
				else
				{
					$context = 'system'
				}
				$upload_context_textbox1.Text = $context
				
				if (!(test-path "$filepath\Logo.png" -PathType Leaf))
				{
					[void][System.Windows.Forms.MessageBox]::Show('You can use upload Logo Button to select a PNG image for the company portal', 'No Logo for Company portal found')
					$upload_logo_button2.Enabled = $true
					$upload_logo_button2.Visible = $true
					
				}
			}
		
		}
		
		
	}
	
	
	
}

$config_howtoBasicSetup_buttonOpenHowToBasicSetupO_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/basic-setup/'
}

$BB_OpenHowTo_button_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/building-blocks/'
}

$tools_choco_label5_Click={
	#TODO: Place custom script here
	
}

$buttonRefreshTenants_Click={
	#TODO: Place custom script here
	refreshTenants
	refreshTenantsUpload
}


$msi_addDescription_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $msi_packagenaam_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $msi_packagenaam_textbox1.text  -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $msi_versie_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $msi_versie_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$exe_buttonAddCustomPackageDesc_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $exe_packagenaam_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $exe_packagenaam_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $exe_versie_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $exe_versie_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$winget_buttonAddCustomDescription_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $winget_displayname_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $winget_displayname_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $versie_textbox2.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $versie_textbox2.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$msix_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $msix_packagename_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $msix_packagename_textbox3.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $msix_packageVersion_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $msix_packageVersion_textbox3.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$powershell_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $powershell_packagename_textbox.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $powershell_packagename_textbox.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $powershell_packageversion_textbox.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $powershell_packageversion_textbox.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$scheduledtask_buttonOpenSourceDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $powershell_package_name_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $powershell_package_name_textbox1.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $powershell_package_version_textbox1.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $powershell_package_version_textbox1.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$tools_choco_buttonOpenPackageDirectory_Click={
	#TODO: Place custom script here
	try
	{
		New-Variable -Name 'ActivePackageName' -Value $tools_choco_displayname_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageName' -Value $tools_choco_displayname_textbox3.text -Scope Script
	}
	try
	{
		New-Variable -Name 'ActivePackageVersion' -Value $tools_choco_appversion_textbox3.text -Scope Script -ErrorAction Stop
	}
	catch
	{
		Set-Variable -Name 'ActivePackageVersion' -Value $tools_choco_appversion_textbox3.text -Scope Script
	}
	
	if ((Show-AddDescription_psf) -eq 'OK')
	{
		
	}
}

$config_tenant_customprivacy_textbox3_TextChanged={
	#TODO: Place custom script here
	
}

$config_tenant_checkboxYes_CheckedChanged={
	#TODO: Place custom script here
	if ($config_tenant_checkboxYes.Checked -eq $true)
	{
		$config_tenant_customprivacy_textbox3.Enabled = $true
	}
	if ($config_tenant_checkboxYes.Checked -eq $false) {
		$config_tenant_customprivacy_textbox3.Text = $null
		$config_tenant_customprivacy_textbox3.Enabled = $false
	}
}

$config_tenant_info_secret_label_Click={
	#TODO: Place custom script here
	
}

$msi_howtoPackageMSI_Click={
	#TODO: Place custom script here
	Start-Process 'C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe' -ArgumentList 'https://intunepreptool.com/how-to/package-msi-example-foxit-reader-language-mst/'
}

$msi_verbose_radiobutton1_CheckedChanged={
	$msiTempinstallPar = $msi_install_par_textbox3.Text
	$msiTempUninstallPar = $msi_uninstall_par_textbox1.text
	if ($msi_radiobuttonStatusMessages.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*v', '/l*i')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*v', '/l*i')
	}
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*i', '/l*v')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*i', '/l*v')
		
	}
	$msi_install_par_textbox3.Text = $msiTempinstallPar
	$msi_uninstall_par_textbox1.text = $msiTempUninstallPar
}

$msi_radiobuttonStatusMessages_CheckedChanged={
	$msiTempinstallPar = $msi_install_par_textbox3.Text
	$msiTempUninstallPar = $msi_uninstall_par_textbox1.text
	if ($msi_radiobuttonStatusMessages.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*v', '/l*i')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*v', '/l*i')
	}
	if ($msi_verbose_radiobutton1.Checked -eq $true)
	{
		$msiTempinstallPar = $msiTempinstallPar.Replace('/l*i', '/l*v')
		$msiTempUninstallPar = $msiTempUninstallPar.Replace('/l*i', '/l*v')
		
	}
	$msi_install_par_textbox3.Text = $msiTempinstallPar
	$msi_uninstall_par_textbox1.text = $msiTempUninstallPar
}

$UploadLogo_openfiledialog1_FileOk=[System.ComponentModel.CancelEventHandler]{
#Event Argument: $_ = [System.ComponentModel.CancelEventArgs]
	#TODO: Place custom script here
	
}

$config_install_libwebp_Click={
	#TODO: Place custom script here
	$installlibwebp = @'

$Url = 'https://storage.googleapis.com/downloads.webmproject.org/releases/webp/libwebp-1.6.0-windows-x64.zip'
[string]$DownloadDir = "c:\windows\temp"
[switch]$Extract = $true
[switch]$Overwrite = $true

# Ensure TLS 1.2
try { [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 } catch {}

# Create target dir
if (!(Test-Path -LiteralPath $DownloadDir)) {
  New-Item -ItemType Directory -Path $DownloadDir -Force | Out-Null
}

$uri = [Uri]$Url
$fileName = [IO.Path]::GetFileName($uri.AbsolutePath)
$outFile = Join-Path $DownloadDir $fileName

# FIX: wrap Test-Path before using -and
if ((Test-Path -LiteralPath $outFile -PathType Leaf) -and (-not $Overwrite)) {
  Write-Host "Already exists: $outFile  (use -Overwrite to redownload)"
} else {
  try {
    $iwrParams = @{ Uri = $Url; OutFile = $outFile; TimeoutSec = 600; ErrorAction = 'Stop' }
    if ($PSVersionTable.PSVersion.Major -lt 6) { $iwrParams['UseBasicParsing'] = $true }
    Invoke-WebRequest @iwrParams
    Write-Host "Downloaded to: $outFile"
  } catch {
    Write-Warning "Invoke-WebRequest failed: $($_.Exception.Message)"
    Write-Host "Falling back to BITS transfer…"
    Start-BitsTransfer -Source $Url -Destination $outFile -DisplayName 'libwebp zip' -ErrorAction Stop
    Write-Host "Downloaded to: $outFile (via BITS)"
  }

  # Sanity check
  $fi = Get-Item -LiteralPath $outFile -ErrorAction SilentlyContinue
  if (-not $fi -or $fi.Length -lt 1024) {
    throw "Download looks incorrect or incomplete: $outFile"
  }
}

if ($Extract) {
  $extractDir = Join-Path $DownloadDir ([IO.Path]::GetFileNameWithoutExtension($fileName))
  if (Test-Path -LiteralPath $extractDir) {
    if ($Overwrite) { Remove-Item -LiteralPath $extractDir -Recurse -Force }
    else { throw "Extract folder already exists: $extractDir (use -Overwrite)" }
  }
  # Make extraction fail fast if the ZIP isn't there/valid
  Expand-Archive -LiteralPath $outFile -DestinationPath $extractDir -Force -ErrorAction Stop
  Write-Host "Extracted to: $extractDir"
  copy-item "C:\Windows\Temp\libwebp-1.6.0-windows-x64\libwebp-1.6.0-windows-x64\bin\dwebp.exe" 'C:\Program Files\IntunePrepTool\dwebp.exe' -Force
  Write-Host "dwebp.exe copied to C:\Program Files\IntunePrepTool"
  remove-item "C:\Windows\Temp\libwebp-1.6.0-windows-x64.zip" -Confirm:$false
  remove-item 'C:\Windows\Temp\libwebp-1.6.0-windows-x64' -Recurse -Confirm:$false
  Write-Host "Removed Temp files; All Done now!"
}


'@
	
	
	if (!(Test-Path "c:\program files\IntunePrepTool\installlibwebp.ps1" -PathType Leaf))
	{
		$installlibwebp | Out-File "c:\program files\IntunePrepTool\installlibwebp.ps1"
	}
	else
	{
		Remove-Item -Path "c:\program files\IntunePrepTool\installlibwebp.ps1" -Confirm:$false -Force
		$installlibwebp | Out-File "c:\program files\IntunePrepTool\installlibwebp.ps1"
	}
	
	powershell_ise -file "c:\program files\IntunePrepTool\installlibwebp.ps1"
	Start-Sleep 1
	PowershellISEOnTop
}

$menustrip1_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
	#TODO: Place custom script here
	
}

$MSIX_tabpage4_Click={
	#TODO: Place custom script here
	
}

$customWIMToolStripMenuItem_Click={
	#TODO: Place custom script here
	if ((Show-simpleWIM_psf) -eq 'OK')
	{
		
	}
}
]]></Code>
  <TV>0</TV>
  <Bookmarks />
  <BreakPoints>
    <Line Disabled="False">1689</Line>
    <Line Disabled="False">13262</Line>
  </BreakPoints>
  <TracePoints />
  <Mode>0</Mode>
  <Assemblies />
</File>